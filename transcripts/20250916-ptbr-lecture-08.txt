Então vamos lá. Então vamos lá. Na aula passada a gente estava falando de transações, tá? Transações. E para recapitular a coisa aqui, porque eu vou agora começar a construir

a meio que a segunda parte do do da coisa das transações, tá? que a gente vai chamar de consenso. Eh, mas eu vou recapitular essa história de transações porque no no meu entender de longe a ideia das transações de Bitcoin, a transação de Bitcoin é a coisa, o elemento mais importante do sistema. Tem uma [ __ ] controvérsia em relação a isso quando eu falo sobre isso, tá? Porque um monte de gente, cara, um monte de gente muito, muito mais sabida do que eu, vai falar que não, a parte mais importante é o que a gente vai chamar de consenso, que eu vou explicar um pouco melhor esses outros elementos do consenso, tá? Eh, e eu tendo a concordar, mas por que que eu digo que as transações são a coisa mais importante de tudo, tá? Porque todas as regras de consenso que a gente vai colocar, que eu vou descrever aqui para vocês e que estão implementadas no sistema e e essa coisa toda, todas elas tão estão postas no lugar para que as transações de Bitcoin façam algum sentido, para que elas possam funcionar. Então, se tem uma coisa A que tá ali para uma coisa B funcionar, para mim a coisa B é mais importante que a coisa A, tá? E segundo ponto do meu do meu minha visão pessoal sobre isso é que ali no consenso a gente vai falar sobre isso também, como que a gente muda eventualmente uma regra dessas aqui do consenso, tá? Mas é uma parte muito mais rígida do protocolo para porque para eu mudar alguma coisa, se eu a gente vai ver aqui parte sobre disso, tá? Mas em princípio, se tá todo mundo seguindo o mesmo conjunto de regras e eu unilateralmente resolvo seguir um outro conjunto de regras que é incompatível com o primeiro, eu tô me desconectando daquela primeira rede. Não é a rede que tá me expulsando, sou eu que tô falando. Não, eu tem um pessoal ali fazendo uma umas coisas e eu não concordo com o que que eles estão fazendo. O que eles estão fazendo é inválido. Então eu que tô me desconectando da rede, tá? Só que numa rede onde o o valor é você permanecer na rede, tá? Isso torna essas regras de consenso algo, tem um deference, né? Como é que fala isso em português? Tipo, é, não, mas tem uma meio que tem uma força para você não não questionar muito a regra de consenso também, tá? Isso faz com que essa parte do protocolo seja muito mais rígida, tá? ao passo aqui nas transações, nas transações, que que a gente viu nas transações? São uma estrutura de dados. Eu tô representando, logicamente aqui com os quadradinhos, né? Tem quatro campos, tá? Tem um campo de versão que eu nunca tô mostrando aqui pra gente não não interessa. Tem um um outro campo que chama lock time, que pra gente não não vai interessar aqui agora. Ele é usado para dizer quando que essa transação pode ser incluída no bloco ou não. Tem entradas e tem saídas, tá? Que é, tô representando logicamente aqui. Entradas é dinheiro que alguém tá gastando. Vou repetir. Cada entrada é uma moeda que alguém tá gastando. É dinheiro que alguém tá gastando. E se só pode gastar cada moeda uma vez. Uma vez foi gasto, acabou aquela moeda, tá? E as saídas é dinheiro que alguém tá recebendo. E repare, se eu só posso gastar uma E o que que é cada uma das moedas, né? Cada uma das saídas aqui é uma moeda no sistema. Então, sei lá, vamos pensar que por algum motivo aqui entrou, sei lá, 10, uma moeda de 10, tá saindo uma de cinco, uma de três e uma de um. uma sa, fiz referência a uma UTXO, a uma saída não gasta que tinha o valor de 10 e eu criei três novas saídas aqui nessa transação, uma de cinco, uma de três, uma de um, tá? É isso aqui. Enquanto essa saída, cada uma delas não for gasta, e o que que significa gastar? ser usada como entrada de outra transação. Enquanto isso aqui não acontecer, cada uma dessas saídas aqui é é uma moeda nesse sistema. Nesse sistema e a gente chama essas moedas aí de utxo, unspend transaction output. É a saída de uma transação e essa saída ainda não foi gasta. A diferença de por causa da taxa, não. Eu posso criar as saídas do jeito do do com o valor que eu quiser. Eu posso distribuir esses 10 aqui do jeito que eu quiser. Ficou. A única coisa que eu tenho que atentar é que a soma das saídas, a soma dos valores das saídas tem que ser menor ou igual a soma dos valores das entradas. Desde que eu respeite essa regra, posso fazer qualquer distribuição ali. Eu não posso entrar 10 e querer sair 20. A gente vai ver aqui que vai ter um caso, só um caso onde isso vai ser possível, tá? Mas é, inclusive, ela é parte do consenso, tudo bem? Mas a transação ordinária, a transação de todo dia, a esmagadora maioria delas, não, essa regra aí vai ter que ser seguida, que é meio que uma regra, é aí fazendo uma uma digressão, talvez, tá? Mas isso aqui eu tendo a entender que é quase como se fosse uma regra de conservação de uma regr de conservação, tipo conservação de energia, conservação de massa, sabe aquelas leis físicas que que são leis de simetria, tá? Quem entrou tem que sair, não sei o tá? Que é meio que a base da gente construir as teorias da física que a gente usa engenharia o tempo todo. Esse tipo de invariante, isso aqui a gente chama de invariante também, tá? É alguma coisa que que que não varia. Tem uma alguma variável, entre aspas, que não varia. uma certa quantidade, uma certa métrica que o valor dela é eu realizo um processo e o valor daquela daquela quantidade não muda. Ela pode mudar a distribuição, como é que ela tá distribuída no sistema ali, tá? Mas isso aqui de alguma forma é isso, tá? Ah, professor, mas tá. E e se a conservação que entrou tem que ser igual que saiu? É porque tem uma saída implícita aqui nesse caso aqui de um, que a gente chamou de taxa, tá? E ela pode ser coletada depois na hora de criar o bloco e a gente vai falar hoje sobre a criação dos blocos. Todo mundo OK? Tá? Repare que aqui eu tenho muito mais flexibilidade, muito mais liberdade para expressar alguma coisa do que no no nas no resto do no resto das regras de consciência que a gente vai ver hoje, tá? É aqui onde a gente expressa, lembra? Aqui nas saídas, cada uma das saídas tem um programinha de computador que expressa um certo contrato. E esse contrato diz assim:

"Quem é que pode gastar isso? Pode gastar essa saída específica. Quem apresentar os dados que fazem essa tal função f(x), que é o contrato, essa tal função f(x), o resultado dela ser verdadeiro. Qualquer um que for capaz de produzir esses dados é o dono dessa XO, entre aspas, o dono, né? Ele, repara que aqui eu não tenho uma exatamente uma noção de ah, quem é o dono do qu? Eu não disse quem é o dono do quê, eu só disse tem uma condição, qualquer um que fizer essa condição pode gastar. Eu não tô nem preocupando quem é o dono, quem não é o dono. Nenhum momento tem essa noção de quem é o dono. Tem um programa, quem consegue gerar as entradas que validam aquele programa, gasta, pronto, bola pra frente. Todo mundo bem com isso, tá? E aqui nesse contrato é um programa de computador. Um programa de computador, tá? A gente vai falar mais especificamente sobre isso e sobre a capacidade de programabilidade e sobre outras moedas que tem outros tradeoffs aqui nessa coisa, tá? Mas se é um programa de computador, o que que o programador faz? Programador programa, tá? E o que que é programar?

É o quê? Colocar um conjunto de regras e instruções pro computador. Colocar um conjunto de regras e instruções pro computador executado. Não, o que que é um programa? Isso é programar. Mas o que que é um programa? Quando você senta para codar, é isso que você tá fazendo? Você tem um objetivo. Você tem um objetivo. Fala um pouco mais sobre isso. Você recebe dados e transforma eles em algo que você Não, eu quero essa essa linha aí, ó. Você tem um objetivo, quando você senta lá para codar, você não pensa assim, todos vocês fazem isso todo dia quase. Você não senta assim, hoje eu, ah, velho, que eu vou dizer pro meu computador o que que ele tem que fazer. Você não, não é assim que você tá pensando, né? Quando você senta lá na frente, tá codando. Não é assim que a gente pensa, tá? Quero resolver um problema. Quem falou isso? Quero resolver um problema. Você senta lá e você tem uma intenção,

você tá querendo expressar a solução desse tal problema que não pode ser que você já saiba na hora que você senta lá e falar: "Ah, não, beleza, já sei como é que resolve, vai lá". só tá codando mesmo, escrevendo, mas tem as muitas vezes um processo meio que de descoberta dessa do do dessa tal. Mas repare que o que você tá fazendo ali na hora de 60 é tentando expressar uma ideia, mas tá traduzindo a sua maneira de tentar resolver aquele problema por meio de uma linguagem, por meio de uma linguagem, inclusive expressão. Tá vendo? Você tá expressando uma ideia, tá? O que que o programador faz? Programador programa. Que isso, que que eu quero dizer quando eu falo isso? Tá, programador, programa. O programador ele tá falando, ele tá tentando expressar uma ideia igual um filósofo, igual poeta, igual músico. Só que o instrumento aqui é diferente, tipo, tá? Só o instrumento aqui é, vamos chamar assim, é diferente. Isso aqui eu consigo expressar ideias.

Isso aqui eu consigo expressar ideias. Repare que aqui eu não tô preso e falar assim: "Ah, repare que não é sempre não é sempre igual". Se você pegar lá no white paper do do do Satoshi, no white paper do Bitcoin, o o Satô escrevendo, ele vai descrever essas moedas como sendo uma cadeia de assinaturas digitais. E aí na hora que ele descreve isso, ele fala assim: "Ah, na saída da transação eu tenho uma PUB key, uma chave pública. Na entrada da transação eu tenho uma assinatura. Eu tenho uma assinatura. Ponto. É isso que ele fala, tá? Que provavelmente foi a primeira ideia dele. Ah, eu eu identifico alguém com uma chave pública no sistema, então, por exemplo, quero pagar pro Como é que é teu nome, filho? Quero pagar pro Lucas. Aí vou lá, crio uma transação, escrevo a chave pública do Lucas na saída e aí na hora que o Lucas quiser gastar isso, ele vai lá e cria uma assina uma transação com a chave privada correspondente àquela chave pública que eu botei lá, tá? Só que não é isso que virou o sistema, não é isso que tá lá, não é isso que foi implementado. O que tá implementado, na verdade uma pequena linguagem de de computador, uma uma pequena linguagem de programação, tá? Que a gente viu em parte na aula passada, né, que é stack base, né, tem uma pilha e a gente vai preenchendo e operando na pilha, tá? Não me perguntem porque é uma linguagem baseada em pilha, não seria a minha primeira abordagem, mas eu reconheço que é bem é bem relativamente fácil de implementar linguagem baseadas em pilha, tá? Então, enfim, também não é uma coisa tão tão estranha assim, tá? Mas repare, eu não tô preso a esse padrãozinho aqui. Ah, eu eu eu assinatura e pub. Eu escrevo uma certa condição e a outra pessoa que se vire para fu aquela condição. Como é que eu falo isso em português, gente? Eu nunca sei. Hã, cumprir aquela condição. Isso, tá? Essa que é a ideia, tá? E já que eu tenho uma linguagem de programação, programador programa. Programador tem ideia de tudo quanto é jeito que vocês puderem imaginar, tá? Quase que o céu é o limite aqui. A gente vai ver bastante mais sobre isso, tipo de contratos que a gente pode fazer. E isso aqui é tão expressivo, parece tão simples, mas é tão expressivo que a gente consegue construir em outros protocolos. E esses outros protocolos aí são expressos nesses contratos. por exemplo, que a gente chama de camada dois ou segunda camada, não é uma uma um outro sistema, é Bitcoin também. Só que a gente tá organizando a forma como a gente vai criar aqueles contratos. Aqueles contratos, a gente tá impondo alguma disciplina naqueles contratos ali. Isso que é o que a gente vai chamar de camada dois. continua sendo transações de Bitcoin, consenso, bloco, prova de trabalho, tudo tudo igual acontecendo, tá? Eh, esses eh pequenos programas aí, eh, esses elementos de código aí, eles são rodados, são executados e por algum link aí, um interpretador, um computador, alguma coisa? Onde é que fica esse elemento que executa? Onde é que onde é que isso é executado? Se eu tenho uma rede aqui com vários nós, vou imaginar que esse esse nó aqui criou uma transação e aí propagou para cá, para cá e para cá.

Esse nó aqui, ó, quando ele viu a transação, ele tem um interpretador, ele vai validar essa transação. Então, uma das coisas que ele vai fazer é validar esses programas aqui. Ele vai executar esses programas e vai decidir, tá? Isso aqui terminou com verdadeiro ou com falso? Cada um, cada um dos programas executa que tem um que tem alguma coisa que tenha relação com a entrada, né? Porque a gente só executa os programas com, lembra? Na saída eu escrevo a f de a f dex, só que é na entrada que eu entrego qual é o valor do x. Isso não pode gerar um problema de segurança. Um problema de segurança. Fala mais sobre isso. Colocar um programa esse. Como é que é o nome, filho? A pergunta do Pedro é uma das perguntas cruciais essa coisa aqui, tá? Cara, mas se é um programa de computador, eu não posso ir lá e tentar fazer um programa que que é malicioso de alguma forma? Que que você imaginaria que seria um poderia ser um programa malicioso? C limite, o céu é o limite. Mas assim, vai, vai, vai, exercita um pouco. Por exemplo, o exemplo da Amélia, né? Exemplo na Améliia. Ah, eu posso criar um programa que fica no loop infinito. Se fica no loop infinito, quando é que esse nó aqui termina de validar essa transação? Nunca. Isso é um problema, porque isso aí é um ataque de negação de serviço, porque enquanto eu tô lá validando, eu não posso validar outra transação ou eu não posso validar um bloco, por exemplo, que imagina que essa transação tá num bloco, eu nunca vi ela antes, mas ela chegou um bloco, a gente vai falar mais pro bloco, chegou dentro do bloco, chegou dentro do bloco, eu vou validar cada uma das transações, tá lá. Aí eu tô validando aquele bloco, eu fico no loop infinito. Que que acontece? Enquanto eu não terminar de validar aquele bloco, eu não posso validar o próximo e nem o próximo e nem o seguinte e nem o seguinte. Então isso é um ataque de negação, isso é uma espécie de negação de serviço bem trivial aqui, né? Como é que seria uma solução para isso? Hã, um time out. Tem um time out. Falar assim, tá? Tem um, entre aspas, um tempo máximo. Tem um tempo máximo. Tem moedas por aí que implementam essa noção. Qual que seria outra solução? Vocês vão inventar o Bitcoin. Vai outra solução. O que o que eu tô perguntando para vocês e a variabilidade de resposta de vocês é a variabilidade de criptomoedas que tem por aí. Bora. Cada uma delas resolve isso aqui meio diferente. Não existiu de repetição. Não existiu possibilidade de eu fazer repetição. Se na minha linguagem não tem como fazer um loop, não tem esse problema. Você faz uma condição sempre que você faz um. Então, mas se não existir na linguagem, se não existir jump na linguagem, eu só posso seguir pra frente. Eu nunca posso voltar na execução.

Hã, você pode fazer algo que você não vai, não volta para trás, mas olha, se não acontecer isso, você faz e ô tá falando é interessante. Olha só, eu que eu tô colocando a sugestão da Mel, que é a sua Bitcoin é, tá? Se eu não tiver jumps ali, se eu não tiver uma forma de mudar o fluxo de de voltar na no na execução do programa, não tem esse problema de fazer um loop finito. Aí só que o P tá colocando, tá? Mas se eu quiser conseguir fazer um programa que se replica metaprogramação, é só que aí o programa para se para alterar o próprio programa, você concorda comigo que ele tem que alterar a transação? O esse programa tá na transação. Concorda comigo?

A menos que eu pudesse executar alguma coisa da pilha, né? Colocar um programa na pilha e executar alguma coisa que tá na pilha. Mas normalmente não é assim que as linguagens de programação que são baseadas em pilhas funcionam. A pilha são pros dados. Programa é mora em outro lugar. Não, mas se uma questão recursiva, mas ah, mas posso ser uma questão recursiva e essa discussão a gente vai voltar a ela porque a gente tá discutindo alguma possibilidade de aumentar a expressividade disso, porque na hora que eu falo não pode tal coisa na linguagem, não vai ter essa construção, eu não consigo fazer um loop, por exemplo. O loop é extremamente útil. Uma das primeiras linguagens que acho que foi a primeira que o con que implementou esse conceito de estas que era forf, ele armazenava tudo na pilha. É baseado no forf isso aqui. Pois é, tudo era baseado em no pilha, né? Isso. Mas no forf você consegue e voltar na execução do programa. Você tem uma noção de voltar. É total, né? Tour incomplete. Isso aqui não tem. E e é vai ser tour incomplete no caso. E é assim, o for é é muito econômico no uso de recursos, tanto é que os primeiros eh videogames, o Atalho na época, a usava o for para programar o Ah, eu nem sabia disso. No noilador se era muito pesado, o Fórum era muito compacto. Então as calculadoras HP, certamente o senhor usou também, usei. né? Usação polonesa. Sim. Que tem uma pilha lá que você vai operando numa pilha programáveis num dialeto de É muito parecido. A ideia é parecido. Cada moeda só pode ser utilizada uma vez. Isso. O que no máximo uma vez, né? Porque ela pode ser zero vezes. Sim. Mas a transação, cada transação é uma é como uma máquina de estágio, né? Que você falou. A transação não é exatamente uma máquina de estado, mas ela é a função de próximo estado. Isso tem como o cada estado que ele que ela se transforma, né, que ela a que ela passa, ele ser igual a moeda que só pode ser utilizada uma vez. Então o programa reconhece quando aquele estado já foi, ela já esteve naquele estado, ele não pode retornar aquele estado. Não sei. Aí você foi bem longe. Preciso pensar nisso que você falou. Se eu posso, se eu tô num certo estado, se eu posso voltar, não tem a pergunta para responder a sua pergunta. Se eu posso voltar para um estado que eu já tava antes. A pergunta é que é basicamente isso. A pergunta é: o que que é o estado? O que que é o estado do sistema? o valor das variáveis que tem nesse momento. O valor das variáveis que ele tem nesse momento. Tá, mas e aqui nesse sistema, o que que é o estado? A moeda que cada um tem, as transações feitas, as moedas que existem no sistema. Você concorda comigo? Isso. Então, imagina que lá no primeiro bloco a gente criou uma transação que tem uma saída de 50. Aí eu anoto, ó, tem uma uma moeda com um certo identificador. Ela tem um ID, essa coisa aqui. Tem uma moeda que eu vou chamar lá de, sei lá, Cer Coin Zer, foi a primeira que apareceu. Aí eu criei um outro bloco. Foi isso que aconteceu mesmo, tá? Que só tem uma transação, tem uma saída de 50. Aí apareceu uma outra moeda, tá vendo? Agora tem o C1 e o C0. E aí eu fui acumulando várias aqui. Até que lá no bloco 170, mostrei isso para vocês na aula passado, tem uma transação que tem uma entrada e duas saídas. Foi a transação do Satos pro Rfin, tá? O que que aconteceu nessa transação?

Uma dessas moedas aqui que tá aqui no meio, eu não sei qual é, tá? Ela foi marcada como utilizada, que ela foi utilizada agora. Tá vendo? Então, o que que que aconteceu? Eu fui lá e excluí ela de lá. Tem um banco de dados que guarda esse estado. Aí eu fui lá excluir ela e ao mesmo tempo eu criei duas novas moedas, ó. Eu vou chamar de C0 linha e de C1 linha. Olha o que o estado novo, tá vendo? Então eu tô tentando pensar assim, tá? Tem como eu voltar para um estado anterior? Porque para eu voltar para um estado anterior, eu teria que ter um estado onde não tem essas duas, mas tem aquela que já foi gasta.

Entendeu? Eu acho que de maneira regular, eu acho, não, de maneira regular não vejo como isso aconteceria. Agora eu vejo uma forma disso acontecer, que é se a gente começar a invalidar blocos, né? Sim. Mas o que tava tava colocando é assim, dentro do contrato teria uma forma de criar uma espécie de lucro? Ah, tá. Não, dentro do contrato não, porque o contrato só vê, o contrato só vê os dados que estão na pilha e uma ou outra informação sobre a própria transação.

Vou repetir. O contrato que tá executando aqui, quais dados ele tem acesso? Essa é uma pergunta que tá sendo discutida hoje, se deveria ser assim ou não, o que que a gente poderia aumentar, tá? E a gente vai falar sobre isso em algum momento, em uma aula do futuro também. Mas quais informações que esse programa tem acesso? Ele tem acesso as informações que eu vou colocando na pilha. Só que para eu colocar na pilha, a entrada tem vai executar um certo programa que vai criando dados e vai colocando na pilha. Esse programa também só tem acesso à pilha em princípio. Tudo bem? Repare os dados eles ou eles estão hard coded aqui no na entrada da transação para eu poder ir colocando eles na pilha ou eles vem de alguns pedaços muito específicos da transação. Por exemplo, quando eu vou checar uma assinatura, eu preciso de uma mensagem, não, né? Uma das entradas de verificar a assinatura é a mensagem. O que que é a mensagem? A mensagem é parte dessa transação aqui. Qual parte, professor? A parte que não tem as assinaturas. porque não tem como fazer assinatura de uma coisa que precisa de uma assinatura, tá? Mas enfim, é o basicamente é o o conjugo de dados ali da transação, tirando uma outra coisa, tirando uma outra coisa, que mais que eu posso ver da de dados que não são hard coded aqui, que são da transação? Lembra que eu falei lá do tal do lock time? Eu posso checar o lock time aqui dentro, ó, usar o lock time como entrada. Entrada, tem um opcode lá que que verifica o lock time, por exemplo, tá? Tem um outro dado, eu que eu não tô entrando em tantos detalhes. Cada uma dessas saídas aqui tem um número de sequência, tem um sequence, que é um outro campo que tem a ver com tempo também. E esse sequence também tem uma instrução, um code que eu consigo olhar e ver se checar se aquele sequence é maior, menor ou igual alguma coisa. Mas é muito restrito os dados que eu tenho acesso fora do do que tá hardod.

Tranquilo? Repare que na hora que eu tô executando esse programa, eu não tenho acesso a isso aqui, ó. O programa não, o programa que tá executando nas na nas transações não tem acesso ao estado da do sistema, a esse estado aqui, ó, de quais moedas existem e tal. A gente gostaria, a gente gostaria uma expressão muito forte. Tem várias aplicações interessantes que surgem se a gente pudesse ver esse estado na nas transações. Você várias coisas interessantes poderia fazer, mas várias coisas bastante perigosas também. Sim. Mas se ele não tem acesso a esses dados, ele só tem aquela aquela marcrita de funcionalidades, né? Como que ele vai se tornar um loop infinito? É, é aí que tá. A gente faz isso para que não possa fazer um loop infinito, pelo menos não aqui em Bitcoin. Mas aí tem outras outras moedas. Por exemplo, a segunda cripto do planeta foi Etheréum. Etheréum, se você for Etherum já mudou de objetivo várias vezes, tá? Não tô nem fazendo um julgamento de valor, mas se você vê o payp lá original, primeira ideia que tem, é uma ideia extremamente interessante. Qual que é a ideia lá do Vitalic? A ideia do Vitário que é, opa, essa essa ideia de ter contratos é extremamente interessante. A ideia do do Vitário que é essa, ó. Vamos fazer então contratos mais poderosos. Vamos colocar uma linguagem que é touring complete aqui, que a gente possa fazer o diabo aqui. Só que a gente viu que é óbvio como como faz um ataque nesse sistema, né? Tipo, é muito barato ir lá fiz uma transação que fica no loop infinito. Como é que ele resolveu esse problema? A linguagem lá no Etheréum é tour incomplete. Como que ele resolveu esse problema?

Tá na tela.

Tá na tela.

Como é que você que que você poderia usar aí? Porque para você e você pensou num time out, lembra a ideia do time out? Só que pensa que aqui, ó, eu não vou ficar olhando o tempo, porque o tempo é uma variável muito, é muito particular aqui, porque o meu node pode ser uma máquina muito rápida e eu tô rodando um outro node, uma máquina muito lenta. E aí por tempo a semântia do programa muda. Um programa vai executar por mais tempo, ele vai fazer alguma coisa diferente do programa que execut o mesmo programa que executa por menos tempo e aí o resultado vai ser diferente, tá? Eu gostaria que isso não acontecesse. Então não vou botar tempo aqui na brincadeira. Que que tem aí que vocês estão vendo aí na tela? Ó, tá aí na tela que eu poderia usar de objetivamente para limitar a quantidade de de operações que eu de tentativas. Número de tentativas. Assinatura. Não, não, não tá aí na tela.

A taxa da transação. Hã? taxa da transação. Não entendi. Taxa da transação. A taxa da transação. O que que o Vitalic pensou? O que que o Vitalic pensou? Se você executar esses contratos, é um custo. É um custo pros nós que estão executando esse contrato. Todos nós vamos executar o contrato para validar ele. Opa. Se é um custo, alguém tem que ser, quem tá executando, quem tá querendo que essa coisa seja executada, tem que pagar. Não necessariamente pagar para quem tá executando, mas quem tem que ter um custo para isso ser executado. Se eu quero que alguma coisa aconteça, eu tenho que pagar um custo para isso. Tem que ter um custo, não pode ser de graça. Que que o Vitalic pensou? Vamos usar a taxa. E aí ele separou a taxa em duas partes. Tem a tem a taxa que você paga a taxa aqui e tem um outro conceito que chama de gas gás, que é quanto dessa taxa você permite gastar para executar aquele aquele contrato. É o budget de computação que você permite em cima daquela taxa. E aí ele criou um mecanismo de limitar, tá vendo? Então você pode fazer L, pode fazer tudo que você quiser, só que você tá limitada, a quantidade de computação que vai acontecer tá limitada peloegar o teto. Se você gastar mais gás do que tá tá escrito na transação, aí isso vai precisar entrar na no na estrutura de dados de alguma forma. Se se eu tô lá executando, cada step que eu executo, cada opcode que eu executo, tem um custo diferente. Aí tem uma tabela gigante lá com com esses custos. E aí eu vou o nó que tá validando e fala: "Beleza, tem 1000 de budget". Ah, executei uma coisa de três, agora tem 997. Ah, executei uma coisa de 10, executei uma coisa de um, executei. Se eu terminar a execução e aí não acabou o gás, beleza, tá tudo bem. Eu vou validar ou não, eu vou dar check ou não check, que tem um resultado aí na mesma semântica. Se acabar o gás no meio da execução, eu vou falar que aquilo é inválido e vou seguir a vida. Professor, nessa situação daí, eh, o esse essa taxa do do ela seria paga se finanças se ela sempre baixa, certo? Não, ela é sempre paga porque ela é sempre taxa. Pois é, mas assim, eu posso converter um g infinito, fazer um programa gigantesco e no final o cara vai validar, validar, validar. Isso que nós val, mas você tem que pagar, né? Calma, imagina que eu botei uma taxa de 1000 unidades lá no no [Música] lá no Etheréum, acho que a unidade básica eles chamam de way. Botei 1000 unidades lá de de taxa na hora que você propaga a transação. O que que é essa taxa? Lembra? A taxa é a diferença entre o o que tá entrando e o que tá saindo aqui, tá? Se o teu programa for válido, válido, você vai pagar aquela taxa toda, independente de quanto gastou de computação ou não é a taxa. Pois é, mas o o quem tá validando isso aí não sabe se o meu contato é válido ou não, até ele até ele realmente gastar a computação. Até ele realmente gastar a computação. Sim. Eu preciso validar antes de de saber de saber. É porque eu não posso meter 1 milhão e o cara vai. Você tá vendo, ó? Você tá vendo como isso aqui é bem mais complexo do que parece, né? Porque eu posso ir lá e continuar ainda assim criando um monte de transações inválidas e tentando fazer um flood, né? Tá vendo? É gigantesco. Mas ó, vou te dar 1 milhão se você calcular. É, não, mas assim, a ideia, a ideia básica que você tá colocando para fazer um ataque, é isso que eu acho que vocês precisam pensar quando vocês tiverem analisando todos esses tipo de sistemas, é como que eu quebro essa parada, como que eu quebro essa parada, como que eu quebro essa parada, o que que eu faço para quebrar essa parada? Uma das coisas que você pode fazer aqui é: uai, faz um fluid, faz milhares, milhões de transações em válidos e fica propagando na rede aí, ó, porque é barato fazer a transação, é só dado, você vai lá e cria dado e fica propagando, tá? Então, preciso de algum outro mecanismo para evitar esse fluding. Normalmente, o que que esses nósos fazem aqui na rede Bitcoin faz isso, no Etheréum, eles fazem isso que é se você me mandou uma transação e a transação é inválida, eu já bloqueio você, eu já desconecto de você. Normalmente é bem agressivo assim, tipo, você me mandou uma transação, eu validei ela aqui, ela é inválida, desconecto de você e anoto que que aquele teu IP, aquela teu endereço lá é é misbehaving, né? Tipo, é e como é que é? Não se comporta bem, é causa confusão, desconecta e tipo fica aí, entendeu? Aí, então eu coloco um custo para fazer esse fluding aí. Faz sentido? Repara que eu preciso ter várias mitigações para fazer essa coisa funcionar. Existe possibilidade de você acidentalmente não dar mais suficiente para suação. Sim, pode acontecer, pode o lá no Etheréum, eu não sei detalhes do Etheréum, tá? Eu confesso para você que eu não nunca fui lá olhar o código, porque onde que tá essa informação? Tem que lá ler o códig fonte e tal, não tem não tem muito documento, tá? O que que eu o o que que eu suspeito? Não, os contratos no Ether eles são bem mais complexos, bem mais complex programas mesmo no computador assim, bem mais complexos, tá? No Etheréum, pode ser que você crie uma transação e você que tá criando a transação, você não sabe se ela é válida ou não. Ela realmente precisa ser validada, tá? Por quê? Porque ela depende do estado do do resto do sistema. No Etheréum, os as transações elas têm acesso não exatamente a esse estado aqui, mas tem um outro estado que que eles que ele tem acesso, tá? Porque ele tem a noção de no Etheréum, não tem a noção de UTX, lembra? É baseado em saldos. E aí ele tem duas noções de saldo. Tem o saldo, que é o das contas normais e tem os saldos dos contratos dos inteligentes, dos smart contracts. Então é por isso que eu tô falando, é bem mais sofisticado o negócio, tá? Mas o a transação da Eta, ela consegue ver esses saldos de alguma forma. E aí quando eu faço um programa de computador, repara que quando ele executa muda a semântica dele, porque depende de qual estado atual da rede aqui. Eu não sei em princípio. Então pode ser que eu crie um programa legítimo, não legítimo, que ele vai ser invalidado porque, sei lá, porque entrou num a rede tá num estado e eu não paguei gás suficiente. Isso não é exatamente misbehaving. Por isso que as regras lá no de na parte, isso é a parte de P2P, a parte rede, essa parte de banir o nó no Etheréo é mais complexa, porque repare, tem alguns comportamentos que não são exatamente maliciosos, tipo alguma coisa que pode normalmente acontecer de uma transação sem invalidado, mas tem, pode ter certeza, isso aqui é muito bem feito lá deles, tá? É bem mais complexo, mas é funciona. Mas esse ban nó individual esse banil nó é todas as decisões aqui elas são individuais, né? O Etheréum, Bitcoin, Etheréum, Monero, essas redes elas são em princípio descentralizadas. Que quer dizer isso? que cada nó toma sua decisão autonomamente ali e fazer soberanamente. Hã, consegue fazer um estrago, eu posso criar, qual que é o custo para eu criar novos nós que são maliciosos? Qual é o custo para eu criar novos nós que são maliciosos? Ele é a história do cibil attack. Por isso que aqui é o como é que a gente vai resolver essa história do cíbil? O CB é se eu ele faz sentido se a quantidade importa, quantidade de nós importa para fazer alguma coisa aqui no Bitcoin, no Etheréum, em todas as criptoméas, o que que é a solução? Alguma forma de prova de trabalho, porque aí a quantidade de nós que você tem não importa, não importa se você tem um ou se você tem 1000. O que importa é a capacidade total deles de fazer alguma computação. Mas se você tiver 1000, nós podem ser vários, etc. Eles podem atacar outros nós vários. O que você pode fazer é, ih, agora a gente tá fazendo umas tangentes aqui, eu vou voltar o que eu ia falar antes, tá? Mas tá de boa. Se eu tenho muitos nós, eu posso fazer alguns ataques. Por exemplo, pensa que eu tenho um um nó, um nó não malicioso aqui, tá? E eu tô tentando me conectar com o resto da rede, sei lá, o resto da rede tá aqui, são os pretinhos, são os os nós pretos, tá? Que que eu posso fazer? Eu posso fazer um ataque chama de eclipse. Eu posso fazer vários nós maliciosos

de forma que esse meu nó que tá tentando se conectado com o resto da rede, ele tem um limite de quantas conexões ele consegue fazer. E eu vou meio que cercando ele e de forma que ele só se conecta nesses meus nós maliciosos. Os meus nós maliciosos estão conectados no resto da rede, tá? Eles vem as coisas, tipo, tá? Mas o que que acontece? A, com esse, se esse tipo de coisa aqui acontecer, o que que eu consigo fazer? Eu consigo, eu sou controlador dos vermelhinhos, consigo controlar o fluxo de informações que aquele nó lá no meio tá vendo. Eu consigo, inclusive minerar outra blockchain e ele nunca vai ver lá o blockchain real, porque ele não recebe os, sei lá, esse azul aqui, ó, ele não vê os a blockchain dos outros caras lá, tá vendo? Ele sempre passa pelo pelos nós vermelhos. E aí eu recebo blo e falar assim, beleza, só que tira esse bloco, deixa eu minerar um outro para tentar enganar aquele um nó ali ali. Isso é a gente chama de ataque de eclipse. Você tá e clipsando o nó. Mas isso aqui é bem difícil de fazer, não é simples, é viável, não é trivial. Todo mundo bem com isso? Mas isso aqui é questões de networking, né? Isso é questão de rede. Isso não tem a ver com as transações necessariamente, nem com os blocos. Seguindo, seguindo, tá? Vamos lá. Que que a gente chama de consenso? Então, que a gente chama de consenso são as regras, as regras que dizem o que que é válido e o que que é inválido, tanto para as transações quanto pros blocos. Tanto para transações quanto pros blocos, tá? Então, por exemplo, os scripts que estão rodando aqui, a semântica deles, o significado desses desses programas é um conjunto de regras que todo mundo vai precisar concordar a priori, tá? Essa regra aqui, ó, de a quantidade de valor que tá saindo tem que ser menor ou igual que tá entrando, é uma regra de consenso. Todo mundo tem que concordar a priori. Se você mudar essa regra aqui, por exemplo, você vai lá e deleta ela lá do seu nó. Você tem o código, você pode fazer o que você quiser. Você roda a regra que você quiser. Se você for lá e tirar do seu nó uma essa regra aqui e você ir lá e criar uma transação que tem valor das saídas maior que das entradas, para você aquilo é válido. Ah, foi lá, tô gastando tudo tem que gastar. A única coisa que mudou foi isso. Na hora que você propagar isso pro resto da rede, o resto da rede, cada um dos nós individualmente vai olhar aquilo, falar: "É, você quebrou essa regra aqui, então isso aqui é inválido. Ele não vai aceitar aquela sua transação. Para você aquilo é válido, para os outros não é válido. Repara que se você perdeu a sincronia com a rede, o seu estado mudou. Porque no seu estado tem saídas aqui C, C linha, bá bá, que foram criadas numa transação que o restante da rede considerou como inválida. O restante da rede nunca mudou, nunca colocou isso aqui no estado, mas no seu tem. E aí você saiu de sincronia com a rede. Na hora que você saiu de sincronia da rede, saiu meio que você se desconectou da rede, bagunçou tudo, tá? Só que repare, bagunçou você.

Problema é quando vários vocês se bagunçam ao mesmo tempo. Mas, por exemplo, digamos que esse nó ele ficou e fora de sincronia com a rede. Ele pode voltar a ter sincronia com Pode, claro que ele pode voltar a ter sincronia com a rede. Isso é absolutamente normal. Por olha nesse exemplo aqui, tem 1 2 3 4 5 6 nós. São os vermelhos. O nó um criou uma transação, mandou pro dois, pro três e pro quatro.

E pro quatro, o nós cinco e seis, eles não viram aquela transação ali acontecendo, nunca viram isso. Então, de alguma forma eles estão meio que fora de sincronia. De alguma forma eles estão meio fora de sincronia, tá? Não, como é que a gente vai resolver isso? Na hora que um deles minerar um bloco? Vamos imaginar que o dois minerou um bloco. Vou marcar o bloco como vermelhinho. Ele incluiu a transação preta lá naquele bloco, tá? Ele vai mandar esse bloco para cá, vai mandar para cá, vai mandar para cá. Vamos, vamos imaginar que esse aqui validou, esse aqui validou, esse cara aqui validou. Eles mudaram de estado num estado diferente. Esse cara aqui mandou esse bloco para cá e mandou esse bloco para cá. Depois de ter depois de ter validado, então repare que isso demora um tempo. Depois de um tempo, esse cara que viu o bloco, esse cara viu o bloco, inclusive com aquela transação preta que eles nunca tinham visto antes, foram lá, validaram tudo, viram, não, beleza, tem que mudar para esse outro estado aqui, ó, bum. E aí sincronizou todo mundo de novo. Aí, no caso, esses outros outros dois nós, eles não vão fazer a verificação, né? Todos nós vamos verificar tudo. Ah, ele não vai, mesmo que seja assim, sei lá, a maioria não vai dizer: "Ah, eu acredito que os nós vão validar tudo. Se o nós cinco entender que esse esse bloco que ele recebeu é inválido, ele simplesmente vai descartar isso e vai manter o estado que ele tava antes. Ponto final. Ele não fica falando pro outro: "Ó, nó que você que você mandou inválido, ô ô, acho que isso aqui vocês não ficam votando." Não existe isso. Como é que você sabe que a maioria? Como é que você sabe que a maioria o quê? Tipo, validou aquele aquele bloco. Não, não diz que a maioria, eu disse que todos os nossos participando da rede vão validar todos os blocos.

Isso não é muito custos não. Isso é muito custoso. É claro que é. Todo mundo tá repetindo computação o tempo todo aqui. Aí a pergunta, a pergunta eu acho que não é essa. A pergunta, mas a pergunta de 1 milhão de dólares é: tem como fazer isso sem ter um validador central?

Ah, muito melhor hã, porque o banco faz isso, não faz? Ele não valida todas as transações que passa pelo banco. O cartão de crédito não valida todas as transações que passam pelo pela operador de cartão de crédito. Eles estão validando tudo. O o cara do do o cara do do da vendinha lá do bazar, ele tá validando as transações? Não, só tem o validador central. A pergunta é: como é que você pode fazer um esquema que o validador central não consegue censurar você, por exemplo, não consegue impedir uma transação? A única forma é não, a única forma de fazer isso é não ter um validador central. Se não tem o validador central, todo mundo tem que validar. Todo mundo é um validador. Trouxe um nó, por exemplo, ele passa um tempo inativo na rede, sei lá, disponibilidade lá dele e depois ele volta. Tem que validar todas asções quearam. Excelente pergunta. Imaginar que o nosso cinco ficou fora do ar, caiu energia, sei lá, caiu a internet por algum motivo, ficou algumas horas lá fora do ar. Vários blocos apareceram aqui. Vai aparecer o bloco vermelho, ele não viu, apareceu o bloco roxo, apareceu o bloco azul e ele nunca viu. Vamos imaginar que todos os outros viram tudo, tudo isso aí, tá? Que que vai acontecer na hora que ele se conectar na rede de novo? Vou imaginar que ele conectou aqui no seis, tá? Primeira coisa que eles fazem, esses nós, el tem um processo de hands shaking lá e eles vai eles vão trocar e falar assim: "Ó, eu tô na altura tal, eu eu vi tantos blocos". E o outro vai falar: "Eu vi tantos outros blocos". Se um deles percebe que o outro viu mais blocos, ele começa a pedir ou então me dá esse esses outros blocos aqui, ó, nessa a partir daqui me dá todos esses blocos aqui. E aí ele vai recebendo e vai validando um por um. Um por um, transação por transação que tá no bloco. Então se você quiser, se eu não quis conectar agora, tem que ver desde o início do se você quiser se conectar na rede agora, um nó virgem, entre aspas, né? você vai, o seu nó vai fazer esse processo que a gente chama de IBD, que é o initial block download. Ele vai baixar cada um dos blocos do desde janeiro de 2009 até hoje. São quase são 900 e poucos mil blocos. Tem agora, né? Então ele vai baixar alguns gigas de de dados. E não não é só baixar, ele vai validar cada um desses blocos. Isso eu ainda não expliquei o que que é o bloco. Tem as regras específicas dos blocos, mas nos blocos tem a lista de transações. Para cada transação que tá no bloco, ele vai validar cada uma por uma. Pa pa pa uma por uma. É isso aí. Tá falando. Não é do minerador, não tem nada a ver com o minerador ainda. Só para você da rede. Só tô lá, tô lá sincronizando com a rede. E quanto tempo demora? Dem, depende um pouco. Quanto tempo demora? depende um pouco. Hoje é um pou é demora, depende até da tua máquina. A maior parte do do da demora aqui é o processo de validar, de de verificar essas assinaturas, tá? É a parte mais custosa disso aqui. Tem muita assinatura e é meio demoradinho. Verificar uma assinatura demora milissegundos. Pensa assim, tá? Então é meio demoradinho. Aí pensa que tem milhões e milhões e milhões de assunto para você verificar. Isso demora um tempo. Última vez que eu sincronizei o Node numa máquina, uma máquina assim, um laptop parecido com esse aqui de 2016, então o negócio já mais passado, se eu não me engano, demorou uns 5 dias, tá? Mas se tudo tá fazendo uma máquina mais constrain, né, mais lenta, vai demorar mais, mas tem algumas coisas que aceleram um pouco esse processo. Aí eu não vou entrar em tantos detalhes porque é bem específico da rede aqui do Bitcoin. Nós começamos a aula falando sobre motivações. Qual a motivação para alguém? Já podemos falar sobre isso. Eh, na minha dúvida é rápida, é só necessariamente se um nó paga umação válida é necessariamente excluído da da Não necessariamente. O seu N faz o que você quiser que ele faça, mas esse é um comportamento bastante comum. Todo mundo aqui roda mais ou menos o mesmo software, chama Bitcoin, Bitcoin Core. Todo mundo roda mais ou menos o mesmo software. Então todo mundo faz mais ou menos a mesma coisa, só que nada te Só que duas coisas você pode fazer. Ele tem vários parâmetros de configuração que você pode configurar e aí ele muda um pouco o comportamento. E você pode ir lá pegar o COD fonte, mudar alguma coisa no COD fonte. Vou mostrar algumas coisas no C fonte hoje para vocês, alguns trechinhos de coisas relativamente simples, mas que são parte do consenso. Você pode ir lá e mudar uma coisa daquelas lá e falar: "Vel, o meu, o meu agora é assim, ponto meu, vou fazer coin." Aí eu mudo uma um número lá e virou coin, acabou. Pronto, final.

Todo mundo bem, posso pra frente?

Beleza, então vamos lá. Então, a gente viu boa parte das regras das transações. Vamos ver as regras pros blocos, tá? Que que é um bloco? Que que é um bloco? O bloco é uma estrutura de dados que tem dois campos. Tem um cabeçalho, tem um cabeçalho, tem exatamente 80 bytes. Eu vou mostrar agora para vocês o que que são esses esses 80 bytes, tá? E tem uma lista de transações, uma lista mesmo assim, tipo, pega a transação, transação, eu vou chamar aqui de T0, pega a transação zero, depois transação um, depois transação dois, bá bá, uma atrás da outra até a transação N que tá incluída naquele bloco, tá? Tecnicamente aqui essa lista é só ir concatenando mesmo. B, tem a transação, depois a outra, depois a outra, depois a outra, tá? Não precisa. Cada transação ela é bem definida como é que é o passing dela. Então quando ela começa, você sabe onde ela você vai passeando ela, você sabe quando terminou, tá? Hã, aqui não é link list, é um array mesmo, assim, tipo, tudo bolão, tá? E tem um contador aqui no início dizendo: "Ah, tem tanto, tem no caso aqui n elementos no início da lista falando tem 1000 transações aqui a seguir e aí você vai pegando essas 1000 transações, tá?" Tá, mas enfim, é uma lista de transações, tá? Que que tem, que que tem nesses? E cada uma delas tem que ser válida. Tem que ser válida, certo? Assim, isso, o que tá escrito depois do é 80, 80B, 80 bytes, tá? Que que tem nesses 80 bytes, tá? Vamos lá. Que que tem nesses 80 bytes? Ih, caramba, fui lá na frente. Não era sobre isso que eu queria falar, tá? Deixa eu, antes de eu falar que que tem nesses 80 byes, eu quero falar uma coisa sobre essa transação aqui, ó, porque ainda é transação, tá? Sobre essa primeira transação que entra no bloco. Essa primeira transação que entra no bloco é uma transação especial, a gente vai chamar ela de Coinbase transaction, uma Coinbase, tá? Essa o essa e somente essa transação, ela segue regras de um pouco diferentes das outras transações, tá? A primeira regra é que ela não gasta dinheiro nenhum. Ela não gasta dinheiro nenhum. Isso não quer dizer que não tenha um TX ID e um index. Lembra que era isso que tinha no na entrada da transação? Tem um TX ID, um index, tem um script

SIG, que cria os dados para validar a transação quando eu tô gastando alguma coisa, tá? Na Coinbase transaction obrigatoriamente isso aqui é tudo zero. São 32 bytes de zero, porque isso aqui é um resto, tá? Tudo zero. E aí tudo zero indica que, tipo, você não tá gastando nenhuma delas. E o index é tudo f. É exatamente esse valor aí, tá? Tudo f, na prática é muito maior do que a quantidade de saídas que a gente conseguiria indexar aqui, tá? Mas enfim, não vou ficar mostrando porquê, mas na prática é, na prática não dá para criar uma transação com FF f, vários Fs aqui, eu nem sei quantos quantos FS são, acho que são 32 bits. Não tem como criar umas uma transção com tantas saídas assim na prática, tá? Mas enfim, isso é detalhe, tudo bem? Mas isso aqui indica para mim, sinaliza que essa aí é uma Coinbase Transaction, tá? E reparem, ela não tá gastando nenhum dinheiro. Ela não tá gastando nenhum dinheiro. O script sig em princípio, tá? Em princípio são dados arbitrages. Pode botar em princípio que você quiser aqui.

Você pode botar o que você quiser, em princípio, tá? Hoje em dia não é exatamente assim. Você tem algumas coisas, você precisa colocar ali algumas informações que são obrigatórias. Já vou comentar, mas você ainda tem um espaço de qualquer coisa você pode colocar lá. qualquer meio que qualquer coisa, tá? Meio que qualquer coisa. Foi lá que o foi nessa, foi nesse campo que o Satos botou lá aquela frase lá, né? The Times, não sei o quê, bá bá, que é aquela mensagem tá lá no no bloco Gênes, tá? É aqui, ó, nesse nesse campo que tá lá essas mensagens, porque isso aqui ele pode escrever o que, em princípio, ele pode escrever o que ele quiser, tá? Em princípio, a gente vai ver que mudou algumas regras ao longo do tempo, tá? Mas inicialmente era qualquer coisa. Tudo bem? Então, repara, eu gasto dinheiro nenhum e eu posso criar quantas saídas eu quiser. As saídas são saídas normais, entre aspas, saídas normais, tá? Tem quanto, o tem um amount e tem um script pub key, que é um contrato do mesmo jeito que diz, ó, quem é que pode gastar esse troço como era antes, tá?

Só que essas saídas aqui, elas seguem mais algumas regras adicionais. A primeira delas é uma saída dessas aqui. Tem que esperar 100 blocos para ser gasta. Então imagina que eu criei essa transação aqui, essa Coinbase, no bloco 1000. No bloco 1000 tem uma dessas. No bloco 100 tem uma dessas. Todos os blocos tem uma dessa. No bloco 1000 tem uma saída lá de algum valor nessa transação aqui. Qualquer transação, qualquer transação que tiver tentando gastar o dinheiro foi criado aqui, né? Tá criando dinheiro novo, tá? Qualquer dinheiro que foi criado aqui, essa transação só pode ser confirmada a partir do bloco 1100.

uma regra especial, uma regra de maturação, que a gente chama, tá? Para que isso, professor? Você pode me perguntar. A gente vai ver que na hora que a gente vai vendo os blocos, pode ser que eu precise reorganizar, preciso pegar alguns blocos e jogar eles fora, mesmo depois que eu já tenho validado eles, jogar fora em função de outros blocos que tm mais prova de trabalho. Isso pode acontecer. Isso é absolutamente normal, tá? Só que na hora que eu jogo um bloco fora, a Coinbase Transact vai jogar fora também. Ela vai ser invalidada. Essa transação especial aqui, ela vai vai deixar de existir. Ela só existe no contexto daquele bloco, daquele um bloco específico que foi minerado. As outras não, as outras são transações normais, tá? a gente consegue dar um jeito nelas, mas essa aqui vai ter que deixar de existir. E aí imagina que eu fui lá, minerei o bloco e aí eu já gasto, já pudesse gastar imediatamente aquele aquele dinheiro que foi criado. Aí eu fiz um pagamento para você. Aí foi lá e tal, daqui a 10 minutos, 20 poucos minutos, alguém foi lá e minerou uma prova, uma uma uma blockchain um pouco maior, invalidou aquela aquele aquela transação que criou dinheiro que eu usei para te pagar. Quer dizer que aquele pagamento que você recebeu vai ser inválido também. Então você não vai receber dinheiro nenhum. Reparou? Esse intervalo de 100 blocos aqui é feito para diminuir a probabilidade acontecer. 100 blocos é bastante bloco, tá? É tipo muito conservador. Pergunta é tá falando da Coin Base aí só. Isso. Só da Coin Base. As outras as outras os outras transações. Pode ser que na transação tenha escrito alguma coisa do tipo, ah, não, ela não é válida antes do bloco, tal. Mas isso aí é você que escreveu lá no contrato, parte do contrato, tá? Fiquei na dúvida porque você disse que ela não não tipo não tem valor, não tem não. Não diz que ela não tem valor. Falei que ela não gasta nada, não entra nada aqui. Lembra, as entradas é dinheiro que alguém tá gastando, as saídas é dinheiro que alguém tá recebendo. Na Coinbase Transaction não tem nada sendo gasto, só tem dinheiro sendo recebido, que é dinheiro sendo criado do nada aqui mesmo, literalmente. Ao contrário das transações normais. As transações normais elas não podem criar dinheiro novo, elas só pode redistribuir o dinheiro, só pode redistribuir o valor. Tá vendo? A Coinbase Transaction, não, a Coinbase Transaction, ela cria novo dinheiro, cria mais dinheiro no sistema, ela inflaciona um pouquinho o sistema. Hã, sim, tem tem limite. Já vou comentar sobre isso porque isso vai ter regras, tá? Mas vamos lá. Esses 100 blocos aqui, tá? É mais ou menos 2 horas, nem é tanto tempo assim. você contar cada bloco, cada 10 minutos aproximadamente, calibrado para ser 10 minutos, isso dá mais ou menos 2 horas. Então é super de boa. Ou sem blocos? 100 blocos. Todo mundo bem? Tá bom. Quanto que pode gastar aqui? Quanto que eu pode gastar? Tem um limite de quanto eu posso gastar. O quanto eu posso gastar nas saídas? Repare que eu posso distribuir esse quanto em como eu quiser nas saídas, tá? Eu posso criar 10 saídas, 100 saídas, 1000 ou uma saída só, que é o mais comum. Mas quanto quanto que eu posso criar de dinheiro novo a cada bloco? O quanto a gente chama de subsídio vai ser, né? O subsídio mais taxas. Vamos falar das taxas que é um pouquinho mais rápido e mais fácil. Cada uma das transações que entrou no bloco tá pagando alguma taxa. Pode ser zero inclusive, mas tá pagando alguma taxa. Essas taxas aqui é a soma de todas aquelas taxas de cada uma das transações. Perceba uma coisa, eu não sou obrigado a coletar essas taxas. Eu não sou obrigado a coletar essas taxas. Pode ser que você botou 100 satoes na numa na taxa de uma transação, eu fui lá e minerei um bloco com a sua com essa sua transação e não peguei esse sem sat, tá? Por normalmente isso é um erro, né? Pô, você vai deixar dinheiro na mesa lá e tal, tá? O dinheiro que que é que foi pago em taxa e não foi coletado no bloco que confirmou aquela transação foi perdido. Não pode mais ser coletado nunca mais. Acabou, já era. Tá? Isso aconteceu em alguns blocos lá no passado. Hoje em dia isso deve ser rarís assim, acho que tem mais de uma década que não que não acontece isso, tá? Porque obviamente você não quer deixar dinheiro na mesa, né? Você tá tá trabalhando, você quer receber o máximo possível, tá? Mas enfim, você não é obrigado a coletar essas taxas, mas obviamente os os mineradores vão coletar essas taxas, tá? E o que que é o subsídio? Subsídio é uma regra que a gente vai ter que concordar também a parte do consenso, tá? Que ela começa é arbitrária, uma regra arbitrária de falar assim, ó, o subsídio inicial é 50 bitcoins, 50 BTC, ponto final. Então, a cada bloco lá no início, o primeiro bloco criou 50 bitcoins. A gente tinha 50 bitcoins na rede, o segundo bloco criou mais 50, então agora tem um total de 100 bitcoins. O terceiro bloco criou mais 50, então agora tem um total de 150. E assim a gente vai indo, tá? O Satos ele pens, repara que isso aqui é o a essa regra de subsídio a gente vai chamar de política monetária. É a é a regra da emissão do dinheiro. É a regra da emissão do dinheiro ao longo do tempo, tá? O Satos pensou, eu não sei dizer exatamente qual foi o racional, tá? Eu não sei exatamente qual foi o racional, mas uma uma uma discussão é qual é a regra razoável para distribuir o dinheiro, tá? Qual a regra razoável para distribuir dinheiro? Primeira coisa é os o Satos podia ter minerado vários blocos antes de publicar a rede e acumulado dinheiro antes de começar a poder os outros o minerarem minerarem por si só ou fazerem parte da da rede. Ele poderia ter feito isso, tá? E isso é feito para caramba hoje em praticamente todas as coins que vocês verem por aí. Ah, teve o lançamento da moeda, não sei do quê. Pode ter certeza que aconteceu. Não tô dizendo que isso é bom, ruim, só tô dizendo que acontece. O que aconteceu? O cara foi lá, desenvolveu, botou o software e botou a entre aspas a rede, não tem uma rede ainda. Ele foi lá e pré-minerou vários e vários blocos, emitindo vários e vários dinheiros e e coletando esses dinheiros. E aí depois ele faz o que a gente chama de ICO, né, o initial coin offer, que ele vai lá e vai vendendo esse dinheiro e ele às vezes ele até lança a rede, a rede é aberta e você pode ir minerando também, tá? Você pode ir inclusive minerando, mas alguém já pré-acumulou um staking inicial aqui, tá? O Satos resolveu não fazer isso. Então, uma das primeiras coisas meio que diferencia Bitcoin é esse uma certa forma de fair distribution, tá? Uma certa forma de fair distribution. Só que o Sató ficou pensou o seguinte: "Porra, se eu a cada bloco eu emite 50, não vai ter fim isso aqui. Quanto que é o quanto dinheiro vai ter? Vai sempre ter mais, não tem limite, tá? Se isso é bom, ruim, deveria ser assim ou não, a discussão lá mais pros economistas do que pra gente, tá? Mas só to pensou, eu vou criar uma regra que vai diminuindo isso aqui, porque isso aqui é uma certa forma de inflação, uma certa forma de inflação, tá? Eu vou criar uma regra para ir diminuindo isso. E aí, o que que ele, qual é a regra que ele colocou? Isso aqui, o subsídio vai diminuir pela metade a cada 210.000 blocos. Então, no bloco zero, do bloco zero até o bloco 209.999, o subsídio era 50 bitcoins. A partir do bloco 210.000, o subsídio passou a ser 25. Quem controla isso?

Todos os nós controlam isso.

Imagina que eu tô aqui, ó, de novo lá. É, cada um dos nós precisa ir lá e e e e seguir essa própria regra, porque o que que vai acontecer? Imagina que o cinco aqui minerou o bloco 210.000.

Ah, sei lá. Vou apagar um pouquinho aqui para ter cores. Vou imaginar que esse roxinho é o bloco 210.000. Todo mundo na rede tá seguindo a regra de que ah, agora a recompensa é 25. Só que o o cinco pensou 25 nada, eu vou botar 50. Tava todo mundo aceitando 50 até agora. Aí ele vai lá e cria com Jack com 50. Na hora que ele propagar isso aqui pros outros nós, os nós vão validar esse bloco, certo? Que que eles vão ver? Uma das coisas que eles vão ver é a coinas transaction tá criando o subsídio correto? Tá criando mais mais dinheiro do que deveria. Nesse caso está. Que que eles vão fazer? Rejeita o bloco. Que que vai acontecer aqui? Nesse caso

o cinco vai sair de sincronia da rede. Estão vendo a bloquinha dele? vai ter o bloco roxo e a blochandin mais ninguém vai ter esse bloco roxo. Então não vale a Só que tem a gente vai ver aqui a história de prova de trabalho. O cinco tem um custo físico real no mundo real, não mais no mundinho de escovabit. No mundo real, o cinco teve um custo para criar aquele bloco, para criar o validar aquele bloco. Então ele já gastou algum recurso no mundo físico, máquina, energia elétrica, prédio, gente trabalhando, alguma coisa já foi gasta e aquele a recompensa que ele supostamente receberia foi rejeitada pelos outros nós. Que que aconteceu? Você concorda que ele vai perder dinheiro no mundo, no mundo real ele tá mais pobre, porque ele fez um trabalho e foi rejeitado por todo mundo. Foi rejeitado por todo mundo. Tem um incentivo monstruoso para que ele não faça isso.

Quando não for uma uma questão se for uma questão de acidente, por exemplo, não interessa qual porque seu bloco foi inválido. Foi inválido ou é inválido? Por exemplo, quando você tá na mudança da contagem, você l pode ser descontinuado, aí essa mudança. Ah, mas foi um bug no meu software. Problema seu. Você o resto da rede ela não vê isso. Ela só vê o dado que você mandou para ela. Mandou um dado e o meu novo olhar e falar assim: "Você que é válido? Se for válido eu aceito. Se não for, se for inválido, eu não aceito. Tchau.

Sim, pode acontecer a reorganização. Pode acontecer reorganização, mas isso é uma nessa transição. E quando acontece o reorg, muitas coisas podem acontecer. A gente fala de relog um pouco mais paraa frente, porque isso eventualmente vai acontecer, mas vamos, estamos falando de regras que em princípio todo mundo tá seguindo. Eh, essa a aproximação de 100 bloco ser mais ou menos equivalente a 2 horas é algo mais muito mais simples, né? Não, sempre foi assim. Sempre foi assim porque não sei pela matemática 210.000 blocos sendo 100 duas horas. não é tantrada. Então, fiz a conta errada porque na minha cabeça é você multiplica aí 100 blocos 100 blocos xes 10 é 1000 minutos divide por 60 para ver em horas tá quanto isso dá 100 divido por 6 não pode fazer assim que tá perto de dois né 210000

tá 2100 x 100 blocas ou seja 2100 vezes 2 horas É, mas cuidado porque no no duas horas ali eu tô arredondando para caramba, tá? Mas aqui nem aqui não. Dá tipo 170 dias, é meio ano praticamente. O 210.000 é não, 210.000 dá 4 anos aproximadamente.

Só fazer a conta 210.000 cada um a cada 10 minutos. Então isso aqui é dos 2 milhões, não sei quantos minutos, divide por 60, divide por 24, 365, vai dar 3.99 alguma coisa. Isso aqui dá mais ou menos calma, isso aqui dá mais ou menos 4 anos. Esse ralvin aqui dá 4 anos. Esse esse intervalo dá aproximadamente 2 horas.

Professor, eh, uma nesse subsídio aí que você falou, se a rede no futuro pensar, tipo, ah, sei lá, a gente tem pouca moeda, vamos todo mundo concordar e a partir de agora pode pegar mais se Essa é uma pergunta, essa é uma pergunta bem relevante. Deixa eu só comentar aqui como é que vai ser essa coisa da emissão e a gente para para fazer um intervalo agora, tá? Mas olha só, isso aqui vai gerar uma uma você consegue calcular como é que vai ser essa distribuição aqui ao longo do tempo, tá? Se você for olhando aqui ao longo do tempo, vai ter uma curva mais ou menos assim, ó, uma retinha, né? Tipo 50 blocos a cada 10 minutos, mais ou menos. Depois cai pela metade, depois cai pela metade. Então a taxa vai virar um negócio, uma coisa logarítmica assim, tá? A gente vai olhar rapidinho o código ali, tá? Vai ter 32 halvens no total

por conta de esse esse subsídio aqui é um número inteiro, é o número inteiro de 64 bits, se eu não me engano. E a gente vai fazendo shift pra direita, a divisão inteira, tá? Vai ter 32 halvs no total.

Esse último halvem aqui vai acontecer mais ou menos no ano 2140. E lá no ano 2140 vai ser emitido mais ou menos, é um pouco abaixo disso, tá? 21 milhões de bitcoins, que cada e cada bitcoin é 100 milhões de satóitos. Então essa quantidade toda aí é menos do que isso, tá? Se fizer a conta toda certinha dá 20 milhões, não sei quanto. Dá um dá um númerozão lá, tá? O atual foi o R que número? Oi? O atual foi o número do Ralvin de que número? Nós estamos em qual? Nós estamos, ó, o primeiro R, o primeiro primeiro halving, a rede começou em 2009. O primeiro halving foi em 2012, passou a ser 25 bitcoins, a o subsídio. Depois foi em 2016, passou a ser 12,5. Depois teve um em 2024,

202 teve um 2020 e teve um em 2024. Então teve 1 2 3 4 halvens. Até agora a recompensa hoje tá em 3.125. Eu anotei errado na minha na minha coisa aqui, tá? Mas eu tenho até o eu até separei uns gráficos aqui. Pera aí. Aí o os halvins,

o nível do subsídio, tá? Começou lá em 50. O primeiro round tá tá com as datas aqui. Ah, não consigo ah, não, eu consigo aumentar. aumentar aqui um pouquinho. Primeiro foi lá em 2012, depois foi em 2016, depois 2020, depois 2024, tá? Daqui pra frente é tudo estimativo, a gente sabe exatamente, não sabe exatamente quando vai ser, tá? Mas é mais ou menos por aí, ó. mais ou menos ali no início de 2028, depois em algum momento no início de 2032 e assim até mais ou menos o início de 2140, quando não vai ser mais emitidos bitcoins. Isso se a gente continuar seguindo essa regra aqui. Ah, professor, mas a gente pode mudar essa regra? Sim, a gente pode mudar essa regra. Como é que a gente muda a regra? É só os nós todos chegarem num consenso de que a regra não é mais aquela e agora é outra, tá? Só que isso é um mecanismo bem mais complicado. Vou falar um pouco mais sobre isso na hora que eu tiver falando mais de governança, tá? Porque eu vou diferenciar entre regras que regras que são compatíveis com as regras anteriores e vão ter regras novas que são incompatíveis com as regras anteriores. E isso faz muita diferença. Eh, todo mundo que já tem bitcoins até às vezes até alguma quantidade considerável, se você faz uma nova emissão e o seu o seu o seu valor passa a diminuir, será que o pessoal vai guardadilmente assim? Não sei. O futuro vai dizer. o futuro que vai dizer. Ã, então isso aqui é o esquema da emissão, tá? Ainda ainda só para dar uma noção de escala, só para dar uma noção de escala e da velocidade da da dessa emissão aqui, tá? A gente tá aqui, né, ó, no início do do sistema ainda. O sistema vai parar de emitir lá em 2140, daqui a mais de 100 anos, tá? Daqui a mais de 100 anos. Hoje, hoje a gente emitiu 19 milhões 900 e qualquer coisa bitcoins. Isso aí é mais ou menos 95% do supply já. Então a gente tá mais ou menos aqui assim já nessa curva. É logarítico, é muito rápido no início, tá? Então do supply novo já foi quase tudo. Já foi quase tudo, tá? 95%. Quer dizer que tem mais uns 5% aí para minerar, né, para tipo ser criado aí para ser emitido até 2140. Repare que é muito menos do que já foi hoje, tá? E tem esse tempo todo até essa coisa acontecer. Todo mundo OK? Então, em parte é para dizer, a gente não viu nem ainda como é que minera, mas em parte para dizer, cara, melhor forma, se você tá interessado em ter Bitcoin em algum momento, a melhor forma é tal, provavelmente a melhor forma é você encontrar alguém que tá disposto a trocar Bitcoin por alguma coisa hoje, porque é onde tá a maior parte do das moedas. O que tem para ser minerado tem muito pouco já. Não que não vale a pena minerar, tá? Mas enfim, já aí já é um outro já é um outro rolê. Todo mundo bem?