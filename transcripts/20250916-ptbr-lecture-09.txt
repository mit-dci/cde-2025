Vamos lá. Então, a gente tá falando de, tá, falamos da Coinbase Transaction, vai ter uma por bloco, tá? Vamos falar do bloco, do restante do bloco. Parte mais importante de todos é o cabeçário. O resto é uma lista de transações, tá? Que que tem nesse cabeçário? Tem seis campos. O primeiro campo é um campo de versão. É um campo de versão. O campo de versão ele ele não tem muita utilidade não. Tanto que a gente nem vai ficar lidando com ele, tá? O segundo campo que tem aqui é o previous block. Isso aqui são 4 bytes. Isso aqui são 32 bytes. O previous block é você dizendo qual é o bloco anterior da cadeia, da lista de blocos que você tá construindo. Você tá construindo uma cadeia, tem começa no bloco zero, depois tem o seguinte, depois tem o seguinte. Cada um desses blocos diz qual é o anterior dele. E é nesse campo aqui. Então o que que vai entrar aqui? Vai entrar o ID do bloco anterior. Já vou explicar como é que calcula esse ID, tá? Vai entrar aqui o bloco anterior. Reparem que se eu tô minerando o bloco, sei lá, 900.000, o bloco que eu que eu considero ser o 899 tem um identificador de 32 bytes, que é um hash. E eu vou pegar esse hash e vou colocar aqui nesse campo. Ponto. Tá? É assim que eu digo como que é assim que eu vou formando a cadeia. O próximo campo a gente vai ver com detalhe um pouco na sequência aqui dessa aula, tá? a gente chama de merot, tem 32 bytes também, que é um hash de alguma coisa, tá? Esse hash aqui ele é o commitment das transações. De alguma forma a gente vai comitar as transações, a gente vai se comprometer com a lista de transações que tem no bloco, tá? Já vou explicar porque a gente vai vai ter esse campo aqui. Vai ter duas dois motivos principais, mas segura ele um pouquinho. O próxima coisa que tem aqui é o time stamp. O time stamp tem 4 bytes. Isso aqui é um unix time. Unix time é quantos segundos se passaram desde o dia? 1o de janeiro de 1970. 0 horas 0 segundos. 0 minutos 0 segundos. Ah, sei lá. Alguém escolheu isso aí em algum momento e ficou. Não, alguém tava na hora que fizeram tavam codando Unix. Foi na década de 70. Alguém escolheu essa data e falou: "Ah, vamos começar a contar a partir daqui pronto segue o baile." É isso, é isso. É uma convenção, só aceita, aceita que dói mesmo. O mundo inteiro roda em cima desse número, tá? Ah, next timey tá aqui nesse time stamp a gente vai ter algumas regras, porque repare, esse time stamp ele é uma eu que tô minerando é que declaro qual é o time stamp que eu vou botar ali. Então tem a ver com o meu relógio, tá? Só que o meu relógio não tem nenhum mecanismo de sincronizar com os relógios dos outros nós. E não só isso. Imagina que eu minerei um bloco aqui agora e e demorou para propagar. Então pode ser até que o time stamp tava correto ali, mas quando você viu, o momento que você viu, já passou vários segundos ou minutos depois da daquele acontecido, tá? Então é autodeclaratório esse time stamp aqui. Então a gente vai ele ele só que ele também não pode ser qualquer de qualquer jeito, tá? porque senão ele não serve para muita coisa. Na real é que esse time stamp de verdade ele não serve para muita coisa, tá? Ele não serve para muita coisa. Se a gente tirasse esse time stamp daqui não ia fazer muita falta não. O problema é que tirar isso aqui é um vai ser um hard que é uma mudança de regra que quebra o sistema. Então a gente não mexe com isso, pelo menos não por enquanto, tá? Você Mas você define ele no no você tá criando o bloco ou depois que você termina? Eu você vai ver que tudo isso aqui precisa, eu preciso definir antes de criar o bloco ou quase tudo aqui eu preciso criar antes de criar o bloco porque tudo isso que vai entrar no cálculo da prova de trabalho, que é o que eu quero explicar agora. Como que calcula a prova de trabalho, tudo bem? Antes de inserir as transações do bloco, já tem não, calma. Uma coisa, uma coisa, outra coisa, outra coisa. Na, eu vou mostrar como é que calcula esse campo e ele tem a ver com as transações. Então, para calcular o macro root, eu preciso primeiro escolher as transações que vão entrar, não só quais, como a ordem com que elas vão entrar. Aí isso influencia macro. O time stamp não preciso, tipo, eu não, não tem nada a ver com as transações. Eu vou lá e boto um time stamp aqui. Eu vou lá e digo quanto que é, tá? Só que eu preciso dizer antes de calcular a prova de trabalho. Já vou mostrar por quê. Tudo bem?

Qual a regra que a gente vai eh em alguma certa regra só para não virar muita bagunça, tá? Esse time stamp ele vai ser considerado válido se o nó que tá vendo e validando isso aqui agora perceber que tem um slack de mais ou menos 2 horas. Então o meu relógio e o seu relógio pode estar fora de sincronia em até duas horas, tanto para mais quanto para menos. E isso é pra gente é totalmente aceitável e tolerável. Reparo que é muito tempo, tá? Mas para que que foi colocado primeira? Se tu lê o se tu lê o o white paper, tu vai ver que o Satos inclusive ele não usa essa expressão blockchain. Não existe essa expressão blockchain lá. Veio depois. Ele vai chamar de time stamp server. Porque qual é o que que é que que que esse essa estrutura de dados tá tentando resolver? Ela tá tentando ordenar as transações no tempo, dizer essa veio antes daquela. E com esse time, ele tá tentando inclusive dizer quando que essa aconteceu.

E aí repare que esse time não tem nada a ver com o time físico de quando de fato uma transação aconteceu. uma transação aqui, ó, que eu botar na lista, sei lá, uma transação qualquer que eu botar na lista, ela pode ter sido criada, sei lá, 10 anos atrás e eu resolvi botar ela agora e tá lá o time stamp entre, é como se ela fosse, tivesse sido criada agora e propagada agora. O que importa para ela é quando entrou no bloco. Todo mundo bem? Beleza, segue o baile aqui. Então, tem um time stamp lá. O próximo campo ele chama bits. Tem 4 bytes. Já vou explicar também com mais detalhe, tá? Porque ele, eu considero esse campo meio inútil. Eu nunca achei uma boa explicação do por que ele precisa estar aqui, tá? Mas ele vai calcular qual. Ele vai calcular, não, ele vai é eu dizendo, eu que tô minerando, dizendo quanto de esforço eu vou botar na mineração. Só que não sou eu. Só que por que que eu acho que isso é meio inútil? Porque eu não sou eu que escolho isso aqui. Eu vou mostrar para vocês. Não sou eu que escolho isso. Se tem uma regra já pré-definida, a gente tem que seguir a regra, tá? Então também me parece meio meio boboca. E por último, tem um campo que chamace, que ele não tem nenhuma utilidade, exceto você te dá algum espaço de você mexer nos bits para você poder mudar o o cálculo da prova de trabalho. Só serve para isso. Ele não tem nenhum significado, tá? Beleza? Como é que, como que é calculado esse áudio de trabalho? Repara que esse header tem 80 bytes, tá? Você somar aí, aqui tem 80 bytes. Isso aqui eu vou calcular um hash desse cabeçalho.

O r, esse azul tá OK para enxergar aí. Esse rche especificamente aqui é chá 256. Oxe, chá 256 duplo quer dizer, quer dizer, pega um dado X, calcula chá 256 dele,

pega o resultado disso, calcula chá 256. Por que, professor, faz duas vezes? Satos satosquis, não tem uma boa explicação também, tá? Tem um outro aí tem uma um ataque bem técnico, bem teórico de que você poderia tentar fazer em cima desses desses desse X256 por conta da estrutura dele de ir aumentando o tamanho da préimagem. Mas enfim, é um ataque de extensão que a gente chama. Mas eu não vejo como é que isso poderia ser feito aqui. Simplesmente não vejo como é que isso poderia ser feito aqui. Então acho que não precisaria desse tipo de mitigação, tá? Eh, então é basicamente o conatoquis. Não sei dizer, nunca achei também uma boa explicação. Nunca achei ninguém achando uma boa explicação. E como o Satosche sumiu, não tem mais como perguntar para ele, né? Então é é porque é, mas enfim, eu vou lá e vou calcular o rash desse cabeçalho. Repara que no hash não tá entrando, na pré-imagem não tá entrando as transações, os dados das transações, só entra o cabeçário. Isso aqui vai ser um número de 256 bits. É, você não tem 256 bits saindo, eu vou pegar e interpretar isso como um número. É um número inteiro de 256 bits, como outro qualquer, tá? O que que é a prova de trabalho válida? A prova de trabalho válida será, eu vou considerar que esse bloco tem prova de trabalho válida se esse número aí for menor ou igual a um certo número que eu vou chamar de target, um alvo. Então eu estabeleço um certo alvo, tem um número, tem um número que eu tô chamando de target. E aí eu pego o cabeçalho, calculo o resto, vai dar um número. E aí eu comparo esse número que veio do cabeçalho do do cabeçalho é menor do que aquilo. Se for, eu vou considerar que aquilo tem prova de trabalho válida. Se não for, eu vou considerar que tem prova de trabalho insuficiente, inválido. Tudo bem? Que que é minerar? Que que é exatamente minerar? Minerar é eu construir um cabeçalho que torna essa equação válida. Só que perceba uma coisa, aquele cabeçalho é pré imagem de um R, né?

Eu tô procurando um certo um R com uma certa propriedade. A gente viu que isso aí é um cálculo de pré-imagem, é um ataque de pré-imagem. A gente viu que os restos são que a gente usa são resistentes a isso. Então não tem uma forma melhor de fazer do que ficar tentando vários headers diferentes. E é isso que o minerador tá fazendo. Ele constrói o header, calcula o hash, vê se bate com o target. Não bateu, calcula outro R, mexe alguma coisa, calcula um RH, outro R, vê se bateu, se não bateu e fica seguindo nisso até funcionar. Aí a minha pergunta para vocês, o que que você pode mexer aqui para poder mudar o esse hash dos campos que vocês estão vendo aqui? O primeiro deles mais óbvio é o 11. Ele só serve para isso, para você ficar mexendo esses bits e mudar o resto, tá? Que mais que você pode mexer aí? O time stamp, [ __ ] olha aqui, ó. Você você como você pode variar bastante lá de horas, né? Você pode ir lá e dar uma mexida, até porque naturalmente você vai querer incrementar isso, sei lá, eu comecei a minerar agora, aí passou um segundo, eu já vou querer naturalmente incrementar esse time stamp. Mas repare que eu posso mexer bastante esse time stamp, posso brincar com ele. Que mais que eu posso mexer? Eu posso mexer o previous block? Não, não, não posso mexer o previous block. Não, já vamos lá. Não posso mexer o previous block, tá? Por quê? porque senão eu tô minerando em cima de outro bloco diferente, que não é o o próximo que eu quero fazer a sequência. Então isso aqui não dá. Eu posso mexer no bits, a gente vai ver que não pode, porque esse bits tá codificando o target e não sou eu que escolho esse target. Esse target tá prédefinido. Só é o mesmo sempre. Não só não é o mesmo sempre, mas como não sou eu que escolho isso aqui, tem uma regra prédefinida e é uma regra de consenso também, tá? Então eu não tenho liberdade para mexer no bits. Eu posso mexer no número de versão? Sim, sim, sim. A maioria dos bits do número, inclusive a gente usou esse número de versão, não como número de versão, mas como um bitmap pra gente sinalizar que a gente concorda com mudanças de regra ou não. Não é muito elegante, deu muita confusão, não tem uma um uma regra muito específica. Cada vez quando a gente for mudar de regra de novo, a gente vai fazer alguma coisa diferente, tá? provavelmente, mas no passado foi usado assim e hoje basicamente os eh praticamente todos os bits aqui você pode mexer do jeito que você quiser. Então tenho liberdade para isso. Tu pode mexer a Merc Root, tu pode mexer, mas como que eu mexo isso? Isso aqui é o resto de alguma coisa. Como que eu mexo nessa mer? Hã, tem que mexer na pré-imagem desse rest, certo? Tem que mexer na pré-imagem desse rest. E se a pré-imagem desse r tem a ver tem a ver com a lista de transações, como é que eu mudo a Marc Road? Mudando a lista de transações. Eu posso reordenar elas ou eu posso tirar uma, botar outra, posso tentar mexer nisso, tá? Só que repare que isso dá mais trabalho, porque eu tenho que, vocês vão ver que calcular me não é só calcular um resto, eu preciso calcular vários restos, uma estrutura, tá? Mas eu tenho um certo grau de liberdade. É isso que o minerador tá fazendo. Tá fazendo. É isso que o minerador tá fazendo. Tá fazendo nada além disso. Escolhe as transações, ordena elas, cria Coinbase Transaction, bota na lista, calcula MC Root. Aí ela entrou aqui. Merc root. Ele já escolheu o o bloco anterior, o último bloco que ele viu, ele já escolheu. Ele escolhe o número de versão. Time stamp. O bits já tá pré-definido na regra. Eles bota o bits lá, fica mexendo no macro root, no time stamp, no version, até achar um número que bate com essa regra aí. E é isso que ele fica fazendo. É só isso que ele fica fazendo. Por que que ele pode mudar o vir? Ele pode mudar o Virgin porque o Vion é uma bagunça. E porque o Virgin é o seguinte, ele, se eu não me engano, a gente começou com versão zero dos blocos, só que o o fato de você colocar lá versão 1, 2, 3, 10, 1 milhão não rejeita o bloco. Então ele continua sendo um bloco válido. A única coisa que acontece é que lá no cliente aparece uma mensagem de warning no log. Ó, alguém botou um um um número de versão meio estranho aqui, mas é só um fosse um. É, na prática a gente usa como se fosse outro NS. Não, não, só um segundo. É um pouco mais técnico isso porque alguns bits ali são travados, a gente não pode mexer de qualquer jeito, mas é a maioria dos bits é ser como nosso e é uma baita bagunça, tá? Então, perdeu o sentido original de ser uma versão. É, originalmente isso aqui servia. Quando a gente bota o número de versão numa estrutura de dados, é porque a gente quer mudar a semântica da estrutura de dados, mudando o número de versão, tá? Pra gente poder fazer upgrades. Mas na prática acabou, o pessoal já começou a usar isso aqui antes, porque o lá no início o cliente não rejeitava blocos com número de versão, entre aspas, diferente do que do zero inicial. Então ficou todo mundo OK com isso? É isso que é minerar. É isso que é minerar. O tecnicamente o que que é o processo? É isso, tá? Por que que isso a gente chama de prova de trabalho? Porque isso dá trabalho para um [ __ ] Isso dá muito trabalho. Qual que é a ideia, a ideia básica? Olha só, eu vou eu vou calcular um hash. O hash é um número, no caso aqui achar 256 de 32 bytes, 256 bits. Então eu toda hora que eu calculo um hash, eu tô, na verdade, produzindo um número entre zero, porque pode ser tudo zero e pode ser tudo um, 256 bit. Pode ser. Todos eles são igualmente prováveis, inclusive, tá? Então, o maior número é 2 elevado 255 - 1. E dentro, a gente acredita que nesse resto específico todos esses números são equipáveis, tá? Não tem uma prova formal disso, mas é, eles são muito bem distribuídos. Na prática é muito bem distribuído, tá? O que que eu tô falando? O que que eu tô fazendo com aquele target? Eu tô escolhendo um lugar aqui, um lugar aqui falando assim: "Ess aqui são números inválidos. Esses aqui são válidos. Ponto. Não tem que ser menor do que o target. O n tem que ser menor que o target. O n tem que tá aqui, ó, nessa faixa. E aí o que que eu faço? Eu abaixo o target quando eu quero deixar mais difícil. Eu levanto o target quando eu quero deixar mais fácil. E aí repare que eu tenho, inclusive se eu puder mexer o target, eu consigo controlar a dificuldade. Por que que seria útil controlar a dificuldade?

Se tiver muito difícil, não tivesse blocos e ele tá conseguindo gerar bloco. Eu quero que eu quero que a taxa de produção desses blocos seja de aproximadamente 10 minutos em média. Eu quero que em média tenha um bloco a 10 minutos. Quer dizer o seguinte, eu tô lá minerando, passou, vamos supor que passou uma hora e eu ainda não vi um bloco. É normal isso, isso acontece hoje tranquilamente. Mas eu quero ir olhando na média, olhando, sei lá, os últimos 1000 blocos, eu quero que na média eles tenha bloco de uma hora, tenha bloco de 1 segundo entre eles, mas que na média o tempo entre cada entre aquele intervalo dê 10 minutos, tá? Inclusive, isso é avaliado dessa forma, entre aspas, dessa forma. O que que a gente vai fazer? A gente vai, a cada 2016 blocos recalcular esse target. Recalcular esse target. Então, lá no bloco zero começou com um target, um target específico. Já vou mostrar quanto que era que é, tá? Começou com uma dificuldade inicial que o Satos escolheu porque ele quis, porque foi o número que ele escolheu, não sei por, tá? Escolheu o número lá, aí ele começou a minerar. Então, minerou o primeiro bloco, segundo, terceiro, tá? Na hora que chegou no 2016, no 2016 o software vai lá e pega, tá bom? Deixa eu olhar o time stamp do bloco 2015, comparar com o primeiro bloco lá que era o zero, e ver se depois de 2016 blocos tem que ter dado 2016 x 10 minutos. Aí ele olha o time stamp, vê o quanto que isso aqui foi mais rápido ou mais devagar, vê a diferença de quanto que tinha, né? Se tava foi mais rápido, se foi mais devagar. Se foi mais rápido, você diminui o target para ficar mais difícil. Se foi mais rápido, mais devagar, você aumenta o target para ficar mais fácil, tá? É essa conta que é feita. É só isso. Vou mostrar o código ali já. É isso que vai acontecer. Ponto final. Então, a cada 2016 blocos, a gente vai recalculando essa coisa. A regra é essa. Quanto que eu aumento, quanto que eu diminuo. Deixa eu até mostrar a código agora. Quanto que eu aumento? Quanto que eu diminuo? Cadê o aqui? Opa, deixa eu tirar isso daqui. Perigoso. Ah, block subsid não sei o quê. Cadê o Eu já deixei separado em algum lugar aqui. Aqui, ó. Esse aqui. Esse aqui. Diacho.

Esse aqui, meu Deus. Esse aqui é o número da dificuldade inicial que Sato escolheu, tá? Não me pergunte da onde que ele tirou isso. Mas onde que isso entra na conta? Aqui tá a conta. Tem uma função aí, ó. Calculate next work required. No no caso aqui Bitcoin core. Tô olhando a versão da master, tá? Mas isso aqui tá assim há, sei lá, muitos e muitos anos, tá? Deve tá desde o começo esse mesmo trechinho de código aí. Dá para inclusive olhar no Git aí depois, tá? Repara que ele pega, ó, o bloco, o tempo do último bloco, o time stamp do último bloco, compara com o time stamp do primeiro, viu quanto que deu a diferença, tá? E aí ele compara, ó, isso aqui é menor do que o que deveria ser, isso aqui é maior do que deveria ser. E aí ele atualiza o o esse time stamp. E repara que tem um máximo de quatro vezes aqui, ó, de ou divide por quatro ou multiplica por qu, tá? Essa é basicamente a conta que ele tá fazendo. Então ele tá olhando e fala assim: "Pô, demora demais, aumenta a dificuldade, demorou de menos, diminui a dificuldade." Ó, ao contrário, né? Demorou demais, deixa mais fácil. Demorou de menos, deixa mais difícil. Foi muito rápido, deixa mais difícil, tá? Então, repare que é isso aqui que tá acontecendo. Isso que tá acontecendo, tá? Ele tava salvando time stampar. Hã, ele tava salvando o time stamp. Ele tá comparando os time stamps. Sim, mas ele tava salvando o time, ele mexe o time stamp lá, ele vai fazer aquela conta bem ali naquele trecho. É porque ele ali ele tá olhando, dividindo, fazendo a conta em cima do time stamp para poder fazer o multiplicador no final. E aí depois tem não. Aí no final das contas tem que dar um certo número da vai dar aquela continha que a gente viu ali agora, vai dar um número que é o target que eu vou comparar com quanto que tem de prova de trabalho no bloco que é eu vou comparar com o resto do cabeçalho. Aí eu comparo o resultado daquela conta ali que tá no cord fonte com o resto do cabeçalho e vejo se vai bater ou não.

Qual o sentido de mudar o target? Excelente pergunta.

Quanto tempo demora para calcular esse esse hash aqui? Hum.

Quanto tempo demora para calcular esse r?

Quanto

a resposta que todo professor adora? Vai. Depende. Depende. Depende do quê? Do tamanho do hã não do tamanho do header não. O header é fixo. 180. Se você tivesse usando hardware específico para calcular, depende de se o meu hardware calcula esse resto mais rápido ou mais devagar. Depende da máquina que tá calculando. Concorda que se eu tiver, se eu tentar fazer isso aqui agora no meu, no meu computador aqui agora, eu vou ter uma certa capacidade de ficar mexendo nesse cabeçalho e calculando o resto até até eu achar um que bate. Se eu tiver um data center para fazer isso, porque vocês concordam que eu posso gerar vários cabeçalhos e calcular rest em paralelo aqui, ó, um não depende do outro. É extremamente paralelizado isso aqui. Se eu tiver um data center com tipo milhares de máquinas lá dentro, você concorda que, tipo, eu consigo fazer isso mais rápido pro mesmo target? Depende da capacidade de dos mineradores calcularem esse R. Por isso que é importante eu conseguir recalibrar, porque lá no início da rede, vamos supor que tava 10 minutos, aí começa a ter mais gente minerando. Que que tá acontecendo? A rede como um todo tá calculando esses rest mais rápido, então esses blocos vão começar a serem emitidos mais rápido. Para manter os mesmos 10 minutos, o que que a rede faz? Vai lá e ajusta e deixa mais difícil. Aí subiu a dificuldade, agora voltou pros 10 minutos. O que que tá acontecendo? Tem mais gente indo lá minerando, botando mais máquina para minerar. Tá ficando mais rápido de novo. Que que a rede faz? Vai lá e aumenta o target de novo. Aumenta a dificuldade de novo. Fica mais difícil para poder chegar nos 10 minutos. E é o contrário, porque percebo que eu posso fazer um ataque aqui. Imagina que eu tenho uma capacidade muito grande de de de computação. Aí eu posso ir lá e fazer o seguinte, [ __ ] vamos lá botar para minerar uma tonelada de blocos e subir muita dificuldade, porque eu vou minerar muito bloco muito rápido, muito rápido. E aí eu subo a dificuldade e aí depois eu desligo as máquinas tudo. O que que vai acontecer? Vai demorar muito para produzir os outros próximos blocos. Concorda? Porque a dificuldade foi lá para cima. Aí eu desliguei o mão de máquina, a rede inteira ficou mais lenta, vai demorar mais para emitir os blocos. Se não tivesse o ajuste para baixo também, que que ia acontecer? Ia ficar difícil, ia bagunçar tudo a coleta, não ia manter os 10 minutos. Diga. Mas o ajuste, ele você ajusta em quanto? Tipo, depende do de depende do quanto eu desloquei do do que deveria ser. Depende do quão mais rápido foi, mas tem um limite de no máximo multiplicar por quatro e no a dificuldade no mínimo e no máximo dividir por quatro pro outro lado, né? É, tem um limite assim também para não dar saltos muito loucos, tá? A gente consegue ver isso acontecendo, tá? É extremamente dinâmico. Eu separei um gráfico aqui em algum lugar que é o da dificuldade da rede aqui, ó. A curva amarela é a dificuldade da rede. Eu vou dar um zoom aqui num pedacinho em algum lugar aqui, ó, que vocês vão vendo, ó. A dificuldade tava aqui depois de 2016 blocos. Subiu nesse caso que subiu, depois diminuiu um pouquinho, subiu, diminuiu, subiu, subiu, diminuiu, subiu, diminuiu. Atribuído a tipo o quanto a rede de Bitcoin tá sendo não utilizada, mas o tem um interesse nela, assim, porque se tem mais gente, tem mais genteando, mais gente botando dinheiro físico e etc. Pode, se pode relacionar o hash essa dificuldade com tipo, com a rede está sendo mais utilizada, é, com utilização do Bitcoin, com tipo crescimento ou decrescimento, por exemplo, tem difícil dizer, né? Qual o motivo? Assim, a dificuldade vai subir, não é porque a moeda tá sendo mais usada ou menos usada, ela vai subir porque tem mais hash rate ou não. Só que é o só que se alguém tiver muito poderá ver. É, mas aqui, ó, o rate, o gráfico do hash rate da rede tá aqui, é esse amarelo aqui, ó. A gente consegue estimar, inclusive, tipo, por venos blocos, a gente consegue estimar, porque a gente consegue calcular quant na média quantos restos calcular para achar um bloco com tal target, tá? Não é difícil fazer essa conta. Inclusive, a gente tá vendo que o restate aumenta, né? Ó, tipo, aumenta, aumenta, aumenta. Tem uns episódios em algum momento aqui, ó, que abaixa, abaixa. Repara que tem, tem meio que meio que mudanças tecnológicas impactam também. Por exemplo, aqui vinha bem baixo e de repente subiu muito assim, ó, perto aqui do 2018, tá vendo? Por quê? Porque a gente parou de minerar com CPU, passou a minerar com com GPU, por exemplo. Depois teve um outro momento que parou de minerar com o GPU e começou a fazer a zic específicos para isso, circuitos específicos para isso. Aí mudou, tipo, o hash tá aumentando muito, entendeu? Então assim, a dificuldade tem a ver com esse hash rate aqui, ó.

Tem alguma correlação, mas eu não sei te dizer que o gráfico do preço tá em verde, tá? Eh, eu não sei te dizer uma tentar te chutar uma relação de causa e efeito. Se o preço sobe porque o recheio sobe ou se o recheio sobe porque o preço sobe. Uma coisa é fato. Eu tô minerando, eu tô minerando. Aí eu tenho a recompensa com subsídio mais as taxas. Se o preço daquilo, se aquilo tá ficando mais valioso, eu tenho um incentivo para botar mais máquina para minerar, né? Então, o preço subir, tem alguma explicação de puxar o hashidate para cima? Sim, mas eu não sei dizer se a recíproca também, se puxar o para cima é o que puxa o preço, porque se você parar para pensar o que que isso aqui tá fazendo, isso aqui tá protegendo a rede. Isso aqui tá protegendo a rede. Isso é um sistema de proteção na rede. Fica quanto maior esse rchete aqui, mais difícil é alguém lá e tentar bagunçar os blocos, tentar reorganizar os blocos. Então, tá cada vez mais segura essa rede nesse aspecto. Nesse aspecto, se a rede tá cada vez mais segura, faz algum sentido você pensar que aquilo tá ficando cada vez mais valioso e vale a pena começar a usar mais, né? Então não sei dizer, professor. Eh, mas sei lá, você é meio perigoso porque o minerador ele tá ali, né, querendo ganhar dinheiro. Aí ele pode criar um monte de bloco falso. E ele pode criar um monte de bloco falso. Por que que ele não faz isso?

Por que que o minerador não faz não faz o não fica minerando bloco fake aqui?

É isso que ele tá fazendo, certo? Isso aqui tem que acontecer antes ou depois dele ser pago? antes. Isso aqui tem um custo real no mundo físico. Esse gráfico que eu te mostrei aqui agora significa que tem mais gente trabalhando. Isso são empresas. Isso. Tem mais gente trabalhando para fazer isso. Tem mais máquinas que tem que ser compradas e fabricadas e compradas para fazer isso. Tem galpões que tem que ser construídos para rodar esses data centers com essas coisas. Isso aqui gasta energia, uma quantidade de energia elétrica enorme que tem que ser produzida e paga de alguma forma. Tudo isso é custo real. Isso não é um uma Isso não é uma simplesmente vem aqui e faz uma brincadeira. Acho que ele vai ganhar um sub. Mas então, mas repare que o a desconexão temporal é importante. Primeiro, primeiro o minerador paga ou incorre no custo de fazer esse processo antes de ser remunerado no sistema, entendeu? Isso quer dizer o seguinte: para eu minerar um bloco inválido e para eu minerar um bloco válido é o mesmo custo para eu que tô fazendo o processo. Se eu minerar o bloco inválido, eu não vou ser recompensado, mas eu tive o custo, eu já gastei. Qual o incentivo que eu tenho para fazer se eu posso fazer o bloco válido e pegar a recompensa lá no sistema? Então, tem um incentivo econômico para eu não para eu agir, não agir maliciosamente. Incentivo econômico é vários incentivos econômicos aqui são extremamente importantes pro sistema funcionar. Professor, e dado que a gente tem, por exemplo, aquele tempo de maturação lá do do, né, e tipo possibilidade, sei lá, reó dos bxos e tal, que a partir de que momento o minerador recebeu, ele de fato ele tem o subsídio como no saldo dele, por exemplo, ou ele pode dizer que aquele subsídio é dele já na hora que ele minerou um bloco e ele meio que já é dele, mas obviamente ele não pode gastar aquilo imediatamente.

pode gastar. A gente vai falar um pouco mais sobre esses modelos de mineração e não sei o quê, porque isso aí tem um monte tem um monte de incentivos também até meio perversos sobre isso. Tem vários ataques que eu não tô dizendo que o minador não pode fazer ataques, ele pode fazer ataques que fazem sentido. Vocês viram notícia recentemente Monero reorganizando um monte de blocos e tals. Você não viram, né? Monero, pera, Monero usa prova de trabalho também, tá? Pare mesmo, mecanismo muito parecido com isso aqui. Qual a diferença do Monero? Ele é feito, eles usam uma função de hash que é construída para não ser para não ser exatamente o detalhe, mas ela é uma função que é muito difícil você implementar em hardware. Em hardware. Então em Monero você faz CPU mining e GPU mining. Até hoje não tem um chip específico para minerar lá no Monero, igual tem no Bitcoin que é CH2 256 que é fácil de implementar errado. Eu não sei detalhes dessa função de R. Só que acontece lá, o que que tá acontecendo agora, né? Os tem uma empresa enorme que montou um data center gigante e falou assim: "Nós vamos bagunçar o rolê". Aí o que que eles fazem? Eles vão minerando os blocos válidos. Vão minerando os blocos válidos. Só como eles têm um hash rate muito grande, eles mineram, conseguem minerar blocos mais rápido do que o resto da rede. Só que em vez de ficar propagando isso e pegando a recompensa lá do que seria o comportamento normal, que que ele faz? Ele minera e guarda o bloco aqui. Ele minera o próximo e guarda com ele. Ele minera o próximo e guarda com ele. Então ele vai montando uma blockchain paralela só dele aqui. E aí o resto da rede tá lá montando outra blockchain, tá? Aí vamos imaginar que o resto da rede, sei lá, minerou. 17 blocos, sei lá, 10 blocos, 20 blocos. Que que eu faço? Eu comigo aqui já tenho 50 blocos válidos. Aí eu propago todos os 50 de uma vez só. Bum. Que que vai acontecer na rede? Todos aqueles aquelas blockchain, aquela topo daquela blockchain legítima que a rede tava achando, tava minerando, vai ser reorganizada. Eles vão olhar e falar: "Ah, tem uma outra blockchain agora aqui com mais prova de trabalho, é essa que a gente vai seguir." Então, tira, vai tirando aquelas aquelas outras que a gente minerou aqui e encaixa a nova que agora a gente viu agora a nova. Só que o que que é o problema de você fazer isso? Em princípio não é para perder transações, tá? Pode invalidar uma coisa ou outra, mas em princípio não é para perder transações. Só qual que é o problema disso? Quem tava minerando lá a outra blockchain que foi reorganizada, perdeu dinheiro para caramba, né? porque gastou, fez o trabalho, tava sendo, em princípio remunerado e aí de repente perdeu a remuneração

completamente dentro da regra. Mas qual que seria o incentivo desse cara fazer esse cara perder? Se você tem muito hash rate, você faz o outro cara perder tempo. E isso é um business, é negócio. Isso aqui não é só, isso aqui não é só um protocolo. Isso aqui tem empresa, tem empresa pagando funcionário a parada toda. Aí imagina que você foi tendo receita ou esperava ter a receita, de repente você não tem mais a receita, só que você já teve o custo. Então você já faliu seus é faliu o seu concorrente. Isso é muito arriscado ao mesmo tempo também. Claro que é tudo é muito arriscado. Você tem que garantir que você vai conseguir sempre eh arrumar a voto mais rápido isso. Quando a gente vê um pouco mais de detalhe de minerações, incentivos e governança, a gente vai falar um pouco mais sobre esses ataques também de esse. Isso que eu descrevi para vocês, a gente chama de selfish mining. É o minerador egoísta. Ele minera os blocos, mas ele não mostra pros outros. Tem outros ataques possíveis. Dá para fazer na rede de Bitcoin? Dá. na rede Bitcoin é mais difícil porque a rede tá muito grande, mas também é o mesmo problema. Mas por enquanto tá bem, por enquanto podemos seguir a gente abre espaço porque uma empresa muito grande no Facebook, Google da vida. Sim, mas a questão é que o o por que que dá para fazer no Monero? Porque a rede é relativamente pequena em termos de capacidade computacional. E não é porque a rede é pequena, porque tem poucas, poucos participantes. Tem até bastante, tem até bastante nós, mas a rede é pequena em termos de capacidade computacional. Na rede do Bitcoin, o Bitcoin é várias ordens de grandeza, a rede como um todo hoje é várias ordens de grandeza, maior do que todos os datacentes, de todas as grandes empresas governo a [ __ ] toda junto. A rede do Bitcoin é maior do que isso em termos de capacidade computacional. O Bitcoin é o maior computador do mundo de muito longe, entendeu? Esse é o rolê, esse é o problema. A rede hoje é muito grande pra gente fazer isso. Não tô dizendo que é impossível, tô dizendo que é mais complicado de fazer, porque a rede é muito grande. Dá para fazer? A gente vai ver um pouco melhor quando a gente for falar de PS, de mineração e porque porque de novo isso tudo é business. Tem o business por trás, tem seus negócios, tem as empresas e as empresas vão precisar ter, elas têm outros incentivos econômicos que elas precisam responder também. Aqui eu só tô falando do protocolo por enquanto. É com esse restente alto hoje assim, a gente pegar, por exemplo, computador comum na CPU para minerar é quase que é uma piada, não faz nem cosquinha pro pra rede. É melhor tu nem fazer isso. Vai tá gastando. Tu pode dar sorte. Claro. Tem a chance. Ah, você pode calcular inclusive a chance. a a a dificuldade, a probabilidade, é mais fácil você ficar jogando na mega cena e tentar ganhar na mega cena na prática. Agora, tanto que tem um certo movimento de que chama lottery mining, que é você fazer isso aí, você ficar lá minerando, sabendo que provavelmente você não vai fazer, não vai fazer nem cosquinha aqui, né? Mas se você encontrar um bloco, três Bitcoin, quanto é que tá valendo isso? Mais as taxas, Rõ R milhõesais 15 milhão né? R 2 milhõ, sei lá, uns R 2 milhõesa. É, também não tá mal, né? Tá, mas tem outras coisas que você pode fazer que faz que não são lottery mais mais rentáveis. Não sei se dizer mais rentáveis, mas de novo, que que geram outros incentivos que as pessoas se vem incentivadas a fazer. a gente comenta um pouco mais paraa frente. Deixa eu seguir aqui porque eu tô falando de consenso ainda, mas vocês estão vendo que, tipo assim, é meio que impossível falar de uma coisa porque cada pedacinho do protocolo abre uma margem monstruosa para vários fenômenos que estão acontecendo, tá? E por que que é parte da disciplina que a gente tá tentando fazer? É mostrar o protocolo para vocês, até para vocês olharem outras moedas e outras fenômenos acontecendo e entender, tá? Mas por que que isso acontece? Não tem como você entender aqui que tá acontecendo lá no Moner entender isso aqui, como é que é o mecanismo técnico aqui, né? Tipo, o que que tá acontecendo? É isso que tá acontecendo. E aí vocês estão vendo aí os problemas, tudo isso precisa de mitigação, precisa de gente pensando como é que vai resolver isso. Tudo isso precisa. Tem gente que precisa resolver o lado de businesses, negócio e tudo isso tem que ser resolvido. Vamos ver o protocolo. Então, quando você vai trabalhar na rede Bitcoin, você trabalha nessa parte de resolver esse problema. Ou você pode estar implementando criptografia, ou você pode estar implementando, sei lá, um monte de coisa.

É, mas tipo, por exemplo, vai que eu vai que eu quero, vai que faz sentido adicionar uma regra nova aqui no sistema. Alguém precisa implementar isso, alguém precisa testar isso, alguém precisa convencer os outros de que isso é útil. Como que essa pessoa quer ser? Vou falar um pouco mais sobre isso, o lado soft dessa remuneração numa aula, numa aula separado também. Como é que alguém se remunera sobre isso? Por enquanto vamos ficar aqui no protocolo por enquanto. Podemos seguir. Professor, só uma dúvida. Então o bloco aí, tipo, que vai ser aceito é qualquer um que achar o esse target ou vai ser tipo sei lá o que chegou mais perto, chegou um bloco para mim e ele tem prova de trabalho suficiente, eu aceito. Eu, claro, isso é um critério do consenso. Eu olho, primeira coisa que eu olho, tem prova de trabalho suficiente? Se não tem, te joga fora, não serve para nada. Se tem, eu vou olhar os outros, os outras coisas. Por exemplo, eu vou olhar, tem uma Coinbase transaction, o subsídio tá correto, as taxas estão corretas, entendeu? A mercot tá correta. Eu vou olhar cada uma das transações é válida, blá blá, entendeu? Vou validar a coisa toda, mas a primeira coisa de todos que é observada é o bloco. A primeira primeira de todos é o bloco é sintaticamente válido. Sintaticamente quer dizer que tem esses bytes nessa ordem aí e eu consigo parciar isso porque senão não adianta nada, tá? Sim, cheque. A segunda coisa que eu vou olhar é prova de trabalho é válido. Se não for, não tem conversa. Tudo bem? E diante de dois blocos igualmente válidos, qual que eu vou escolher? O que tiver mais prova de trabalho. Eu vou estar sempre olhando, falando onde tem maior prova de trabalho. Onde tem maior prova de trabalho é onde eu vou ficar. Qual é a prova de trabalho? Qual que foi mais difícil de minerar? Qual foi mais difícil de minerar? Olha só essa sobre essa coisa. Sobre essa coisa. pergunta. Eu vou tentar passar uma intuição e depois eu explico como é que calcula o target ali, tá? O target não, o o bits que eu falei para vocês que tinha a ver com o target e eu quero ainda explicar a mote hoje, mas vamos lá. Vamos lá. Deixa eu passar uma inção para vocês, porque vocês vão olhar na internet por aí direto falando assim: "Ah, prova de trabalho tá procurando o número de zeros no no começo do do do hash". É normal você ver por aí, tá? Isso aí é parcialmente correto, tá? Não é isso que a gente tá olhando. O que a gente tá olhando é isso aqui, tá? Ó, se esse rche eu calculo, eu vejo aquilo é um número. É um número, um número com muitos caracteres, mas é um número. Eu vejo aquele número, aquela quantidade é menor do que uma outra. Não tem nada a ver com o número de zeros, mas obviamente o número que tem muitos zeros à esquerda é o número menor. Então vai ter mais vai ter a ver com isso aqui, tá? Mas não é número de zeros que a gente tá olhando. Mas vamos supor que fosse número de zeros, tá? Imagina que eu tô procurando um hash que tem um 1 bit zero e qualquer coisa depois. 1 bit z0 é o não, ele é 0 1 1 1 1. Isso aqui é 7. Não, isso aqui é 7. Então é 7 F.

Tudo F. Vamos supor que eu tô procurando,

procurando algum número que satisfaz isso aí, um número menor do que esse aí. Para um número ser menor do que esse aí, basta ele ter um zero na frente. Você concorda? Menor ou igual que esse aí, basta ele ter um 1 um bit zero na frente, tá? Tá. Pergunta aqui para vocês.

Nesse intervalo que eu desenhei aí, ó, de zer tem 2 a 2 56 números aí nesse intervalo. Onde estão os números que são menores ou iguais aqui? Esses 7F FF aí? Hã? Da metade para baixo. Metade dos números começa com zero. Metade dos números começa com bit1. Então, se eu tô procurando esse número aqui, um número menor do que esse, o meu target tá aqui, né? Ó, metade. Vocês estão vendo? Tá? Se eu tiver procurando um número que começa com dois zeros, com dois zeros é 3 F f tudo F.

Onde que eles estão? na metade da metade. Na metade de baixo da metade de baixo. Então vocês concordem comigo quando eu boto mais um zero na frente aqui, ó, é o intervalo de coisas válidas. É uma máscara. Hã, faz uma máscara. É, tá, mas é, vocês estão vendo que toda hora que eu peço um zero a mais, eu tô dividindo por dois. Então, essa coisa é exponencial. Repara que pedir um zero a mais dobra a dificuldade, tipo, diminui pela, é muito, não é, não é um ajustezinho pequeno, é um, pá, eu tio, eu tiro fatia zona grande do que, do que poderia ser. Eu tiro uma big fatia do que poderia ser, tá? Tá. A dificuldade cresce exponencialmente, se fosse isso, como não é isso, não é exatamente exponencialmente. A gente tem algum ajuste um pouco mais fino do que isso, mas não é muito mais fino do que isso aqui, não, tá? Não é muito mais fino do que isso. Eu não vou calcular exatamente quanto que é o ajuste, mas é perto disso aqui que vocês estão vendo. O bloco inicial, o bloco zero lá, o Gênesis, a o bits dele, né, o target dele era ele era esse número aqui, ó, 1 D00 FF FF. A gente viu ali no código. Que que isso aqui quer dizer, tá? Isso aqui é um número entre aços em ponto flutuante. Isso aqui é a mantiça. Isso aqui é o expoente. Número em ponto flutuante é alguma coisa que você escreve como sendo m x 2 elevado ao expoente, tá? M x 2 ao expoente. Nesse caso particular aqui do do Bitcoin, a conta é 8 vezes o expoente -3. Ah, professor, por quê? Porque o Satos quis, gente. Tipo assim, toda a resposta é porque o Satoshi quis, tá? Mas vamos ler isso aqui, tá? Porque isso aqui é mais fácil de ler do que parece. Como é que eu traduzo isso aqui numa num número mesmo? Porque eu preciso dos bits lá para poder comparar os dois números, tá? Eu vou traduzir assim, ó. Amantiça, 0 0 F f.

Um número vezes 2 é, vocês lembram disso? Sistema digitais? É deslocar um bit pra esquerda.

Cada um bit que eu desloco pra esquerda multiplica por 2. Então 2 elevado 8 é multiplicar 1 byte pra esquerda.

Quantos bytes? Esse tanto de bytes 1 D é 29 - 3 26. Então vou deslocar 26 bytes pra esquerda. Essa quade, esse número aí deslocado 26 bytes pra esquerda. Que que significa isso? botar um monte de zero aqui

que soma 26 bytes, tá? Cuidado que isso aí são 52 zeros. Aliás, é 52 zeros.

Dá 26 não, o excessimal de 1D é 29, tá? Só que tem esse -3 aí, tá? 26 mais aqui tem aqui tem mais 3 bytes, então dá 29 bytes. O número tem que ter 256 bits, ainda faltam 3 bytes. A gente completa com zero aqui. Hã, 128

bytes, não, 26 by, sei lá quantos zeros dá cada byte. É, é, um monte, é 26 x 8 zeros. É 26 x 8. Eu não tô escrevendo bits, eu tô escrevendo bytes, tá? Aí, repara, essa aqui é a dificuldade do bloco gênis, é a dificuldade inicial que travou. E essa aqui é, inclusive no não tá hardcod no código. Isso é uma regra também. Nenhum bloco pode ter menos prova de trabalho do que essa. Não interessa se lá no início, se não tava indo a 10, a cada 10 minutos e não estava no início mesmo, tava mais devagar do que a cada 10 minutos. Não interessa, não abaixa além disso aqui, não fica mais fácil do que isso, tá? Enfim, quantos zeros tem aqui?

Não. Quantos bits zero tem aí? 64. Quantos? 64. 64 bits, não, né? 1 2 3 4 5 6 7 8. tem 8 x 4, que é 32 bit zeros, tá? 32 bit zeros. Que que quer dizer isso? Essa dificuldade aqui é perto de 2 elevado -32, né? Tipo, se eu for olhar ali, eu dividi essa coisa aqui pela metade 32 vezes. Onde é que tá mais ou menos a dificuldade inicial? Então, nessa escala aqui, ela tá tipo aqui assim, ó. Eu tô procurando números aqui, ó, nessa faixinha lá no início da parada. Onde é que tá a dificuldade hoje? Eu nem sei, tá? Tipo, mas é uma dificuldade, tá num número muito muito muito bizarro. Vamos olhar aqui, ó. O último bloco. Ixe Maria. Vamos pegar um bloco aqui qualquer. Para, me dá um bloco qualquer aqui. Vamos pegar um bloco qualquer aqui. Eu consigo dar zoom nisso? Não consigo. Mas eu consigo colar aqui. Pera aí.

Meu Deus. Cadê o cursor? Mas eu consigo colar.

Pera aí. Tá colando aí. Foi. Tá aqui o resto do último bloco, tá? Ó, olha o número que é para baixo já mais difícil do que isso, do que o que tava inicial, tá? Isso aqui é milhões e milhões de vezes mais difícil de encontrar esse bloco aqui, essa prova de trabalho. E tá ficando mais difícil cada dia. Em algum momento vai, eu acredito que vai começar a dar uma saturada, tá? Vai, mas não chegou nesse momento ainda, tá? É isso que essa rede tá fazendo. É isso para vocês terem uma uma noção aqui de o que que é essa dificuldade. Por isso que é difícil. É difícil, é para ser difícil mesmo calcular esse troço aqui. Tem que dar trabalho mesmo. Quanto mais trabalho der, mais segurança tem nessa rede.

Isso é o que garante que quando eu vejo um bloco, é porque provavelmente esse bloco, quando eu vejo um bloco e ele tem prova de trabalho válida, é porque o cara que fez isso aí não tá querendo me sacanear, porque isso aqui é muito caro de fazer no mundo real. Isso é muito caro de fazer. Esse isso aqui é muito caro de fazer.

Então eu tenho uma certa expectativa de que alguém não vai fazer isso para arriscar não receber alguma coisa em troca. E quanto mais difícil for fazer isso, melhor nesse sentido. Todo mundo entendeu o que que é a prova de trabalho? Isso aí é o que vai codificar nesses bits, tá? Isso aqui é recalculado. A gente viu aqui a cada 2016 blocos pergunta: "Prof, eh, você falou que você recebe oito blocos anos?" Hã, eu escolho o que tem mais prova de trabalho, certo? Isso. E você aplica blocos anteriores também? Também se você aplica blocos anteriores a história da prova de trabalho. Sim. Olha só, cada um desses blocos aqui tem uma prova, foi calculado, tem um trabalho executado em cima dele. Repara que é muito difícil de criar esse bloco, mas é muito fácil de verificar. Eu só preciso pegar o cabeçalho, fazer o r e acabou. Tipo, eu faço o resto uma vez só para verificar. É muito barato verificar. é muito caro de construir o bloco, tá? Aí eu vi o bloco vermelho. Eu vi o bloco vermelho que encaixou, ele é o bloco, sei lá, 0 1 2 3. E aí eu tô vendo um outro bloco três linha concorrente. Que que quer dizer o vermelho e o três linha concorrente? Quer dizer que no previous block tá igual, eles estão minerando em cima. Eles consideram que o anterior é o mesmo, tá? Bem fácil de checar isso aqui também, né? Quando eu vejo um e quando eu vejo o outro.

Vamos supor que no que esse bloco vermelho tenha X de prova de trabalho e que esse cara aqui tenha Y e que o Y é menor do que o X. Em princípio, eu vou jogar fora o o bloco azul em favor do bloco vermelho, porque ele tem mais prova de trabalho. Só que pode acontecer de alguém viu esse bloco azul e considerou que vai trabalhar em cima deles, não tem problema. E ele foi lá e minerou outro bloco que é o quatro linha. E aqui acumulou mais prova de trabalho do que aqui, ó. O que que eu tenho que fazer quando eu vejo isso? O meu novo vai fazer, o meu novo vai pegar e falar: "Nossa, tô vendo um bloco, tô vendo um bloco que tem, que gera uma cadeia concorrente daquindo aqui. E essa cadeia concorrente tem mais prova de trabalho, acumulou mais prova de trabalho. Isso aqui a gente vai chamar de reorganização. Eu vou desconectar esse bloco daqui. Aí esse desconectar esse bloco daqui, ó. Tipo, você pode pensar, vou só jogar fora, mas é um pouquinho mais sofisticado que isso, porque tem um monte de transações e são transações que eu já validei, que eu considerei aquele bloco válido. Então eu quero guardar aquelas transações comigo pro caso de eu ver elas de novo em outro bloco e não precisar refazer o trabalho, tá? Então a gente guarda essa informação, mas enfim, jogar aquilo e vou passar a considerar essa aqui a minha blockchain. Isso aqui é o que a gente chama de reorganização. No caso aqui eu reorganizei um bloco, que foi o bloco vermelho. É relativamente comum a gente ver reorganização de um bloco na na rede Bitcoin. A cada, sei lá, duas semanas, um mês, não é tão comum mais, tá? No passado era mais reorganização de dois blocos tem meses que não acontece. De três blocos, tem anos que não acontece. perguntado na rede real, na prática, quantos blocos tem que ter e garantir que não vai? É muito raro, é muito, tá muito raro você ver reorg de um bloco já, porque esse, essa, isso aqui depende não só da prova de trá, mas depende de quanto tempo demora para esses blocos se propagarem. Aí isso depende de quanto tempo demora para um nó validar o bloco e passar pro próximo, entendeu? A medida que a gente foi melhorando o software, isso foi ficando mais eficiente, a propagação dos blocos vai ficando mais rápida na rede. Então a probabilidade de eu eu minerei um bloco e você também tá minerando e aí eu te mandar esse bloco ou esse bloco que eu minerei chegar em você, você passar a minerar em cima do do próximo. Repara que esse intervalo de tempo é o que gera esse esse conflito. Esse tempo passou a ser milissegundos hoje. Então é, você fica muito pouco tempo minerando um bloco, sendo que em algum lugar da rede já apareceu o bloco que já desfaz o seu trabalho, entende? Aí você já vê e já passa a trabalhar em cima do próximo. Então é muito raro hoje em dia, eu não sei te dizer exatamente, mas é bem raro, não é? Mas no passado era bem mais comum ter reorg de um, dois, três blocos. Hoje em dia é bem bem raro, assim, deve ter mais de um ano que não acontece real de três blocos, de três blocos é quase assim, é extremamente improvável já na prática hoje em dia e você 100% serviço de umação foi feita história de 20 minutos. Tem aqu dedão aí de seis blocos, né, que é esperar aproximadamente uma hora. Seis blocos. Um reorg de seis blocos eu acho que só aconteceu duas vezes na história do Bitcoin, alguma coisa assim, tá? Posso estar enganado nessa informação, mas e e as duas vezes foi porque aconteceu algum hard, foi algum forte na rede, alguém fez alguma besteira na rede. E alguns desses aí eu vou, um deles eu vou contar a história para vocês aqui na hora que a gente falar de governança que tem a ver com esses fortes, tá? Mas assim, é muito incomum acontecer essas reogs de muitos blocos, muito incomum, ao contrário de outras chas, tá? ao contrário de outras cências. Isso inclusive era uma coisa que eu que tem a ver com a escolha do 10 minutos, porque se eu faço esses o intervalo dos blocos ser muito muito curto entre dois blocos, eu tenho muito pouco tempo para validar e propagar um bloco novo. Vai ter muito, muito tráfego de bloco na minha rede, entendeu? Então, passa a ser mais comum eu ver essas reorganizações, porque é uma rede, tipo, cara, uma rede é IP, perde pacote, tem que retransmitir ou não chega na no outro lugar, tá? Acontece tudo isso. Não sei se entende certo, mas supostamente poderia poderia tentar minerar sobre um bloco que já foi minerado antes que se eu tiver uma de trabalho maior substituir para você pode tentar minerar a partir daqui, ó. Isso, isso sim. Mas se você, só um segundo, imagina que você imagina que a a rede tá naquele naquela azul ali, azul clara. Deixa eu fazer de vermelho agora. A, a rede tá naquela cadeia azul clara. E você também tá vendo isso aí. Você resolve minerar em cima desse bloco aqui. Você foi lá e criou um bloco. Se você propagar isso aqui agora, a rede toda vai falar: "Não, isso aqui encaixa". Isso aqui vai criar uma bloquinho com menos prova de trabalho, que é que eu tenho agora. joga fora. Então, para ela substituir efeticamente na rede, ela precisaria ter maior pro de trabalho que todo o resto da Isso, ó. O que que você pode tentar fazer, tá? Que que você pode tentar fazer? Você vai minerando sozinho, sozinho entre aspas, né? Mas assim, você vai minerando uma uma blockchain paralela aqui, ó. Uma blockchain paralela. Esses blocos tem que ser válidos, né? né? Tem que ter prova de trabalho, coisa toda. Se você conseguir minerar essa essa essa vermelha mais rápido do que o resto do que o resto da rede, na hora que você propagar todos esses blocos vermelhos, todo mundo que tá na chain azul vai olhar e falar: "Hum, tem uma uma cadeia com mais prova de trabalho". Que que eles vão fazer? Tira isso, tira isso, tira isso, tira isso, segue a vermelha. Só um segundo. Isso aqui é uma reorganização, tá? Só que repare que enquanto você tá fazendo, esticando a sua cadeia, essa aqui também tá andando. A rede tá andando, a rede tá progredindo. Então, para você conseguir fazer isso aqui numa, você precisa conseguir fazer isso aqui numa taxa maior do que a taxa do resto da rede. Então, não é exatamente 51%, mas em princípio se você tiver 51% do Rate todinho da rede, você consegue fazer isso porque você consegue minerar mais rápido do que o restante, tá? Mas isso não quer dizer que você minera instantaneamente. Você demora mais ou menos 10 minutos, 20 minutos para fazer cada um desses blocos ainda. Tá vendo? Tá. Isso aí é o entreço ataque de de 51%. Você consegue reorganizar a rede. Quanto mais demora esse ataque, quanto mais pro passado você quer reorganizar, tá? O que que você consegue fazer aqui? Você consegue roubar dinheiro de alguém assim?

cons fazer o sal. Você consegue roubar dinheiro de alguém aqui? Você consegue uma transação que era válida aqui? Pode ser inválida aqui?

Não. Como é que você faz para invalidar uma transação? Ela pode não ser incluída no bloco, sim. Mas como é que você faz para invalidar uma transação?

Você faz outra que gasta a mesma saída que a primeira tava gastando. Mas você pode eliminar essa saída. Você tá lá no início eliminar a existência da saída, mas você não elimina a transação anterior que é a filha, né? Que é o parent, é o é o parent, né? De uma, o máximo você vai conseguir tirar ela de um bloco e não confirmar mais aquela. Mas você não invalidou a outra. Vamos supor que eu gastei a o o a saída, esqueci que o nome é ex TXO. Hã? UTXO. O TXO. É isso. Exato. Eu tenho essa saída aí, certo? Essa saída foi gerada em algum momento por uma base, né? Ah, tem em algum momento atrás eliminar essa Sim, sim, isso sim. Eu quebrei isso Mas aí você precisa fazer um reorg de 100 blocos. Nunca aconteceu na história. Quanto tempo demora para você fazer uma Vamos imaginar que você tem 50% da rede do Rate hoje. Quanto tempo demora para você para você fazer uma uma um reorg de 100 blocos? Você precisa minerar 100 blocos. Quanto tempo você precisa? Você precisa para isso? 100 vezes 20 minutos, né? Porque você não tem todo o restate da rede, você tem menos, você tem metade. Então você vai demorar meio que o dobro do tempo. Então 200 minutos, sei lá, não, 2000 minutos. Enquanto isso, a rede tá andando aqui. O resto da rede tá, ela não precisa, o resto da rede não precisa produzir 100 blocos mais rápido que você. Ela só precisa produzir um bloco mais rápido que você. já chegou na tua frente, já dificultou o teu trabalho. Tá vendo? Quanto mais no passado, mais difícil você andar para você fazer isso aqui. Aconteceu alguma vez na história? Sim. Dob? Sim. Vou contar esse caso depois, em algum momento quando a gente tiver falando de governança, porque isso senor tem chance de isso tá acontecendo agora? Uma pessoa tá acumulando um monte de bloco. Tem chance de tá acontecendo agora? Tem. E alguém, tipo, uma pessoa com muito poder tem, tá acontecendo agora na rede do Monero.

E tem uma empresa que é que eu não lembro como é que é o nome da empresa, mas enfim, ela tá vocalmente falando: "Estou fazendo isso". A tônica do Moniro é é Não tô dizendo que Moniro é ruim, tá? Só tô dizendo que tá acontecendo lá agora nessa rede, tá acontecendo um real totalmente dentro da regra, mas é uma sim é um ataque aquela rede ali. Só que aí só que aí a moeda depende da compensa das pessoas para usarem. Tem uma empresa que faz isso, ela ataca e mesmo ela vai ter muito al que não vale nada. Mas eles não estão fazendo para fazer dinheiro. Sei lá, por que que eles estão fazendo. Enfim, Moniro é feito para privacidade. É, tem outro. As transações elas são bem diferentes. A gente vai falar um pouco sobre isso. Pera aí, pera aí, pera aí, pessoal. Essa questão de eu avaliar se, por exemplo, uma uma blockchain tem mais prova de trabalho que outra, né? Na prática, isso é o quê? A soma dos sets, tipo uma uma ter a soma dos sets maior que a outra. Eu dizer que uma teve mais prova de trabalho do que outro. Não é exatamente a soma, mas você consegue calcular. não queria entrar nesse detalhe de como é calcular essa quantidade. Então dois blocos e um vai ter um próprio trabalho que a outra e cálculo específico para isso. Sim, tem uma que os dois se vá. Sim, tem uma conta, tem uma regra determinística para isso, inclusive. Todo mundo bem, tá? Eu queria fechar essa história aqui de consenso dos blocos e essa coisa toda falando, vocês entenderam aqui, ó. Dificuldade pr de trabalho, o Ah, já que estamos nessa aqui, em algum lugar aqui, tá? O código fonte chama calculate next work required. Calculate next work required. Onde é que ele tá? Não, não. Get difficulty. Não, não, não, não sei. Separei. Uai, não deixei aqui. Ah, aqui

não. Não deixei separado.

Não deixei separado. A função tá aqui, ó, que calcula, que calcula isso aqui, tá? Calculate next work required.

Esse cara aqui, P é proof of work.

Essa função aqui.

Ah, não, essa aqui é o que tá, tá, esse aqui é o que tá calculando. Ah, tá. Então, tá, enfim, volta, tá? Volta. Aquilo ali é a função que calcula quanto tem que ser o target. Beleza? Para finalizar essa história de blocos e consenso, deixa eu explicar para vocês o a história da Merkel Road, tá? Repara que eu vou fazer o hash e o hash vai, esse hash é o identificador do bloco. Você quer dizer que na hora que eu calculo esse hash, se eu não estou incluindo as transações no hash, eu não tô travando as a lista de transações. Eu preciso ter uma forma de incluir os os as transações no resto do bloco para poder garantir que ninguém vai mexer nas transações mais. Porque se mexer nas transações, eu quero que mude o bloco, o o inclusive a prova de trabalho do bloco. A partir do momento que você calcula ali, ela sim, porque tá o o bloco tá entrando no como pré-imagem de um hash, certo? Eu quero que se mudar a pré-imagem, ou seja, se mudar as transações, inclusive, mude o resto do bloco. E eu quero que isso invalide o bloco, certo? Eu preciso de alguma forma de incluir as transações que estão no bloco nesse hash. Só que ao mesmo tempo aí eu tenho dois problemas. Primeiro, eu quero que isso aqui seja bem compacto para eu não precisar te mandar todas as transações toda hora para você validar a prova de trabalho, tá? Segunda coisa, imagina que você tem um nó que não quer validar tudo, uma wallet, por exemplo, mas que você quer uma prova de que uma certa transação foi incluída num bloco. A wallet pega o header e vê a prova de trabalho, mas ela não vê as transações. As transações não entram aqui, ó. Eu quero uma forma compacta de poder ter essas provas, de que tem alguma coisa no bloco sem eu precisar ver o bloco todo. Esse é o problema, tá? São esses dois problemas. Quero ver provas compactas e eu quero comitar as transações no resto do bloco, tá? Se eu só pegar a lista de transações e incluir no hash, eu resolvo o segundo problema, que é se alguém mexer em um bit de qualquer uma das transações ou mudar a ordem, qualquer coisa, vai mudar o resto, vai invalidar a prova de trabalho. Só que eu não resolvo o problema de provar que uma transação tá no bloco. Como é que eu provo que uma transação tá no bloco X lá qualquer? Se fosse simplesmente a lista de transações entrando no hash, eu precisaria ver a lista de transações, pegar todas as transações e ver todas as transações. Só que a maioria das transações não me interessa. A minha pra minha carteira, eu fiz um pagamento para você, não me interessa. Para você, não interessa todas transações, só interessa aquele pagamento. Você você não precisa ver tudo, tá? Então como é que como é que o Satos resolveu essa parada aqui? Essa estrutura de dados que eu vou mostrar para vocês não foi inventada para isso, mas ele aproveitou. E a gente usa isso em outros, um monte de outros de outras coisas, tá? Então, extremamente útil. Que que a gente faz? A gente faz o seguinte, eu vou construir uma árvore e vou fazer uma coisa parecida com uma busca binária. Busca binária é bem eficiente, né? Tipo, para eu mostrar, para eu encontrar alguma coisa numa lista, né? Tá? E é baseado meio que numa ideia de ter uma árvore, uma árvore binária. É, mas então eu não poderia ter uma lista de organizada. Como é que é? Não, ali, eu não vou construir uma lista organizada, não, não vou fazer busca binária. Tô falando que é baseada nessa ideia de ter uma do algoritmo da busca binária. Acompanha comigo aqui. Que que eu vou fazer? Eu vou pegar as transações. Então, vou colocar elas na ordem aí. Dois, vamos supor que tem um bloco lá com seis transações.

Essas c essas seis transações aí. Aí eu vou calcular o r de cada um delas. aqui de R 0, R1, R 2, hash 3, 4, resto da transação 5. Agora eu vou começar a combinar elas num formato de árvore binário. Vou pegar essa com essa e vou calcular o R 01. O r 01 é o r do hash zero concatenado com o hash 1. Bota um do ladinho do outro os bytes, bota tudo no hash e é isso aí. Esse esse resultado eu tô chamando de hash 01. Tudo bem? Eu vou fazer a mesma coisa com esse aqui para calcular o 2 3. Eu vou fazer a mesma coisa com esse aqui para calcular o r 45. Vocês concordam comigo que se eu mexer nessa nesse nessa transação muda esse hash? Estão vendo, né? Tá aí eu vou continuar, vou pegar esse par aqui e vou juntar e vou fazer o r 0 1 2 3. Mesma coisa. Pega um r, concatena com outro r, faz o resto desse disso. E essa daqui, ó, só tem uma com com catena com quem? 2 tr. Com 2 tr. A sua a sua proposta é fazer assim, aí não é mais árvore binária, né? Porque esse cara aqui, ó, tem agora mais filhos ou mais pais do que deveria. Eu não quero fazer isso, quero fazer binário. Tem que combinar esse cara aqui com alguém. Qual que foi a solução do Satoshi que gera problemas, tá? Mas foi o que ele fez. Ele falou: "Quando não tiver um par, duplica e faz o par com ela mesma".

Isso funciona, mas tem um bug nisso que, enfim. Então isso aqui vai gerar o rest H45 45. E aí eu pego esse último par aqui, bum, e faço o R, que é o 0 1 2 3 4 5 4 5, que é um hash só, né? Isso aqui eu vou chamar de Merkel Root. Merkel é o nome do cara que inventou isso aqui, é o halfle. o sobrenome dele, tá? Repare uma coisa, se eu mudar um bit em qualquer uma dessas transações, você concorda comigo que vai mudar a Merc Root? Porque todas elas entram no R. Se eu mudar alguma coisa na TX3, vai mudar aqui, que vai mudar aqui, que vai mudar aqui, que obrigatoriamente vai mudar aqui. Então essa Merc root, ela tá travada com relação aos bits de cada uma daquelas transações. E ela também tá travada com relação à ordem. Se eu trocar isso aqui de ordem, esse rest vai mudar e aí vai mudar todos os restos na sequência. Então ela também trava a ordem. Se eu tentar mudar a ordem também vai mexer na Mercal Root. E a Merc Root entra no cálculo da prova de trabalho. Se eu mexer aqui, vai mudar o hash desse header. Provavelmente esse header não vai mais bater aqui. Lembrando que a probabilidade de eu ter um dado aqui, que é onde tá o meu bloco válido, eu mexi um bit, a ideia é que eu vou andar para um lugar qualquer agora. A probabilidade de eu cair aqui é monstruosamente maior do que eu cair num outro resto aqui, ó. Pum, pode acontecer, pode. Essa probabilidade é extremamente baixa e é mais baixa quanto mais prova de trabalho tá acumulando ali na coisa, tá? Então, provavelmente eu vou invalidar o a prova de trabalho se eu mexer em qualquer uma desses desses desses caras, tá? Então, desse jeito aqui, eu incluo na na prova de trabalho a ordem das transações e as transações. Então, se eu mexer nas transações, vai bagunçar a prova de trabalho. Vou perceber isso, vou conseguir ver isso na hora que eu tiver validando. Só que isso aqui tem uma vantagem monstruosa, porque olha só, se eu imagina que eu vi, eu vi isso aqui e eu confio nisso aqui, porque isso aqui tá junto à prova de trabalho, então vou confiar nesse número que eu vi aqui. E eu quero saber se a transação dois foi incluída no bloco, mas eu não tô vendo todas as transações, eu só vejo os cabeçários. Eu sou uma wallet aqui, eu só vejo os cabeçários. Eu quero saber se eu quero descobrir se a transação dois tá nesse bloco ou se não tá nesse bloco. Que que eu posso fazer? Eu posso pedir para algum nó calcular uma prova de inclusão para mim. Que que é essa prova de inclusão? Esse nó vai me mandar, eu vou chamar de P. Ele vai me mandar a seguinte coisa. Ele vai me mandar o resto do H3, porque o resto do H2 eu consigo calcular. Eu mesmo, eu sei qual é a transição T X2 que eu tô interessado. Ele me manda o H3. Eu calculo o H23.

Eu sei o H2, eu recebi o H3. Eu que tô validando, calculo o H23. Aí o nó depois na sequência me manda esse resto aqui, ó, o H01. E aí eu sozinho calculo esse resto. Eu sozinho. E aí depois o nome manda esse resto aqui, ó. H45 45. E eu calculo esse aqui e eu vou ver que bateu ou não na minha Mercur que eu confio que tá lá na por trás da prova de trabalho, tá? Essa sequência de restos aqui eu vou chamar de prova de inclusão. Isso prova que aquele que aquela transação que aquele pedaço do do da estrutura existe. Eu só não entendi o que você quis dizer com o nome manda. O nome manda porque imagina que eu sou um uma wallet, eu só vejo os cabeçalhos. Eu que produzi a transação T2 TX2. Ou, por exemplo, eu fiz um pagamento para você, a sua wallet sabe que a que é aquela que é aquele pagamento que você tá esperando. Você viu a a transação, tá tentando esperar se ela vai entrar no bloco, tá? os nós, e repare, a minha wallet só vê o o header, os nós da rede, os nós completos da rede vem tudo. Eles vêm tanto os headers quanto as transações. Então os nós completos, eles conseguem calcular esses caminhos aqui para mim, mas eu sozinho não consigo calcular isso aqui, ó. Entendeu? E aí eu vou pedindo para ele, eu quero, que eu quero descobrir é o TX2 está incluído nesse bloco. Aí eu vou num no em alguém que viu todas as transações e pergunto para ele: "Ou me calcula para mim aqui esse caminho, me dá uma prova de inclusão dessa transação aqui, ó". Bum. Em princípio, eu nem sei que ela é a TX2. Eu eu nem sei onde que ela tá no bloco. Eu nem sei que se tá no bloco ou não. Eu vou lá no nó do, como é que tá o nome? Gustavo, eu vou lá no nó do Gustavo, o meu nó vai lá no Gustavo e pergunta assim: "Ô, essa transação aqui tá incluída no bloco?" Aí o do Gustavo vai responder: "Tá, pode ser que responda: "Não está." E aí não tem prova para fazer. Mas se ele falar que tá, eu não quero só acreditar nele, eu vou falar para ele assim: "Então, prova que tá mesmo." Aí o que que o nó dele vai fazer? Ele vai calcular essa prova, que são esses restos, e vai me entregando esses restos. E eu vou calculando e falando: "Ah, olha só, realmente bateu". Como que ele sabe calcular isso aqui? Ele sabe calcular isso aqui por quê? Porque ele viu todas as transações, entendeu? Então quando eu recebo essa prova, ganha compartilhando isso? Você tá pedindo que que ele ganha compartilhando isso comigo? Ele ganha a minha amizade. Mas essas provas são baratas de calcular, entendeu? Essas provas são baratas de calcular. Pensa que não precisa ser o meu node perguntando para o node de 1 terceiro. Pode ser a minha wallet que tá rodando no meu celular perguntando pro meu node que tá rodando num servidor, mas é o meu, eu controlo o servidor, entendeu? E aí você, alguém me perguntou qual a importância de rodar o node, eu vou terminar com isso a aula. Alguém me perguntou aqui agora no começo da aula aqui, qual a importância de rodar o node? A importância de ronar o node é essa aqui, ó. É essa daqui, principalmente essa daqui. Para você que tá interessado, ah, tem um wallet aqui no no meu telefone. No seu telefone não vai ver todas as transações. Ela não vai ver a blockchain inteira, não vai validar a parada. Ela só vai lidar ali com uma algumas transações que interessam pra tua wallet, ou que você fez de pagamento ou que você tá recebendo, entendeu? Se você não roda o seu nó, você precisa confiar no nó de alguém para produzir essas provas corretamente para você. E aqui tem um um uma pegadinha que é se alguém me dar uma prova de inclusão, é garantido que aquilo tá lá no bloco. Mas alguém pode querer me enganar que a minha transção não está no bloco. Gustavo, posso ir lá no n do Gustavo perguntar assim: "Ô, a transção TX2 tá tá no bloco tal". E ele falar: "Não, e ela está de fato, mas ele fala para mim que não tá". E aí não tem como ele provar que não está. A única forma de eu saber que não está é ver todas as transações do bloco e validar eu mesmo, entendeu? Então assim, esse esquema aqui, ele me permite, quando alguém falar para mim que está, provar que tá, mas não tem como eu provar que não tá. E aí eu posso ser enganado por causa disso. Não sei que tipo de ataque, mas então repare, eu tô confiando no node de 1 terceiro. Quanto mais a gente tá tentando bolar esse esse esquema todo para não precisar confiar no terceiro. Eu não sei se talvez seja um parêntese desnecessário, mas para provar. Eu não poderia falar, por exemplo, eu tenho nesse blog, você sabe que tá no header que tem, sei lá, cinco transações. Não, eu não sei que tem cinco transações. O header não tem o número de transações. Ó lá o header lá. No header não tem o número de transações. Eu não sei nem quantas transações tem naquele bloco. É porque se tivesse poderia falar: "Tá, tem, sei lá, cinco transações, eu vou te mandar log dois de cinco testes, você faz aí." Sim, poderia se soubesse e mas eu precis saber a ordem delas e tal, precisa saber mais coisas, precisa ter visto o bloco inteiro, tá? Só que isso aqui tem um problema de privacidade ainda que eu não vou resolver aqui agora, vou terminar a aula agora, mas tem um problema de privacidade que é, imagina que eu fui lá no nó do Gustavo, que é um nó de terceiro que não que eu não controlo, e eu pergunto para ele: "Ou a transção TX2 tá no bloco? Me prova que tá no bloco, mesmo que ele não esteja me enganando. Tu concorda comigo que se eu perguntei da transção TX2 é porque eu tenho algum interesse nessa transação. Provavelmente é um pagamento que eu, o mais provável é um pagamento que eu tô recebendo. Se eu quero ver que você tá no bloco, é porque eu quero confirmar que eu recebi o dinheiro. É, é a coisa mais provável de acontecer aqui. O, o Gustavo, ele ele não tem certeza, mas ele olha e fala: "Hum, isso aqui, essa transação TX2 deve ser o Edil recebendo dinheiro. O as transações, o formato mais comum é ela ter uma entrada e duas saídas. Aí o Gustavo começa olhar e fala assim: "Hum, essa transação deve ser o Edil recebendo dinheiro". Deve ser, ele não sabe com certeza, mas é plausível que seja. Hum. Então quer dizer que isso aqui e ou isso aqui deve ser dinheiro dele. Vou passar a monitorar isso aí.

Isso aqui é um problema de privacidade, a gente vai precisar lidar com ele. Não tem uma boa solução, uma solução assim, uma bala de prata, tá? Ainda, mas isso é um problema que tá em aberto. Mas isso só se não se tiver nó. Se você tiver o seu próprio nó, se eu tiver meu próprio nó, tô mais de boa, né? Porque aí o meu próprio nó faço, valido tudo, não precisa perguntar nada para ninguém. M.