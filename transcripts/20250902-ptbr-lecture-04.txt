Então vamos lá então. Vamos lá então. Hoje eu quero falar, a gente já começou a falar de hash eu quero falar mais sobre hashs e vamos falar de assinaturas digitais, tá? Eh, então vamos lá. Que que a gente definiu até agora, tá? Eu disse que um hash é o resultado de uma função que eu vou chamar direto aqui, eu vou chamar essa função de h de hash, tá? Ela recebe uma entrada que eu vou chamar de pré-imagem.

Pré-imagem é a entrada da opção de R. Em princípio, pode ter qualquer tamanho, tamanho arbitrário. E a saída da função de hash a gente vai chamar de hash ou de digest, né? mais comum é chamar de hash. E essa saída tem tamanho fixo. Aqui para todos os os exemplos para vocês, eu vou usar o um digjest de 256 bits. E a maioria dos casos, a função que a gente vai usar é CH2 256, que é uma função de has, uma função de hash criptográfica, tá? Qual a diferença de uma função de hash para uma função de hash criptográfica? A função de hash, ela precisa receber uma entrada de tamanho variável e custar uma saída de tamanho fixo. Ponto. Para ser considerado criptográfico, eu quero algumas propriedades adicionais, tá? Propriedades adicionais. Primeira delas, eu quero que a saída pareça sempre meio aleatória, sempre aleatória. Não consigo distinguir muito ali o que que tá acontecendo, tá? É meio difícil de definir formalmente o que que é isso, tá? Mas eu quero três outras propriedades que são um pouco mais eh um pouco mais formais, tá? A gente não vai ver como que implementa essas coisas numa função específica, tá? A gente vai simplesmente assumir com uma caixa preta. Eh, assumir uma caixa preta e usar essas, mas a gente vai usar essas propriedades o tempo todo, tá? A primeira delas é resistência a pré-imagem. Préimage resistance.

Tá aparecendo minha tela? Ah, tá. Ã, resistência a pré-imagem, lembra? Ó, lembra como é que é isso aqui. Eu te dou um y. Eu te dou um hash ou saída de um hash, tá? Eu te dou um y. Vou chamar até inclusive de h0. Aqui eu te dou um uma saída de um hash e você não consegue encontrar, eu vou marcar assim, ó. você não consegue encontrar um X tal que h de X seja esse Hz. Que que isso aqui tá falando para você? Que se você vê a saída da função de R, você não consegue saber qual é a entrada, não consegue calcular a entrada, tá? Óbvio que você pode ficar testando vários X ali, ó. Tipo, ó, fazer um brute fort, né? Bota lá 0 1 2 3. Pensa como 0 1 2 3. Fica testando até uma hora que você encontra algum que vai dar o H z0. Você vai encontrar? vai encontrar, você vai encontrar eventualmente, tá? A questão é que a questão é o espaço de busca é tão grande que isso é impraticável de fazer, tá? Para 256 bits aqui, é, você precisa testar na média 2 a 256 combinações, tipo assim, x diferente até você ter uma probabilidade relativamente alta de encontrar um um r desse, tá? Óbvio que você pode dar sorte, tá? Você pode testar uma, duas, três vezes se achou alguma coisa do jeito que você queria, mas a probabilidade de acontecer extremamente baixa. Segunda propriedade que a gente quer, tá, é a resistência à segunda pré-imagem, resistência à segunda pré-imagem, tá? Nesse caso aqui, nesse caso aqui eu te dou um x0 e um h0. De tal forma que ã h de x0 é o h0. Repara que agora eu te dei o par. Eu falei, ó, tem aqui um rest e aqui é a entrada dele. Aqui é a pré-imagem dele. Te dê mais informação, tá? Você não vai ser capaz de encontrar um x linha diferente de X de forma que h de x linha seja igual a h0. Eu te dou uma pré-imagem, ele tem um rest. O que a gente tá dizendo aqui é você não vai ser capaz de encontrar um outro, uma outra pré-imagem que gera o mesmo resto. E eu vou chamar isso aqui de resistência à segunda pré-imagem. Você não consegue achar uma segunda pré-imagem. Repare, você tem uma já que gera um resto. Você não vai achar uma segunda, tá? Repare que vai ficar. A próxima aqui é parecida com isso aqui, tá? Repare que eu tô travando esse X0. Você não pode escolher esse X0 em princípio, né? Tipo, já tem esse par, tá? A terceira propriedade aqui é resistência colisão,

resistência colisal, que é falar o seguinte: você pode escolher x0 e x1.

Você pode escolher do jeito que você quiser, x0, x1. Você tem liberdade de escolher dois dois duas entradas quaisquer, tá? você não vai conseguir encontrar x0 e x1 tais que h de x0 seja igual h de x1. Repare que aqui você tem liberdade para ficar testando x1 e x0 do jeito que quiser. Você não tá preso em numa delas. Você pode mexer nas duas, tá? De novo, esse aqui você também pode fazer um ataque de brute force. Todos eles pode fazer brute force, tá? Ficar testando coisa. Nesse aqui, nesse caso aqui, você precisa testar 2 elevado 128

entradas, entradas até conseguir encontrar uma colisão dessa com uma probabilidade razoável. Essa probabilidade razoável é 50%, tipo que se padroniza, tá? E por que 2 128? Porque você pode ir acumulando o resultado. Você escolhe um x0, escolhe um x1. Não deu. Guarda os restos desses dois, escolhe um x2. Aí esse X2 pode estar colidindo tanto com o X0 quanto com o X1. Não deu. Aguarda aquela informação. Calcula um X3, escolhe um outro x3, calcula o resto. Agora você vai testar a colisão com x0, X1, X2 e aí vai acumulando. Então quanto mais você faz, mais coisa você já tem para buscar, mais informação você vai adquirindo. Por isso que vai te dando esse ganho de coisas que você tem que testar, tá? Ainda assim, a melhor coisa que você pode fazer é testar 2 elevado a 128 combinadas que você precisa ir lá e ficar testando e calculando esses tá? Isso aqui a gente chama de 128 bits de segurança

e a gente considera um rche ou alguma coisa que alguma ou alguma outra coisa tá quebrada quando tem quando a gente consegue encontrar alguma técnica que me permite, por exemplo, calcular uma colisão com menos de 2 a 128 tentativas, tá? É basicamente essa essa ideia. E aí isso aqui também é útil pra gente poder comparar outros sistemas. A gente não vai ficar comparando tantos outros sistemas aqui, tá? Mas tem sistemas, principalmente de assinatura digital, com chaves bem grandes, tipo, sei lá, 4.000 e cacetada bits, 6.000 e não sei quantos bits, tá? Que eles têm mais resistência a uma certa resistência, uma certa segurança nessa ordem de grandeza 128, 256 bits. Por quê? Porque a gente sabe algum algoritmo que acelera essa coisa e eu não preciso de 2 elevado a 4000 e e muita coisa. Tudo bem? Mas isso aí eu vou deixar isso para um curso de criptografia de fato. Trata de tudo isso. Todo mundo OK? Beleza. Restos são extremamente úteis. Vocês vão ver que a gente vai usar resto para tudo. Absolutamente tudo. Vai aparecer resto em tudo quantter lugar, tá? Absolutamente tudo quant é lugar. Tem três usos principais de restos, tá? O primeiro deles é usar o um hash como nome de alguma coisa. O nome de alguma coisa. Aí deixa eu aproveitar e abrir um Ah, eu não tenho internet, eu acho. Opa, deixa eu vir para cá. Nova. Eu acho que eu não tenho internet. Mol p space. Eu tenho internet.

É, eu deveria ter internet.

Deixa eu ver se assim vai.

Ah, não vou. Ah, vou. Beleza. Que que é esse mainpool.space? É um explorador de blocos da blockchain do Bitcoin, tá? Então, tu pode clicar. É bem bonitinho, é feito para ser bonitinho, tá? Então, tem os blocos que já foram confirmados, são esses azulzinhos aqui, tá? Vou clicar aqui no último bloco confirmado. Vou clicar aqui no último bloco confirmado aqui. Tá me dizendo, ó, tem 1656 transações. A gente vai ver o que que são essas transações pouco a seguir. Mas repare, ó. Cada transação tá marcada aqui de alguma forma, desenhado, renderizado, bonitinho. E isso aqui é um identificador dessa dessa transação específica. Tá? Isso aqui é o rche dos dados que tem nessa transação. Calculado de uma certa forma particular. Mas o que que é a pré-imagem desse R aqui? Os bytes dessa transação. Não são todos os bytes exatamente, mas os bytes dessa transação em princípio, tá? E aí eu uso isso aqui como identificador do dessa transação específica nesse sistema. Tipo, isso aqui passa a ser o nome praticamente dessa dessa transação, tá? Por que que a gente pode fazer isso? Vai ter colisão de qualquer jeito. Por que que a gente pode fazer isso?

Porque estatisticamente é tão improvável que que aconteça uma colisão que, tipo, para realmente a gente conseguir duas transações com o mesmo hash e elas vão ter o mesmo nome, eu preciso botar os mesmos dados na nas transações. A gente vai ver aqui que elas têm é muito difícil gerar duas transações com com exatamente os mesmos bytes, tá? Nunca aconteceu na na no caso do blockchain de Bitcoin já aconteceu. Tem duas transações com o mesmo TXID, que é esse nome dela aqui que é um hash que é um hash tá? Tem duas transações que tem o mesmo nome lá. A gente vê esse caso depois porque isso passa a ser um caso especial, isso é um problema, tem que ser tem que ser tratado, tá? Hum, não sei se foi bem um azar, é um bug eventualmente, tá? Mas enfim. E mas isso faz, ó, tipo, isso foi no início da rede, faz muito, muito tempo. Então, assim, assim, as pessoas estavam descobrindo aí nos problemas, estavam experimentando. A gente ainda tá descobrindo, tá? A gente ainda tá descobrindo. Repare que vocês estão vendo que o bloco aqui ele tá marcado com esse número, né? 9000 e 912.879. A gente vai chamar isso aqui de altura dele. Ele é o ele é o ele é o começou no bloco zero, teve o bloco um, bloco dois. Esse aqui é o que foi o último, é o 912.800. 1879, tá? Repara que tem um hash dele aqui também, ó. Aqui tá, não tá todos os os os bikes do do M desse RH, mas ele também tem um hash dele aqui, tá? E repara que tem uma coisa particular acontecendo, ó. Começa com um monte de zero. E isso a gente vai ver um pouco mais detalhe, porque isso, tá? Ainda assim, esse resto aqui também ele é usado como o nome desse bloco. Toda hora que eu quero falar do bloco 912.879 lá no no na implementação, a gente não é bem raro a gente for olhar e falar assim: "Ah, me dá o bloco 912.879", tá? Na verdade, a gente pede: "Ah, me dá o bloco com esse resto aqui, bum!" Que é o essa essa informação que tá aqui. A gente vai ver inclusive um pouco mais de detalh sobre isso, tá? Por que isso? Porque pode, lembra que a gente comentou isso na aula passada, eu posso minerar dois blocos em cima de um bloco anterior, de um mesmo bloco anterior, tá? Então eu posso ser dois blocos diferentes da mesma altura num certo momento. Então só identificar um bloco pelo qual é a posição dele na fila não é suficiente, não é? Pode ter uma alguma ambiguidade nisso, tá? Mas no resto provavelmente não vai ter. Todo mundo bem? Eu fiquei com o a diferença do rest e do outro. Esse aqui você falou que tem dois iguais. Não, do o do Ah, não, é aquele lá era da transação. Isso, porque cada transação a gente vai calcular um r dela também e vai usar esse r como identificador dela. Aí eu preciso achar elas aqui, tipo assim, ela muito do passado, não sei de cabeça que o resto, não lembro nem quais blocos foram foram minerados, tá? Mas elas tm a mesma tem duas transações aí com o mesmo com o mesmo R. Tudo bem? Esse é um primeiro uso de de

hashes como nomes, tá? Não é exclusivo de blockchain. Eu uso uns, tipo, vocês estão vendo aqui, eu tô no Mac, tá? Aquela coisa toda, Apple coisa, tá? Mas eu uso um gerenciador de pacote, chama NYX, tipo, tá meio que na modinha, tem várias vantagens se eu usar isso. E esse o NX

LS, ele gera para mim uma pasta chamada NX Store, que é onde ele vai guardar todos os packs que estão no meu sistema, tá? Eu vou pedir para ele listar Core Utils. É um pacote que tem várias ferramentas úteis básicas aqui, que é o LS, sei lá, LN, as ferramentas de make assim básicas do do sistema, tá? Repar que eu tenho várias versões diferentes aqui disponíveis, ó. 9.7, 9.5, 9.6, tá? tem uma tonelada de versões. E repare o que que esse NX faz para identificar unicamente cada uma, ele adiciona no nome da coisa, no nome da coisa, o hash um hash daquela coisa. E aí eu consigo ter várias várias versões diferentes do mesmo software. Às vezes o número de versão é igual, mas ele tem alguma variação porque foi compilado de alguma forma diferente, tá? E aí isso gerou um binário diferente e eu posso usar o hash hash para identificar unicamente cada uma dessas versões aqui, tá? Extremamente útil esse conceito. Segunda coisa que a gente pode usar para o qual a gente pode usar hash referências

ou ponteiros ou ponteiros, tá? que a gente vai usar nesse caso aqui para montar a blockchain, né? Volta aqui no no volta aqui no no nesse cara aqui. Bloco não sei o quê. Cadê o cabeçalho dele? Ah, aqui não vai aparecer tão bonitinho, tão bonitinho assim. Eu acho que eu não consigo ver os Aqu, né, Luca, os detalhes aqui não. Qual o bloco anterior não vai est tão tão tão bonitinho assim, tá? Mas no cada um desses blocos aqui vai ter um cabeçalho. A gente vai ver essa coisa um pouquinho mais de detalhe, um pouco mais pra frente, mas cada um desses blocos vai ter um cabeçalho, tá? E um dos campos desse cabeçalho é um é o rash do bloco anterior. Para eu poder saber, ó, esse bloco aqui, 912879,

ele considera como bloco anterior esse outro bloco aqui que tem esse determinado R. Então, repare que eu tô, quando eu tô fazendo isso, eu tô fazendo uma lista ligada. Eu tenho um item e o item aponta para um para um pro anterior, no caso aqui, né? Uma lista que mandando para trás, o anterior. E o anterior tem um é um item, tem lá suas informações e ele tem um ponteiro que aponta pro anterior e é pro anterior e pro anterior, tá? E a gente tá usando hash como esses ponteiros. Nesse caso aqui são um exemplo desse osso, tá? E aqui o que é o que eu vou mais discutir com vocês hoje é a ideia de hashes como commitments. Comit é, eu não, eu não gosto muito da tradução, mas commitment é compromisso. É você se comprometer com alguma coisa, tá? É você se comprometer com alguma coisa, tá? Por que que dá para usar restos cometas? Deixa eu explicar isso aqui, porque isso aqui é um conceito que vai aparecer o tempo todo. A gente vai fazer dezenas de construções criptográficas baseadas nessa ideia de hash como cometas, tá? Tem duas propriedades que eu um hash criptográfico me dá, que são a primeira delas é hiding, tá? Hiding. Hiding vem do fato,

vem do fato de que eu sou resistente a pré-imagem. Ou seja, se eu te mostro a saída do rest, você não consegue calcular a entrada a partir daquilo ali. Somente eu tô escondendo a informação de entrada. Então, repare, eu posso mostrar para você uma informação e você, tipo, o resto da informação e você não consegue saber que informação é aquela. Eu escondo ela de você, tá? Mas ao mesmo tempo, quando eu tô fazendo isso, eu tô binding.

Binding vem do fato de que eu sou resistente à colisão. Binding quer dizer o seguinte: uma vez que eu te mostrei um hash, imagina aqui que eu vou, sei lá, imagina que hoje à noite tem jogo do Flamengo e do Fluminense. E aí eu quero fazer uma aposta com o Luc falar assim: "Eu sei qual o resultado do jogo". Aí eu escrevo aqui o resultado do jogo, faço o RH, entrego o R pro Luca. O Luca não consegue saber o que que eu escrevi ali, tá? O Lucão não consegue saber o que eu escrevi ali. Só que eu também não consigo mais mudar o que é que eu escrevi, porque se eu mudar o que eu escrevi, vai mudar o hash. E aí na hora que eu mudo, passou o jogo, eu vou revelar qual foi aquela coisa que eu escrevi antes do jogo, antes de alguma de um certo evento. Se eu tentar mudar aquela informação que eu produzi anteriormente, tá? Eu vou dar aquilo pro Luca e o Lucas vai trivialmente ver porque ele vai pegar aquilo, calcular o resto, vai ver que não bate com aquele que ele recebeu antes. Então repare, binding é essa probidade que uma vez que eu mostrei para você o resto, eu não posso mais mudar de ideia. A pré-imagem tá fixa, tá? Então isso aqui protege as duas partes. Eu eu quero fazer algum protocolo interativo aqui com o Luca, por exemplo. Eu quero mostrar pro Luk que eu que eu sei alguma informação sem mostrar a informação. Então mostro o resto para ele. Só que na hora que eu mostro o R para ele, eu me comprometi com aquela informação, porque o Luca não, ele não precisa, ele não vai mais aceitar uma informação que não produz aquele hash. Exatamente. ou se eu produzir uma informação qualquer aqui que não bate com aquele resto, o Lucas sabe que eu estava mentindo anteriormente e ele pode agir de acordo com isso. Eu só executo a aposta se ou executar a aposta ou eu só faço um certo pagamento, né? Ou então tipo a contrapartida do pagamento, eu executo um serviço, tipo se aquele resto bateu ou não bateu. É um uma certa forma de a gente contratar alguma coisa, porque repare que o contrato em parte é isso, né? Você se comprometer com alguma coisa. e você cumprir aquela coisa, tá? Aí esse essa ideia de hiding, eu consigo comçar essa ideia de construir contratos de que eu não posso mudar de ideia depois. Uma vez que a gente acordou, o R vai ser o o o assim o o sei lá a a a trava, uma das travas disso aqui, uma das travas desse da informação que a gente contratou. Só uma dúvida, dentro do que você tá falando, é o conteúdo da sua aposta, então o resultado, né, do jogo, por exemplo, um 2 a 0, seria uma entrada. Isso, esse é o nome, é, eu escrevo lá do Flamengo 2, Fluminense zero. Vai ser a entrada. É a entrada. Vai ser a préimagem. É a informação que eu quero esconder. Perfeito. Todo mundo bem, [Música] professor? Sim. Que que tá escrito ali em cima? Que que tá escrito ali em cima? Onde? de referências assim, referências ou ponteiros. Não, assim, nome name vai acontecer de eu misturar português com inglês escrito aqui. Eu já nem tento mais, eu já nem tento mais melhorar isso. Sobre esse exemplo que senu, a função de resto já é pública, ou seja, é conhecida dos dois. A função de resto tem que ser acordada primeiro. Se o Luca não souber qual a o resto que eu usei, não não tem como. A gente precisa concordar no resto primeiro. Qual é a função? Eh, o resto ele tem uma aplicação legal, é aceito pela justiça no Brasil. Se é aceito pela justiça no Brasil, cara, não sei te dizer especificamente sobre isso. Eu acho que has sozinhos não assim, mas ele formulado dentro de um cont, mas eu acredito que tenha contextos onde você pode usar assinaturas digitais como como uma assinatura com mais valor até do que assinatura física. Tem alguns carros, por exemplo, quando você faz um transferência de carro hoje, você não vai mais no, você não vai mais no cartório, você faz tudo no aplicativo lá e você tem que ter um um esquema de assinatura digital. Você tem que ter um cadastro lá no coisa do governo que produz uma assinatura digital para você, entendeu? Aquela assinatura digital tem hashs lá, a gente vai ver sobre assinaturas digitais hoje. É um é um é um é um protocolo, tem que construir um protocolo, tá? Mas não é só ir lá e fazer um hash alguma coisa, não é só ir lá e assinar alguma coisa, precisa construir. Tem o diabo mora nos detalhes nessa nessa coisa toda. Mas repare que a gente já usa, por exemplo, para transferir de carro o um uma construção criptográfica com legal binding, que a gente chama, né? Tipo, com valor legal, vai ser aceito depois num tribunal, no caso de uma disputa. Só isso do comentário, mas o governo tem uma vista dá para ver uma ideia de autoridade centrais. É, tem ainda tem essa coisa aí de tipo autoridades, certificadores, não sei o quê, porque a gente vai ver aqui que um dos problemas envolvidos na assinatura digital é a gente eh divulgar chaves públicas das pessoas. Isso você vai ver que isso é um problema. Tipo, divulgar essas chaves é mais difícil do que parece, tá? Mas enfim, segue o baile aqui. Segue o baile aqui, tá? Segue o baile aqui. Deixa eu pular algumas coisinhas aqui. Ã, ah, não, não, não, não, não quero pular não, porque eu eu nunca posso pular o que eu pensei, porque eu pensei em alguma coisa com um fator pedagógico que eu tenho que seguir, mesmo depois que eu fiquei com 30.000 cartinhas para seguir. Mas vamos lá. Pensa num jogo aqui. Pensa num jogo aqui. Eu vou jogar. Vou fazer um jogo de aposta com o Luca. Vou fazer um jogo de aposta com o Luca. Tá, o Luca tem um site, a gente aposta em dados, tá? Usualmente a gente chama os personagens de Hélice e Bob. Hélice é o personagem A e o Bob é o personagem B, tá? Então vão se acostumando com esses nomes aí, porque aí eu vou usar a letrinha A pras coisas da hélice quando eu tenho que escrever coisas de matemática e B pras letrinhas, pras pras informações que o Bob sabe, tá? Isso vai acontecer o tempo todo. Então, imagina que eu sou a hélice e eu quero jogar com o Bob. Bob é o Luca e o Luca mantém um site. E a aposta é a seguinte, tá? A gente vai rolar um dado. A gente vai rolar um dado. No caso, o Luca vai rolar um dado. Eu, hélice, antes da rolagem de dado, eu escolho o número onde eu vou apostar, tá? Então, sei lá, vou apostar no número três. O Luca vai rolar um dado. Se eu acertar, se caiu três, eu recebo R$ 60. Se não cair o três, o Luca recebe R$ 12. Se eu acertar o número, eu tenho que o Luca tem que pagar 60. Se eu não acertar o número, eu tenho que pagar R$ 12 pro Luca. Parece fazer sentido, certo? Ou alguma variação disso. Eu pago R$ 12 para entrar no jogo e o Luca tem que me pagar R$ 60 ou no caso R$ 72. Se eu acertar o coiso, que é devolver mais o 60, né? Tá. Qual que é o problema aqui? Qual que é o problema aqui? Eu não confio no Luca. Eu não tô vendo ele rolar o dado. Eu não tô vendo ele rolar o dado. Então nada impede do de eu falar para ele, "Luca, o número que eu tô escolhendo é três." Ele ir lá dizer que rolou um dado, escolher quatro, falar: "Ah, olha, foi quase". Tá? Nada impede isso acontecer. Como é que a gente pode fazer então protocolo bem simples aqui, bem simples, bem simples mesmo. Para mitigar esse problema? Eu posso vir aqui escolher o número n que vai ser minha aposta e eu calculo. Eu vou chamar aqui h de a vai ser o r desse n. Então ele segredo escolho o número que vai ser minha aposta, calculo o resto e mando o resto pro Luca. Fala: "Ó, esse aqui minha aposta". Qual é o problema agora? O Luca não sabe o que que o no que é que eu tô apostando em princípio, né? Em princípio o Luca não sabe no que é que eu tô apostando, tá? E aí ele vai lá e rola o dado. Tem que rolar o dado, tá? Qual é o problema nisso aqui?

Bora, Lucas, já que eu tô falando de você, qual é o problema desse protocolo aqui? O espaço de busca é muito pequeno. Espaço de busca é muito pequeno. Que que você quer dizer com isso? Eu posso só o cada dado tem de um a seis, né? Então eu posso só pegar, fazer o resto de cada um deles e te mandar qualquer. Só tem seis possibilidades para eu escolher. 4 5 6. Só tem seis coisas que eu posso botar naquele N. Só tem seis pré-imagens possíveis. Que que o Luca pode fazer? Ele pode pré-calcular os restos de todas essas pré-imagens. Sei lá. Eu pré-calculei algumas aqui, tá? Sei lá, 6B, 86. Opa, 86, alguma coisa. blá blá blá D4 73 alguma coisa e assim por diante. Ele pode pré-calcular, gente, já combinou a função de H antes e aí eu vou lá, escolho, sei lá, o número o número dois, calculo o resto, vai dar D473, blá blá blá blá blá. E aí eu falo pro Luca, ó, tá aqui a minha aposta. O Luca agora tem um dicionário que é o nome dessa tabela aqui. Lucou um dicionário de de restos pré-calculados. Ele consegue ir lá no no dicionário dele e falar assim: "Que resto é esse aqui? É algum desses?" "Ah, é esse aqui, ó. Ah, a escolha dele é dois". Aí eu vou lá e tu escolho, sei lá, o resultado deu quatro. Aí falou ser quatro. É. Ah, rolei o dado aqui, deu quatro, tu perdeu. Tudo bem? Repare que se o meu espaço de pré-imagens possíveis for muito pequeno, o resto não vai me proteger, porque eu não vou fazer brut repare, o bruting aqui vai funcionar por quê? Porque tem muita pouca coisa que eu tenho que testar. Aquele 2 elevado 256 que eu tava colocando aqui, 2 elevado 128 para colisão, tá pressupondo que o espaço de pré das pré-imagens, tipo, potencialmente é infinito, tipo, não tem limite, tá? Agora, quando tem limite é muito fácil, é muito fácil tu dar essa fazer essa coisa, tu fazer um dicionário e e e olhar o dicionário, tá? Isso aqui parece meio teórico, mas isso aqui acontece todo dia, o tempo todo, quando você bota tua senha no site da internet. Porque quando tu bota tua senha no site na internet, tu tu tá mandando tua senha para algum lugar. Essa tua senha tá armazenada em algum lugar. Pior ideia de um site é armazenar a tua senha num banco de dados, tipo em claro assim. Tá lá escrito tua senha em algum lugar. Normalmente não se faz isso. Normalmente o que que você faz? Na hora que você se cadastrou, você escolheu uma senha, o sistema, o site lá fez o rest da tua senha de acordo com alguma função e guardou esse resto, tá? Só que só isso ainda não é uma boa ideia, porque é esse exato problema aqui. É esse exato problema. As pessoas elas são muito previsíveis na hora de botar senha. A gente não gera boas senhas, tá? Então o que que vai acontecer? E vários e vários ataques acontecem exatamente assim, tá? Você vai lá e vai construindo um dicionário de senhas, de senhas que são conhecidas, senhas. Cara, teve vazamento de senha de trouxe a senha. Então você meio que sabe as senhas mais comuns e não sei o quê. Tá, variações, né, do tipo trocar o três pelo o e pelo três, o i pelo um, lógico, é, essas coisas, essas variações, tudo isso aí é conhecido, tal, tá? Então, o que que que existe hoje? Você vai na internet por aí, não é muito difícil de encontrar. dicionários enormes e enormes de vários gigabes, de gigas e gigas, gigas, gigas de hash pré-calculados de 100 desses dicionários, tá? Por quê? Porque é muito mais fácil atacar alguém, tipo, você intercepta lá a comunicação, olha e fala assim: "Porra, tô vendo o resto do da senha ali do do do da pessoa, tá? Tô vendo o resto da da cena da pessoa." Você vai lá e procura no dicionário, tudo bem? Como é que você pode mitigar isso aí? Como é que você pode mitigar isso aí? Quem tem algum chute? Hã? Ah, mas a gente não falou de criptografar. O que que é criptografar? Pensa numa coisa mais simples assim, tipo, usa as coisas que a gente já tá vendo aqui. Diga. Anexar dados aleatórios que só você conhece. Anexar onde? Assim você calcula a primeira parte da entrada seria a aposta. A segunda parte fica por minha conta. Eu coloco o que eu quiser. Olha como é que teu nome mesmo? Rogério, olha a proposta do Rogério. Eu vou eu vou em vez de rachar direto a minha aposta, que é o esse número N aqui, eu vou concatenar e vou mostrar, marcar assim, tipo, é o juntar, tá? Vou concatenar, juntar essas duas informações aqui, vou juntar com um número que eu vou chamar de K, que eu sortei aleatoriamente. Foi mais ou menos que você falou, né? Vou juntar com uma informação K que eu sorteio aleatoriamente. E aí a o segredo aqui é esse K ser tirado de um espaço suficientemente grande para manter a segurança disso. Todo mundo bem? Por a ideia é que se você não reutilizar, se você reutilizar o K, não protegeu nada, né? Tá? Mas se você não reutilizar o K, toda vez que eu fizer uma aposta nova com o Luca, não adianta ele fazer esse dicionário aqui. Por quê? Porque mesmo ele sabendo os um pedacinho do da pré-imagem, isso não ajuda ele a calcular o restante da pré-imagem vendo o resto que que que eu tô entregando para ele. Repare, tá? Isso aqui é seguro nesse nível. Eu mostro o resto pro Luca. O Luca sabe os ns possíveis no início. Ele sabe um pedaço da pré-imagem, ele sabe alguma informação, mas ele não sabe esse restante. E isso é suficiente para ele não conseguir construir um dicionário e não conseguir quebrar esse R, a menos que ele conseguisse, tipo, calcular, fazer um ataque de pré-imagem, como a gente viu aqui, não vai ser possível. Então, tipo, se eu vou assumir que não é possível, tá? E aí eu escolho esse K grande o suficiente de um espaço grande o suficiente com entropia grande o suficiente pro Lucas não conseguir chutar esse K. Tudo bem? Esse K ele em geral recebe dois nomes, tá? Naquele contexto de senhas na internet, tal, tal que eu falei para vocês, ele ele recebe esse nome de salt. É uma pitada de sal que você bota para dar uma misturada lá no no junto com a tua senha, tá? Aqui com vocês, eu vou chamar esse K mais comumente dece. É um number, tipo, é um número que só se utiliza uma vez ou que só deve ser utilizado uma vez, tá? Eu vou usar chamar de NSE, nunce o tempo todo, tá? Nem sempre usar o repetir o é problemático, mas em geral é. Em geral é. E eu vou mostrar inclusive um caso para vocês hoje lá no final da aula. Eu espero diz que que acontece se você reutilizar o anúncio lá na hora que tiver fazendo uma assinatura digital. Vou mostrar para vocês que você consegue que tipo a outra pessoa consegue recuperar tua tua chave privada que é uma um um furo catastrófico. Se alguém tiver sua chave privada, acabou suas acabou para você, acabou sua com a sua segurança inteira. Ela virou você do ponto de vista de qualquer sistema. Todo mundo OK até aí? Todo mundo OK. Aham. O que que eu efetivamente estou fazendo na hora que eu faço um salt desse daqui? Tá. Hã, como é que você vai fazer o caminho contrário? Qual caminho contrário? Você tem por exemplo indicar. Eu tenho hash. Não, eu mostro isso aqui tudo para ele depois da da da aposta. Eu mostro para ele tudo isso aqui, ó. Ele precisa ver tudo. O Luca, tipo, eu não sei se eu entendi muito bem a pergunta, mas é, eu tô entendendo. Ah, tá. Mas se você mostrar só o N depois da depois da do jogo, depois do dele rolar o

senha, o site guarda esse solto. E aí e guardar esse solto você pode pensar que é um problema, tá? Mas ele, o site guarda esse salí

você não vê isso aí. Em princípio, você nunca viu, você bota só uma senha lá e vai, né? Uhum. Mas tem as informação lá. Tudo bem? E aí você precisa revelar essa coisa toda. O isso aqui, isso aqui que a gente tá fazendo, ó. Repare, eu vou escrever, tá? De vou usar uma algumas notações diferentes e eu já vi essas notações diferentes em vários lugares. Então, assim, eu vou tentar não bagunçar muito, tá? Mas se ficar um pouco confuso, em algum momento vocês me perguntam. Eu tô chamando de H de L. É uma função de resto. O H é X256, por exemplo, tá? Isso daqui às vezes eu vou escrever assim, H de N concatenado com K, como só tô mexendo na na na entrada, tá? Algumas vezes eu vou escrever assim H de N com K, como se tivesse mais uma entrada lá no resto, tá? Isso aqui é meio confuso, vocês vão ver algum acho que aqui aqui nesse curso não vai gerar tanta confusão, mas assim isso aqui gera uma alguma confusão, mas é tão comum que não vai ter muito como fugir, tá? E algumas vezes vocês vão ver isso aqui assim, ó, H subíndice K de N, como se fosse um outro resto. E isso aqui é uma certa, é uma forma de personalizar a função de hash de certa forma, tá? de eu ter uma função de hash única para cada vez que eu for usar a função. Só que em vez de fazer toda uma função diferente, sei o quê, eu consigo mexer nos dados e me dar esse mesmo efeito, tá? Por fim, antes da gente pra frente, isso aqui eu chamei de o K de salt ou dece, tá? E isso aqui dentro da função de hash ou então adicionar alguma coisinha na junto da função de hash não calcular a função de só dos dados, tá? Recebe às vezes o nome de twaking e a gente chama esse caso às vezes de twick. Twick é tipo, sei lá como é que traduzir isso. É, é dá uma modificada, é, dá uma mexidinha, hã, dá uma empurradinha assim, né? Tipo tirar a coisa de um lugar e botar no outro assim. Tô dando uma arrumadinha, sabe? Aquela, enfim, todo mundo quieto aí? Pergunta, filho. Vai. Pergunta, filho. Vai. Só pensa só e o o não se twó a mesma coisa? Não dizemos. Twick é você dar uma mexida no no na função de has para personalizar ela. Então, ela é diferente doce. Oce dado específico que você vai juntar com o com o seu dado mesmo que você quer passar no resto. Beleza? Entendeu?

Oi, pera aí. Oi. Não, como se fosse a classe outro objeto. Ah, sei lá. Isso foi muito longe para mim. Não sei, não sei. Professor, o salte é fixo para todos como fosse uma segunda, um argumento de uma segunda função ou ele varia para cada nesse protocolo aqui de aposta minha coma, o ideal é que eu não repito o K, né? Porque se eu escolher o K uma vez, olha só o que que eu porque aí o o fica um pouco mais difícil, mas o Luca pode fazer o ataque. É, ele olha e fala assim: "Tá bom, deixa eu deixa eu ir coletando informação. Eu sei que a hélice, eu sei que o Edils sempre repete o K. Então o que que ele pode fazer? Ele pode ir lá pegar a primeira aposta e rolar o dado genuíno, tá? Aí ele viu o hash e viu o meu a pré-imagem. Aí a partir da pré-imagem ele tá vendo o 11. Aí mesmo que ele não saiba que eu repito, ele pode fazer isso uma segunda vez. Ele vai ver uma segunda para imagem e ele vai ver o mesmo K nas duas. Aí olha e fala: "Eu tá repetindo esse K. Então eu sei já pr já daqui nesse momento. Ah, agora eu posso pegar pré-calcular o meu dicionário, fazer o meu dicionário aqui e a partir daqui agora o só perde tigrinho.

Não vou falar muito. Eu nem devia est falando se eu tô gravando, né? Mas assim, enfim, esse tipo de coisa. Eu não tô dizendo que esses caras fazem isso, mas é fácil. Mas eu tô dizendo que é fácil fazer. Afinal, quando você vai entrar lá no tigrinho, você escolhe o das coisas que você tá mandando? Não. Você que rola os dados? Não. Ah, então, meu amigo, é o probleminha de comprar monta de nessas bet aí. Eu não tô dizendo que são desonestos, não tô dizendo isso. Só tô dizendo que eu mando aposta, eu vou lá, escolho, sei lá, boto lá, o placar do jogo vai ser tanto e tanto. Eu mando, eu não, eu eu que tô colocando lá, eu não escolho 11. Para esse caso aqui é um pouco mais difícil de roubar, porque ele teria que controlar o jogo de alguma forma, né? Teria que ter alguma forma de influenciar o jogo. Mas a Bet não é o patrocinador dos dos times, tudo, [ __ ] As bet tudo. Mas ele não paga não pelo o rateio de quantos acertos? Não sei como é que funciona no detalhe. Estou dizendo que eu não confio nesse protocolo porque eu não consigo esconder a minha aposta do do da parte que vai processar a aposta. e ele consegue ver o que que eu tô apostando antes do evento acontecer. Então, para mim, para mim pessoalmente não serve. Todo mundo bem com isso? Todo mundo bem com isso? Tá bom. Essa é a ideia pergunta. Eu não sei se é pertinente assim, mas tudo é meio pertinente. Tudo é impertinente. Vamos lá. Como que o não ser gerado? Eu acho que eu não entendi essa essa. Como que o não ser gerado? Como é teu nome, filho? Antônio. Cara, Antônio, essa pergunta é uma pergunta de 1 bilhão de dólares. Como que o N é gerado? Como que o N gerado? Tá, a melhor esse, repare que esse N precisa ser imprevisível pra parte que vai que vai receber o H, né? Pois é. Tá. Pois é. Isso. A melhor coisa que você pode fazer é gerar um número aleatório. É pegar, sei lá, alguma coisa fisicamente aleatória e, sei lá, rolar dados. não viciados, pegar algum, sortear o número aleatório mesmo, que nem você consiga prever a parada. O problema é que quando você entra lá no WhatsApp, tudo isso aqui no WhatsApp funciona isso aqui, tudo isso aqui, no signo, esses todos esses protocolo de internet quando você entra lá no teu banco, tá? Vai ter um monte de gerador de número rolando o tempo todo, porque gera nom, gera chave, gera parada toda baseada no númeroatório. Você não rola dado, você não não qual a física da coisa que vai te garantir que um dado que foi aleatório é aleatório mesmo, entendeu? Então gerar esses números aleatórios é bem mais difícil do do que parece. Bem mais difícil do que parece, tá? Hoje em dia os hardwares têm embutido lá vários processadores aqui, um módulozinho para ajudar nisso, que ele pega algum tipo de de ruído, ruído térmico em transistores ou em resistores. Pega ruído de detrin. Aí é aí em eletrônico. Quando você tem um oscilador, a frequência dele fica variando, oscilando um pouquinho, não fica travadinha num f0. É um f0 mais ou menos um delta. E esse delta tem uma certa distribuição estatística, tá? Então você pode usar de alguma forma medir isso, isso se faz, tá? Não tô, isso não é só teórico, isso de fato está acontecendo aqui agora nessa máquina, por exemplo, você consegue medir esse esse essa distribuição desse delta e usar isso para alimentar um um como uma entropia inicial para um gerador de números pseudo aleatórios, que é um algoritmo que calcula o número para você. Você entra, parece um hash. Repare que um hash já tem mais um pouco essa cara. Se o se o se o x, a pré-imagem for o número aleatório, a saída também tem cara de número aleatório, não foi isso que a gente pediu lá no começo, tá? Então você consegue usar hashs para dar uma arrumada num número que tenha alguma entropia já, alguma aleatoriedade. Aí imagina que você precisa de 256 bits, uma 256 bits, mas você tem, sei lá, 50 bits aleatórios, de fato aleatório, assim, de boa qualidade, você consegue pegar e se produzir 256 bits. Cuidado porque isso não tá aumentando a entropia da parada. Se eu tenho 50 bits de entropia, sei lá, um número totalmente aleatório mesmo assim, totalmente imprevisível, mas ele só tem 50 bits. E eu botar no RH, eu consigo atacar a pré-imagem, lembra disso? Então f consigo ficar tentando fazer a força bruta na préimagem e o espaço dela é 2 elevado 50, não é o 2 256 do do R, mas eu consigo usar o R para dar uma arrumada nisso. Percebeu? Óbvio que tem que tomar cuidado, como eu tô te falando, esses geradores não aumenta a entropia. Tá? Então isso é bem mais difícil fazer do que parece. Tudo bem? Em princípio hoje é esse aqui pro como não é uma um curso de cripto ou de implementação, basicamente vou falar para você, esse não tem que ser numeratório. E aí parte do pressuposto que é possível produzir umatório,

mas é bastante comum também ataque em cima desse desse de ah tem um número aleatório lá, tem um número aleatório que você não pode tem que ser imprevisível. Eu vou mostrar para vocês aqui calcular que se eu souber o K eu consigo calcular uma chave, por exemplo, tá? Ou consigo calcular uma chave privada. Vou mostrar isso mais bem mais pro final da aula. Quer dizer que se eu conseguir chutar o seu o K que você usou lá na assinatura, você vai ver que vai ter um número aleatório vai entrar, eu consigo recuperar a tua chave e aí já era para você, sacou? Eu vou simplesmente partir do pressuposto que tem bons geradores e que a gente vai conseguir fazer isso, mas isso não é necessariamente verdade. Tem que tá cheio de tá cheio de sistema aí que envolve a centro digital que gera números eletórios fracos. Aí, se você sabe mais ou menos quando quando foi gerada a senha, se você sabe mais ou menos o dispositivo, se você sabe mais ou menos o qual era a linguagem de programação, qual era o aplicativo, aí sabe linguagem de programação, sabe dizer mais ou menos qual a função que foi usada, tal, não sei o quê, tu consegue tipo diminuir bastante assim o seu espaço de busca porque o gerador é fraco, tá? Só uma dúvida rapid quando sei lá tô gerando minha na que eu coloco palavras uma coisa. Aí eu já, né, assim, aí depois que você gera a você pode criar outra, né, você pode botar outra palavra desses números que gera, tipo assim, você gera o teu a tua que lá, tá, com tuas frases do jeito aleatório. Aham. Depois disso tem como você botar mais uma, né, aleatoria, uma pass phrase. É isso. A gente vai ver essa esquema de como é que gera essas chaves um pouco mais pra frente. Acho tipo essa peça vai ser tipo um twick, uma coisa assim, é um uma espécie de tweak para poder entrar lá junto dos dados. Porque a primeira coisa, quando aí você tá falando de sed de de das wallets, das carteiras, que ela gera aquele esquema de 12 palavra ou 24 palavras, tu pode adicionar uma best phrase em cima daquelas palavras. O que que ele vai fazer? Vai pegar aquelas palavras, entre aspas, dali vai derivar o número. Aquilo lá só uma codificação para o número. Vai derivar o número e aí vai juntar, vai concatenar com o teu, com a tua pazer. Então vai mudar o número, entendeu? Aí isso gera aí como isso vai entrar numa tonelada, numa sequência de hash isso vai se propagando. Essa entropia adicional vai se propagando e aí vai para caminhos completamente diferentes. Achados? Todo mundo bem por aí por enquanto. Tá bom.

Vou insistir. A gente vai usar, vai começar a usar restos o tempo todo. Sempre se lembra, essas três coisas é o que você precisa ter na mente o tempo todo, tá? Se eu te der o rest, não dá para calcular pré-imagem e principalmente dá não, você não vai conseguir escolher duas pré-imagens que geram o mesmo resto, calcular uma colisão, tá? Tá bom? Que que é uma assinatura digital? Então, que que é uma assinatura digital? A gente vai definir a assinatura digital por meio de três funções

por meio de três funções, tá? A primeira delas eu vou chamar de generate keys, que em princípio não recebe nenhuma entrada. em princípio não recebe uma entrada e ela precisa produzir duas informações, um par, tá? Uma primeira que eu vou chamar de secret key, uma chave secreta e uma public key que vocês vão me ouvir falar direto em vez de public porque eu acho ruim de pronunciar, eu vou chamar chamar de pub key. Pub key, pub key, Pub key e uma circuito key. Vai ter o segredo, vai ter uma chave privada e vai ter uma chave pública, tá? A gente chama a chave pública de pública porque em princípio não tem nenhum problema você mostrar isso para mundo inteiro. Em princípio não tem nenhum problema. A chave privada tem, o próprio nome diz, chave secreta, é para você manter em segredo. A gente vai, vai ficar meio óbvio para vocês que a chave privada é o que te permite construir a assinatura, tá? Então, se a assinatura te identifica no sistema, é você autorizando ou desautorizando alguma coisa num sistema, se uma pessoa pode assinar no teu lugar, aquela pessoa é você para aquele sistema, tá? Então vamos lá. Segunda coisa que eu que eu a segunda função, segunda função vai ser uma função que eu vou chamar de sign, uma função que produz a assinatura, tá? Ela recebe duas entradas. Ela recebe a sua chave privada e ela recebe uma mensagem.

Ela recebe uma mensagem. A mensagem é aquilo que você quer assinar. Diferente do mundo físico, onde você pode pegar um papel em branco e assinar e depois imprimir o contrato. Aqui em cripto não dá para fazer isso. Aqui eu preciso primeiro produzir na mensagem. E aí aquela mensagem será assinada. E aí vocês vão ver aqui aquela assinatura, aquela assinatura só é válida para aquela mensagem específica.

Bom, então vocês vão tirando aqui como é que a gente vai ver algoritmos específicos de assinatura, tá? Mas vocês podem ver que a mensagem precisa entrar na conta. Eu vou calcular alguma coisa, é um monte de número. A mensagem precisa entrar na conta. A secret key precisa entrar na conta, tá? O que que eu vou produzir? Eu vou produzir uma coisa que eu vou chamar de signat, assinatura.

Assinatura, tá? Letrinhas aqui, ó. Normalmente a gente vai chamar isso aqui de M. Várias vezes eu vou chamar isso aqui de Várias vezes eu vou chamar de S. Mas toma cuidado porque nem sempre o S que tem numa assinatura é a assinatura toda. Precisa de mais informação, tá? Então, mas é bem comum ver aqui, chamar aqui de S. A chave secreta eu vou chamar de E. E aí é de historicamente é uma chave de encryption, tá? É uma chave para cifrar alguma coisa, enfim que seja. E a public aqui com vocês, vocês vão ver que é bem comum chamar de P maiúsculo.

Um pouco mais pra frente vai ficar um pouco mais claro porque P maiúsculo e não um P qualquer minúsculo. Então eu vou usar o P minúsculo para outra coisa, tá? Mas é bem comum chamar de P a chave pública, tá? Ou PK e SK. Vocês vão ver assim também, tá? Pk, SK. Bastante comum assim. Acho que até melhor, uma anotação até melhor, talvez.

A última função é uma função que eu vou chamar aqui de verify, que verifica se uma assinatura é válida. Verifica se uma assinatura é válida. Diga. Qual que é o nome da primeiração? Sign da primeira. Generate keys é uma função que gera as chaves para você. Então você simplesmente para dizer que você consegue gerar uma chave pública,

você precisa usar ela em algum momento. Você precisa ter uma chave para uma privada e faz parte do pressuposto que eu tenho como gerar isso. Mas eu vou mostrar obviamente alguns como é que você gera algumas chaves, porque cada sistema é um um sistema diferente, tá? O verify ele vai receber três informações. Três informações. A mensagem. A mensagem. [ __ ] meu Deus, deu pau na mão. Message, a mensagem que supostamente foi assinada, a assinatura que eu quero verificar

e a publica,

à chave privada de quem assinou. Repara. A chave privada eu uso para assinar, a chave pública eu uso para verificar, tá? E aqui eu vou produzir, vou chamar assim de

bezão, que é um buleno, tá? Isso aqui é o conjunto que só tem verdadeiro e falso. Verdadeiro quer dizer que aquela mensagem M específica foi as foi as ah, perdão, aquela assinatura S que eu recebi de fato assinou aquela mensagem M específica que eu recebi e quem assinou usou a chave privada que está ligada àquela mesma chave pública que eu usei para verificar. Eu tô validando tudo isso. Oi. A gente vai ver a conta dessa coisa. Cada tem várias formas diferentes de viver isso aqui, tá? Mas de fazer isso, de implementar isso. Repare que tá extremamente abstrato, mas é isso que esse verifi tem que fazer. Ele tem que me dar verdadeiro se aquela assinatura de fato assinou aquela mensagem específica e a chave que foi e a chave que foi usada. é a secret key que tá conectada, que é o par daquela pub key que eu usei para verificar. Se der falso ou se qualquer uma dessas coisas não for verdadeira, é para dar falso o resultado do verify. Ou eu não usei a ou alguém me deu uma public errada, ou alguém me deu uma mensagem alterada, não é a mensagem que foi assinada, ou alguém mexeu na assinatura.

ou alguém não sabia a chave privada que deveria realmente assinar, porque de novo, a chave pública é conhecida, mas você pode tentar pegar a chave pública de alguém e tentar assinar alguma coisa no lugar dela. Aí a ideia é que você não sabe a chave privada, você pode tentar forjar uma assinatura, entendeu? A ideia é que essa função consiga verificar isso. Tudo bem? Repare que isso aqui me dá duas duas duas garantias, né? me dá duas garantias, tá? A primeira delas é, primeira garantia é a pessoa que assinou é quem deveria ter, é quem quem ela diz que é. Então, se você de fato, se eu consigo de alguma forma provar que você é o dono de uma certa secret e tem uma certa assinatura que é válida para uma certa Puby, você não consegue negar que foi você que assinou.

é uma propriedade que a gente chama de non repudiation. Você não consegue negar que foi você que assinou aquilo se foi realmente usada sua chave. Claro que você pode falar assim: "Ah, professor, mas alguém foi lá e roubou minha chave". É, mas tipo assim, pro sistema o dono da chave é você, entendeu? Aí é uma outra questão, mas dentro do sistema criptográfico você não consegue negar que foi você que assinou, que foi aquela chave que assinou. Pergunta, Jack. Eh, a biometria pode ser usada como hum como pode ser usada como o quê? A CR C. Eu acho que seria uma péssima ideia. A pergunta é se eu posso usar algum esquema de biometria para como 50 K. Eu acho que é uma péssima ideia. E e cara, eu não vou dizer que não tem sistema fazendo isso. Eu acho que é uma péssima ideia fazer isso, porque sua biometria você larga por aí o tempo todo. Por exemplo, vai botar digital em algum lugar, velho, você bota muito tudo quanto é lugar o tempo todo. Você tá espalhando sua digital tudo no mundo inteiro. Aí você, sua digital é o que você usa para calcular uma chave secreta. Tipo, tá, velho. É, é só tu seguir a pessoa um dia e ver onde é que ela foi botando na mão, velho. Já era, velho. Fala sério, né? Então assim, não tô dizendo que não tenha sistemas que não façam isso, que provavelmente tem sistemas que fazem isso. Para mim é nítido, é trivial, que é uma péssima ideia. E escaneamento de íris, escaneamento facial, tudo isso aí para mim são péssimas ideias para pr para produzir circuito kit. Tá tudo bem? Uma boa ideia fazer uma circuit sortear o número aleatório. A gente vai ver que a circuito aqui que é um número. Sorteia o número aleatório e guarda ele com você. Melhor coisa você pode fazer. Inclusive no no GPG quando você vai gerar uma um uma ficar você carga na CPU fica mais adapado. GPG é um sistema criptográfico que você permite você assinar coisas e assinar, cifrar, decifrar e não sei o quê. Trocar mensagem cifrada com outras pessoas. E aí quando você tá setando o sistema lá, você precisa gerar um par de chaves e guardar essas chaves com você. Aí me o mouse, abre o é ele pede lá, tipo, mexe o mouse, tipo, abre um processo que usa muito disco e tal, não sei se porque isso ele vai usar esse tipo de coisa como fonte de entropia. Mas enfim, vamos cuidado sistemas, tá? Cripto parece muito fácil, tá gente? Mas se pegar se pegar e inspecionar uma fiser uma multitoria dos sistemas que usam cripto, vai ter duas classes sistemas. aqueles que são aqueles que a gente ainda não sabe como quebrar, tipo de banco, tipo as coisas que provavelmente são mais bem feitos. E tem aqueles que já estão quebrados e alguém só não percebeu, já estão assim trivialmente quebrados e alguém só não teve interesse em ir lá e fazer alguma coisa com aquilo. Hã, só não tem interesse em explorar, é porque sei lá, tá? Então toma muito cuidado, tá? na hora de usar cripto. Mas tudo bem aqui. Mensagem é o qu? É mensagem, uma mensagem qualquer que você quer assinar. Ah, tá. Eu tava dizendo aqui, primeira propriedade, né? O non repudiation. Quem, tipo, se eu seu, se uma certa mensagem, uma certa assinatura para uma certa mensagem é verificável com aquela PUB key, o dono da Secrety não consegue dizer que não foi ele que assinou, tá? Tá. ligado, tipo que nem unha carne essa coisa aqui, ó. O non repudiation. Segunda garantia que isso que essa assinatura me dá é uma certa forma de, como é que é o nome disso, gente? É uma certa garantia de que ninguém mexeu na minha mensagem. Porque se eu mexer um bit na mensagem, a assinatura vai ficar inválida. Se eu mexer na mensagem, a assinatura fica inválida. Perceba a coisa. Autenticidade. Autenticidade. Isso é a palavra que eu tava procurando, tá? Isso me garante, me dá alguma garantia de autenticidade sobre essa mensagem, de que essa mensagem não foi alterada no em trânsito. Todo mundo OK com isso, tá? E a gente vai ficar começar a usar essas essas propriedades para construir protocolos, tá? Normalmente os protocolos são mais interativos assim, eles estão tipo, ah, eu faço isso, outra pessoa faz aquilo, alguma coisa assim, tá? Mas eu posso fazer, usar esse tipo de coisa para fazer eh para me autenticar no sistema, por exemplo, tá? Para autenticar o sistema. Vou mostrar aqui para vocês um pouco mais paraa frente aqui eh algumas formas de usar centro digital, não sei o que, essa coisa toda. Todo mundo bem por enquanto, tá? Mas repare, em criptomoedas, Bitcoin e todas as outras criptos, tá? Onde que a gente vai assinar usar assinaturas digitais? A gente vai usar assinaturas digitais para autorizar gastos. E aí, o que que vai ser a mensagem? Uma certa transação falando, pega o dinheiro que é meu e transfere pro fulano pro fulano e aí como é que eu autorizo isso usando uma assinatura digital? Esse é o esquema mais comum. Esse é o esquema vanila assim, é o básico, o básico do básico, tá? Eu usar a assinatura digital para autorizar alguma coisa. Que coisa? A a coisa que tá descrita naquela mensagem. E aquela mensagem vai ser uma transação que fala para eu fazer alguma coisa no sistema. Todo mundo OK? Sim. assinatura digitais, por exemplo, sei lá, do sistema do CBR também usa esse sistema ou só tá falando especificamente da Não, todo isso aqui é assinatura digital é um é um qualquer esquema criptográfico tem essas três essas três eh funções aqui. E aí tem várias formas de implementar isso aqui. Reparem que isso aqui tá bem genérico, tá? A gente vai ver duas formas hoje aqui de implementar as centras digitais, tá? Aí a gente vai ver três esquemas, um baseado em hash e depois na segunda metade da aula um outro esquema que é baseado em teoria teoria dos números, né? Tipo coisas fatos com números, tá? RSA não, eu não eu nem vou falar de de RSA aqui. Eu vou falar já de curva elíptica, que é o que eu uso em todas as criptométras. Professor, para você fazer a verificação, você tem que a mensagem original. A mensagem original é perder a mensagem original você Oi. No caso, se você perder a mensagem original, se você perder a mensagem, já era. Aí não vai, não faz sentido a assinatura dela, né? Não tem como extrair a mensagem original de uma assinatura. Não tem como extrair a mensagem original a partir de uma assinatura. Não tem como. Professor, é uma dúvida. mesmo que eu falo, faz uma mensagem que não tem sentido, ela vai ser validada, vai, mas a vou te dar 10, por exemplo, eu eu crio uma mensagem que pro sistema é uma mensagem válida, mas a assinatura é válida. Isso quer dizer que a primeira coisa que o ST vai olhar é aí depende um pouco da de como é implementado, mas uma das coisas que eu vou olhar é tá a autorização está OK, está aí agora vou olhar a semântica da mensagem, tá? Aquela, aquela mensagem faz sentido? Não, aquela mensagem é inválida, então joga fora. Ah, veio de quem deveria ver, vir e quem tá querendo fazer, de fato, pode fazer, mas ele tá tentando fazer uma coisa que não é permitida no sistema, então joga fora. Não é a única coisa que garante que alguma coisa vai acontecer no sistema. Isso aqui é para autenticação, é para você dizer que você é você mesmo.

Todo mundo bem até aí podemos, tá? O primeiro esquema de hash que a gente de assinaturas digitais que a gente vai que a gente vai ver aqui, ele chama é chamado de Lamport signature,

Lamport signatures, que foi inventado final dos anos 70, o começo dos o dos 80, final de 70, 70 alguma coisa, 77 ou 78, se eu não tô enganado, por um por um por um pescador chamado Lesle Lamport. Por isso que ganhou esse nome dele, tá? E a qual que é o o tchan da parada, tá? A gente só precisa para implementar isso aqui de hash vai ver que é um uso, vamos chamar assim, inteligente de ros, tá? Professor, que perguntar, esqueci. Eh, tem alguma implementação que você vai usar, por exemplo, um hash dentro de um hash? Um hash dentro de um hash tá? a gente usa em alguns contextos. Sim. É, você tinha perguntado naquela outra etapa, como é que a gente garantia, por exemplo, um dado lá, se o cara soubesse, se tivesse um m, eu queria perguntar se, por exemplo, teria que fazer o r é, tá aqui atrás aqui, né? Aqui nesse exemplo atrás, em vez de usar o K, você mostrar para ele ah, do H do N. Isso. Mas aí usando, por exemplo, outra função de hash, um hash zero aqui, um hash um aqui. Isso. Mas se o Lucas souber o o H0 e o H1, ele vai lá e calcula do mesmo jeito, não tem nada. Eu vou precisar para autêntico, para verificar se você fez o lance correto ou lá. Você pode chamar isso aqui de h grande de N e considerar que é uma função de hash um pouquinho mais complicadinha, mas é a mesma coisa, entendeu? Isso aqui não melhora. E no Bitcoin a gente usa X256 duplo, que é X 256 de de Xá 256 de alguma coisa. O tempo todo, todo aquele rest que eu mostrei para vocês ali no no Block Explorer é é chá 256 duplo. Não tem uma boa explicação do porque que é assim. Não tem uma boa explicação. Satosquis. Porque essa tosquisa é, em princípio mitiga um certo tipo de ataque que é bem específico do XH256, mas tipo assim, hum, é porque tem um monte de Bitcoin, tem um monte de coisas que que a explicação simplesmente é porque o Satos quis fazer assim e foi e agora já era, não tem como mudar, tá? Outras moedas que vieram depois, elas foram falando: "Ah, tá, a gente não precisa fazer isso porque, tipo, talvez tenha uma alguma jusicativa melhor para fazer de outra forma e aí tem uma certa jicativa melhor". Tá, mas é cheio dessas coisas em todas as criptos. É cheio dessas coisas. Ah, por que que tal coisa é assim? Por que o cara que fez decidiu que era assim?

Tá? Então, vamos lá. Lamport signatures. Lamport signatures.

Então vamos lá, ó. Presta bem atenção, porque os ficam uns números meio grandes. Eu vou desenhar uns quadradinhos no lugar de números, tá? Então vamos lá. Eu preciso gerar gerar uma chave pública e uma chave privada, tá? Eu vou fazer tudo aqui com H de 256 bits, mas você pode fazer com H de qualquer tamanho em princípio, tá? Então vamos lá. Como é que que eu vou fazer, tá? Primeira coisa que eu vou fazer é, eu vou gerar dois conjuntos de números de 256 bits. Cada um desses conjuntos tem 256 números.

Que que eu quero dizer com isso? vai ter um conjunto que eu vou que vai representar o bit zero. E aí esse conjunto vai ter

256 números. Cada um deles aqui tem 256 bits. Então isso aqui tem 256 x 256 bits, né, que dá 4K bytes, eu acho, por aí. Só multiplicar aí, tá? Eu vou gerar um outro conjunto desse. O ideal é fazer isso aleatório, tá? Tipo, sai gerando os números aleatório aí que vai que eu vou usar depois para representar os números um.

Tudo bem? E aí eu vou chamar esse conjunto de chave privada. Que que é minha chave privada? Um conjunto que tem duas vezes 256 x 256 bits organizados desse jeito aí. Cada bloquinho de 256 bits eu vou é uma palavra que eu vou usar para alguma coisa e isso vai ser minha chave privada. Eu guardo isso aí comigo. E a chave pública como é que vai ser? Eu vou pegar e vou produzir um outros bloquinhos aqui do mesmo tamanho, tá?

Um para cada um desses dois aqui.

Aqui tem 256

elementos. Cada um tem 256 bits. E o que que é cada um desses desses elementos? é o rche daquela posição da minha chave privada. Cada um deles aqui, eu pego esse pedaço, calculo o rest, vai ser esse primeiro pedaço da minha chave pública. Daí eu pego esse pedacinho aqui, faço o resto dele, vai ser esse pedaço da minha chave pública. E eu faço isso para todos eles. Então eu produzi aqui minha chave privada em preto, eu guardo isso, minha chave pública em cinza, eu mostro isso. Posso mostrar isso pr os outros. Todo mundo bem? É bem straightford, né? Não tem muito por fazer isso, tá? Repare que a partir da minha chave pública não dá para calcular minha chave privada, porque para calcular minha chave privada eu teria que conseguir, eu tô vendo um hash e eu teria que calcular a pré-imagem de um hash. Então não consigo calcular. Vendo a chave pública, eu não consigo calcular a chave privada. E eu preciso que isso seja verdade o tempo todo, tá? No no todos os sistemas. Aí vai ter diferentes formas de proteger isso, né? Aqui a gente tá fazendo com o resto. Todo mundo bem, tá? Como que eu assino alguma coisa? Como que eu assino alguma coisa? Tá? Eu tenho uma mensagem M que eu quero assinar. Eu vou lá e calculo o resto dela. O resto dela vai ter 256 bits. Então vai ter um monte de bit aqui, tá? 0 1 1 0 blá blá blá blá 0. Um monte de bits aí, os bits que forem, certo? Aí na hora para construir a assinatura, o que que eu faço? Se a minha assinatura aqui, o bit for, se a mensagem, o bit for um certo bit for zero, eu seleciono esse bit aqui, essa, esse bit não, essa palavra toda, 256 bits, e coloco aqui na assinatura.

Se é um na mensagem, no resto da mensagem, eu pego lá na posição correspondente e coloco aquele bloquinho de 256 bits na assinatura. E aí eu vou fazendo isso. O próximo bit é um. Peguei aquele vou pegar de outra cor inclusive porque eles são diferentes, né? Esse cara aqui, ó, é outra coisa. Boto aqui. E aí eu vou fazendo isso até completar. Então, qual o tamanho da assinatura? 256 x 256 bits,

que é relativamente grande, tá? Isso é alguns kilobby todo mundo OK? Pergunta não. Tudo bem? Tá todo mundo bem, né? Como é que construir a assinatura? Como é que eu verifico? Pergunta na chave privada. O zero ali é uma aquele zero é uma parte da chave. Qual zero? Isso aqui é zero. Esse esse cara que eu marquei aqui, o zero todo. Esse zero. Não entendi. Isso aqui é isso aqui. Eu só separei em dois pedaços para você olhar e falar assim: "Ah, quando uma parte vai representar os bit zero e a outra parte vai representar o bit". Porque olha lá, no final das contas, que eu vou fazer esse processo aqui embaixo, ó. Quando é zero alguma coisa, eu pego do conjuntinho da esquerda. Quando for um alguma coisa, eu pego do conjuntinho da direita. E de onde veio esse conjuntinho cinza da esquerda? veio daqui e esse veio daqui. Por isso que eu separei em dois pedaços,

entendeu? Mas é só você botar os bits lá, tipo, como é que você faz isso em C? Int, sei lá, Scret key array, 300.000 bits você precisa lá, quantos bytes você precisar e bota eles na sequência. Só que você sabe, beleza, esse esse byte é para aquilo, esse byte é para aquilo outro, entendeu? Só tô mostrando graficamente aqui para ficar tentar ficar um pouco mais visível. Tudo certo? Como é que verifica uma assinatura então? Como é que verifica uma assinatura?

Eu falei besteira. Deacho. Isso aqui tá errado. Volta um pouquinho. Volta um pouquinho. Eu vou fazer o seguinte, ó. Se for um zero na mensagem, no resto da mensagem, eu vou pegar da minha private key, da minha chave privada e vou botar aqui, ó, um pedacinho dela. Se for um, eu vou pegar da minha chave privada e vou botar aqui 256 bits. Eu vou tirar daqui da privada e vou botar aqui e assim por diante.

Tudo bem? Todo mundo bem. Lembra? A chave eu uso para assinar, eu uso a chave privada, não a pública. Por isso que eu tava me embolando aqui. Todo que todo mundo bem? Como é que eu verifico isso? Tu vai receber, tu vai receber para verificar o M, você vai lá e calcula o resto do M. Então você recupera isso aqui, ó. Você recebeu a mensagem, calcula o resto, você recupera essa sequência de bits. Hã, não se indica aí não tá aparecendo. O que que não tá aparecendo?

Tá aparecendo. Tô vendo a tela aí. Vamos lá. Eu recupero essa essa esse string aqui, ó, tá? Que é que é que representa a minha mensagem, né? Eu tô recebendo essa assinatura aqui, ó. Eu tô recebendo isso aqui e eu recebi a chave pública. Eu vou chamar de P grande. E eu recebi o S, que é esse esse pedaço aqui. Eu recebi essas coisas. O que que eu não recebi? Eu não recebi esse, ó, que é o chave privado, tá? Tá bom. Como é que eu vou verificar? Então, olha lá. Eu venho aqui na mensagem. Eu venho aqui na mensagem e olho. Tá bom? Primeiro bit aqui é zero. Primeiro bit aqui é zero. Eu pego esse pedacinho da da assinatura, calculo o r dela e comparo com essa palavra que tá aqui, que eu conheço. O P eu conheço todinho. Se bater, eu sigo. Se não bater, que que quer dizer? Quer dizer que esse essa palavra aqui não veio do resto daqui, ó, que é o que deveria ter acontecido no começo.

Se bater, eu sigo. Eu tô vendo que aqui tem um. Eu pego esse pedaço da assinatura, calculo o resto dela e comparo com o resto que tá aqui. Se bater, eu prossigo. Porque, lembrando, esse quadradinho vermelho que tá embaixo é esse quadradinho vermelho que tá aqui em cima, ó. supostamente foi copiado. Supostamente o que tem aqui é o radinho vermelho.

Então aqui se tiver o mesmo quadradinho vermelho, na hora que eu calcular o rche daquela coisa, tem que bater com o que tá aqui. Eu recebi o P todinho, e qualquer um desses restes que não bater, eu vou rejeitar isso aqui, porque ela não veio da chave privada que deveria. Ou a chave pública tá quebrada ou a mensagem foi mexida. Repara que eu não consigo descobrir o que é que aconteceu de errado. Eu só sei dizer isso aqui tá errado. Rejeita essa parada. Pergunta. Eh, quando eu confirmo que essa assinatura é correta. Eu não obtive um pedaço da da chave privada. Muito obrigado por essa pergunta. Pergunta melhor é o seguinte. Eu fui lá e validei a chave, essa essa assinatura. Eu não tô vendo a chave privada ou pelo menos pedaços dela. Você tá vendo, não tá? Olha aqui, ó. Pedaços da chave privada tão aqui, ó, direto para você. Não tão em claro. Quanto que você aprendeu da chave privada? Quanto? Não foi pouco não. Quanto que você aprendeu da chave privada? Metade. Metade. Tu aprendeu metade da minha chave privada? Sabendo metade da minha chave privada, você consegue assinar alguma coisa no meu lugar? Ainda não. Ainda não. Mas se eu usar a mesma chave para assinar uma segunda mensagem, tu concorda comigo que o R parece, o Remin aquela cara de meio aleatório. Então tu concorda comigo que esses bits aqui vão mudar, né? E aí na média eu vou revelar um outro um outro pedaço da minha chave privada. Quanto? metade, metade daquela metade, porque metade da chave toda eu já conhecia. Aí a metade que eu não conhecia, na média, eu vou conhecer agora metade desse conjunto tava desconhecido. Quanto que eu conheço agora do total? 3/4. Com 3/4 você consegue assinar no meu lugar? Ainda não. Ainda não, cara. Ainda é muito bit para você para você, tipo, conseguir tentar ficar aqueles que você não conhece. Você precisa ficar testando muita combinação ainda. Mas aí eu fui lá, assinei uma terceira vez com a mesma chave. Quanto que eu conheço da da chave da chave privada? 7 7 o

sei lá. É é meio + 1/4 + 1/8. Quanto que é isso? Isso aqui é 2/8. Isso aqui é 4/8. Então é 4 do 7 o 7 o tá certo e eu não sei de nada. 7/8 7/ 7 o

quase 90% já, né? É quase 90%. E aí já começa a ficar factível de você chutar o resto dos fazer uma força bruta até encontrar o resto. Que lembra que você tá vendo a PUBY, tá? Você tá vendo a PUB, você tá vendo os restos? Você pode ficar fazendo força bruta até encontrar esses caras aqui, ó. Só que agora você não tem tantos para tentar encontrar, você precisa achar bem menos. E aí começa a ficar factível de se fazer isso, tá? Que que você conclui então, Amélia, desse desse esquema aqui de Lamport sig,

uma assinatura que você só pode usar uma vez, né? Não é uma é um conjunto de chave público e privado, você só pode usar uma vez. Por isso que a gente vai chamar esse esquema de one time signature. Você gera uma um par de chaves e aquele par de chave só pode ser usado uma vez, tá? Isso é um problema, isso é um baita problema, um big problema na real. Por quê? Porque eu preciso ficar gerando chave pública e privada nova o tempo todo e essas chaves são relativamente grandes e eu preciso ficar guardando essa parada dessa tralha toda aí, ó. Tá? Não, só isso, eu preciso ficar revelando essas pub keys e elas são grandes. Eu, pô, várias pub keys que eu preciso, cada vez que eu assino, eu preciso uma uma uma chave nova, uma chave nova, uma chave nova, uma chave nova. E aí eu preciso começar a gerenciar muitas chaves. Quantas chaves? Quantas mensagens eu quiser assinar? Então, repara que essa coisa escala escala de n, a quantidade de chaves que eu preciso, onde n é o número de mensagens que eu quero assinar. Se for uma ou outra mensagem, beleza. Mas se for um sistema que precisa gerar assinatura digital o tempo todo, pensa no no na Visa processando sei lá quantos milhões de de transações por segundo. Cada uma delas tem assatura digital lá no meio. Não vai rolar tempo também. Guardar o tempo também que ela foi usada. Tempo aí é outra coisa do sistema que a gente só tá olhando a parte de assinatura. Talvez precisa do tempo, mas aí já na parte do protocolo. Se eu for assinar de novo, o que que é diferente disso? Só para só de eu gerar um número, um monstro, por exemplo. Como assim? Se eu só vou usar assinatura uma vez, porque aí eu tô meio que eu eu vou tipo, você quer gerar o N botar onde? Não, eu só uso a assinatura uma vez. Isso não é muito diferente de eu gerar um não. Gerar um e fazer o que com ele? E passar a mensagem e assinar. Não entendi. Não entendi. Onde? Onde que você quer colocar o nome? Tem uma mensagem. Tem uma mensagem aí. Eu boto o nonce e eu tiro o resto disso assim. É. Tá. E já que o só passo na mesa, só acaba não sendo diferente disso, né? Porque é, mas aí esse tá meio inútil, né? Por enquanto. Mas ele vai ser útil na hora que a gente voltar do almoço.

Tá adiantando um pouquinho de coisa, mas ele ele vai ser útil, mas só do jeito que tá aqui não ser para muita coisa não, porque eu só vou assinar um aquela Eu só vou assinar essas chaves uma vez. Então esses restos aqui só vão entrar uma vez e acabou a conversa. Aí preciso gerar um conjunto todo novo de chaves para assinar outra coisa. Eu acho que talvez uma uma um detalhe aí seria que esse não, se você publicasse ele, você poderia assinar outra coisa com ele também. Não tem essa. É não. Mas aqui o problema não é não é não é não é a mensagem. O problema não tá na mensagem. O problema tá no fato de que a assinatura revela partes da chave privada. a assinatura, o S aqui, ó, que eu te entrego aquilo ali, você sabe que tem pedaços da chave privada. Você só pode, você vai só separando, você já sabe, ah, a chave privada tá aqui, ó. Entendeu? E eu tenho que te dar o M, porque o M é o que você quer validar. Então, você não sabe, você sabe não só que tem parte, mas você sabe qual parte, em que pedaço da da chapa, cara, você sabe dizer exatamente, ó, na aqui em cima, aqui em cima, quais os pedaços que você já tem.

Porque eu preciso te mostrar mensagem para você validar. Se você não soubesse, era um pouco mais difícil, porque você sabe que tem, mas elas estão misturadas lá. Você não sabe onde, qual a posição. Não, não, não. Aqui você sabe até as posições, mas é seguro para uma assinatura só. Segura só. Tá. Pergunta meio porque você, tipo, você tá mostrando a trav diretamente, porque parece que você tá mostrando como que o rest dela, né? Não é o rest dela. Quem? Não, não. Aqui na assinatura, repara que esse esse 256 bits entraram aqui dentro, ó. É direto os bits da chave privada aqui. Então eu estou revelando sim partes da chave privada. E quanto mais eu assinar, mais eu vou revelar. Até que uma hora alguém sabe qual é a minha chave. praticamente calculou minha chave toda. Professor, pergunta. Eh, mas tipo assim, o que você precisaria fazer basicamente na forma na força na força dúvida para descobrir, sei lá, o final da chave seis, seria encontrar uma pré-imagem que gera a resta públicos. É, é isso. Isso. O ponto difícil é isso. Aliás, calma, só calma. Essa é uma possibilidade, você vir aqui e ficar testando pré-imagens para achar rests aqui. Mas para forjar uma assinatura, você não precisa fazer isso. Para forjar uma assinatura, você pode falar, pensar assim, ó, eu já sei esse pedaço aqui, ó, mas eu não sei o equivalente do outro lado. E aí, o que que você pode pensar? Eu vou mexer na mensagem de tal forma que aquele bit cai no lugar que eu já sei, porque é o resto da mensagem que define, entendeu? Isso é bem mais fácil de fazer do que ficar tentando achar um uma uma pré-imagem para calcular a chave, a chave privada. É você ir mexendo na mensagem para achar uma colisão, a gente vai chamar isso aqui de colisão parcial. Tem um bit só que eu quero que esteja num lugar específico lá na saída do resto. Isso a gente vai chamar de colisão parcial. A colisão parcial é bem mais fácil de de encontrar, porque para achar uma colisão de um bit só num hash, eu preciso testar duas entradas, entendeu? Então é relativamente fácil você falar assim: "Ah, beleza, eu só preciso encaixar um zero nesse resto, nesse nessa posição. Eu eu eu gero uma mensagem assim, eu mexo no bit ali, tipo dois, três passes, eu vou encontrar. Se eu tiver que mexendo a mensagem inteira para achar uma colisão, é 2 a 128, não vai dar. Por isso que se eu revelar metade da chave você ainda não consegue fazer porque é muita coisa ainda, tá? É muita coisa. São 256 bits, você precisa quebrar ainda 128 bits. Só que a medida que você vai revelando, revelando mais da chave, mais da chave, mais da chave, quantos bits você tá em posições que você conhece um lado e não conhece o outro, entende? Uhum. Aí, esses aqui você precisa encontrar uma colisão, só que só nesses bits. Aí vamos pensar que seja, sei lá, 10 bits, 20 bits, 30 bits. 30 bits. Achar uma coleição de 30 bits, tu teu celular faz em se bobear faz em minutos, em menos de é minutos, talvez, entendeu? Aí, ó, bum, é rapidão. E aí, o que que você tá fazendo? Você não tá exatamente calculando a chave privada da pessoa, mas você tá forjando uma assinatura, porque você tem uma mensagem, uma mensagem, e você calcula uma assinatura válida para aquela mensagem com aquela com aquele pedaço de chave que você conhece. Aí é um pouco mais difícil fazer um ataque do que só isso que eu tô falando, porque a mensagem tem que fazer sentido no sistema que você tá atacando. Sim. Mas em geral, no sistema você tem algum espaço para mexer nas mensagens, entendeu? Em Bitcoin a gente tem bastante espaço porque como vai uma assinatura digital dentro da transação que é o que eu uma a coisa que eu assino e aí vai virar um enfim e na assinatura digital vai um e tem que ser aleatório, eu tenho alguma fonte de entropia que eu consigo ficar mexendo na mensagem, ficar assinando, assinando, assinando, assinando de novo, entendeu? Até para tentar bater uma mensagem de novo. Tô falando de novo, não é tipo assim que você vai lá e com um minuto você quebra, mas os caminhos estão dados, tá vendo? É. Fica bem mais fácil. Fica bem mais fácil.