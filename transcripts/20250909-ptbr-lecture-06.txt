Então, tá bom. Vamos lá, então. Vamos lá. Deixa eu falar um pouco sobre o outro tipo de assinatura

de assinatura com curva elíptico, porque não só porque é interessante, mas porque é útil, importante, tá? E e basicamente todas as crips estão indo para usar esse tipo de construção agora, mas tem que tem algumas coisas que você precisa a tentar.

Lembrando, o que que a gente tem para trabalhar na nessa esquema de criptogógrafo de curvas elítricas, tá? a gente tem uma noção do que que são escalares. E os escalares eles permitem a gente fazer a continha de A + B, a continha de A - B, porque todo elemento, no nesse conjunto aí dos dessa coisas que chama de escalares aí, todos os elementos vão ter uma inversa da aditiva, tá? para todo B tem um B. Então você sempre consegue fazer a subtração, tem uma noção de multiplicação bem definida e tu consegue fazer a dividido por b, que na verdade é fazer a multiplicação pela inversa multiplicativa. E aí na construção a gente exigiu que todos os elementos, exceto zero, tem uma inversa multiplicativa. Então é, eu sempre consigo fazer essa, essas operações aí na construção que a gente fez. É, tem uma ver que você fala que sempre vai ser inteiro até tipo na dição. Isso no caso específico que a gente tá fazendo, esses A e B, eles pertencem a um conjunto que eu chamei de FP, que é o conjunto 0. São números inteiros. Tá, até o elemento P - 1. E a gente viu que esse P aqui era um número lá 2 a 256 - 2 a 32, blá blá blá, alguma coisa. Aí era um número bem grandão.

Todo mundo OK com isso? Beleza. A partir daqui a gente construiu uma noção de pontos. Então eu tenho essa outro outra coisa que eu tô chamando de pontos, que são coordenadas XY.

coordenadas X, Y que respeitam uma certa relação entre essas duas coordenadas. Aí a gente viu que tinha uma equação, né, que era y a y cubo, tem que ser x² e + ax + b para dar duas constantes a e b aí escolhidas. Hã, não era isso aí.

É isso aí, né? Não. Ou aí é y². É, eu é assim, é pronto para dar das constantes a e b, tá? E a o que a gente chama de curva elíptica é o conjunto de todos esses pontos X y que satisfazem essa equação com A e B escolhidos, tá? Onde X, Y pertencem a esse conjunto que o conjunto do campo ferido, tá? E a gente definiu uma operação de soma para ele. A gente não definiu uma multiplicação, a gente definiu uma soma. Então eu posso fazer

e aqui com vocês na maior parte do tempo, eu vou usar letra pequena pros escalares e letra grande pros pontos. Então a gente consegue fazer a + b, somar dois pontos. A gente construiu uma noção dessa soma que era aquela coisa de traço uma reta, não sei o que, aquela coisa, tá? Como cada ponto tem uma inversa aditiva, eu posso fazer a - b, tá? Mas eu não posso fazer multiplicação. Não existe uma noção de o que que é a x b e nem dividir, tá? Não tenho essa noção, então não posso fazer isso aqui, tá? E eu posso fazer uma certa certas operações que combinam essas duas coisas, tá? Eu posso fazer um ponto vezes um escalar vezes um ponto. Como esses escalares são inteiros, n vezes um ponto é o ponto mais o ponto mais o mesmo ponto. Bá bá, n vezes foi assim que a gente definiu, tá? Então tem uma noção, uma noção de multiplicação por escalar nesses pontos aí, tá? E como cada escalar tem uma inversa, eu tenho uma noção também de que eu posso fazer a dividido por um escalar, que é a inversa dele vezes o ponto, tá? Então eu posso dividir esses pontos pelos escalares, todo mundo OK com isso? Isso aí é o o os blocos básicos, as primitivas que a gente tem para trabalhar, tá? Isso que a gente tem para trabalhar. E aí tudo parte da ideia de que por que a gente construiu essa coisa aqui, tá? Tudo parte da ideia de que eu posso escolher um certo número, um certo número não, um certo ponto G, que é um ponto gerador na curva, que a gente prédefine qual vai ser. Todo mundo concorda que ponto é esse, tá? De tal forma que quando eu faço um escalar que eu vou chamar de E, vou lá e escolho um escalar e que eu vou chamar de chave privada e multiplico por esse ponto gerador, isso produz um certo ponto na curva que eu vou formar de P e esse P vai funcionar como uma chave pública. Então, toda hora que vocês verem os escalares aqui, eles são chaves privadas e toda hora que você vê nesses pontos, eles são chaves públicas. São as coisas que a gente de fato mostra, publica e os escalares são as coisas que a gente não mostra. Pergunta, tem que falar um pouco mais alto. Tem que falar um pouquinho mais alto. Pode falar sobre

como é que é um ponto divido por escalar? É multiplicar o ponto pelo inverso multiplicativo do escalar.

Tranquilo?

Então, em geral, a gente vai chamar isso aqui de chave privada. Eu vou tentar usar mais como SK de secret key e o P como public key ou PK. Vou tentar usar mais assim porque é um pouco mais consistente essa anotação. Todo mundo OK? Ah, desculpa, antes eu te passo a palavra. Essa essa multiplicação tem uma propriedade nesses nesses na curva elífica usando esses pontos nessa construção, usando esses tipo de campo finito aqui, que é o seguinte, essa direção aqui, ó, da conta é relativamente barata de fazer. Eu tenho as fórmulas fechadas e eu vou lá e calculo, tá? Eu vou lá e calculo, mas essa direção aqui que é se eu souber o, se eu souber o P, se eu sou e eu sempre sei o G, a ideia é que eu não consigo calcular o E. A melhor coisa que eu posso fazer é ficar testando vários e es e vendo qual deles satisfaz essa equação aqui, tá? Isso é um tipo de função de uma direção, né? Tipo one way function. Tipo, eu consigo calcular alguma coisa facilmente se eu souber um certo segredo, que é o e, mas se eu souber a parte que é o resultado da função, eu não consigo calcular esse segredo de volta. Essa que é a ideia. Eh, eu não entendi muito bem por que eh porque você se duas coisas são chaves, uma é privada e outra é pública, por que que a gente muda a natureza delas? Tipo assim, pra gente ter essa para para a gente por que que a gente usa a a por que que a gente usa uma chave pública e uma chave privada de natureza diferente? São objetos diferentes essa é a pergunta. Se as duas são chaves? Se as duas vão ser chaves, porque eu o que eu tô procurando, na verdade é alguma coisa que tenha essa propriedade. Isso aqui é o que me interessa. É eu ter alguma certa função onde eu coloco uma chave privada. e eu calculo uma chave pública de tal forma que calcular a F é relativamente barato, mas calcular a inversa é muito caro computacionalmente. No final dos contos, é esse tipo de problema que a gente tá procurando. Mas então a função a função seria possível de de ser aplicado tanto num num escalar quanto num ponto? Sim. Por exemplo, o o a gente não vou mostrar aqui porque é é praticamente não usado em em criptomoedas em geral, mas esse F aqui ele pode ser multiplicação de dois números primos grandes. Você escolhe P e Q, dois primos, multiplica eles e aí isso gera um outro um outro número, um outro escalar. Uhum. Tá? E aí os aqueles dois primeiros ali eles vão um deles vai constituir sua chave privada e o e a multiplicação deles vai constituir uma chave pública, mas é a mesma natureza, tá vendo? Tipo, são tudo escalares, tá? E qual que é a propriedade que vai ser? Multiplicaram esses primos é relativamente barato. Relativamente barato. Mas fator, pegar um número e fatorar em fatores primos, números muito grandes, é muito caro. Computacionalmente é muito caro. Então ele também serve para fazer isso. Isso aí é o princípio do do esquema que chama de RSA, que foi inclusive o primeiro esquema prático de de chave público privada. esse esquema de cover elíptica que já é um pouco mais um pouquinho mais moderno. Tem outros esquemas, tem outros esquemas que eu não tô mostrando para vocês, mas eles meio que estão sendo começando a ser discutidos mais por conta de uma certa um certo medo de de computação quântica atacar isso aqui.

O G é um O G é um ponto. Ah, tá. É justamente por isso que a gente consegue encontrar o que a gente não poderia passar ele dividindo, já que pontos não podem ser divididos um por outro. Não existe uma noção de fazer P. Que que não tá escrevendo? Não existe uma noção de fazer P dividido por G. Exatamente. Por isso, eu não tenho essa. Eu não tenho ess isso bem definido. Exatamente. Por isso que a gente não conseguiria descobrir o Mas não é nem só por isso, porque olha só, porque não existe mesmo a própria, Não, não é não, não, calma. Não é só por isso, é porque na hora que eu tô, se eu olhar o gráfico desses pontos na curva, eu mostrei, tipo, o jeito que eu mostrei para vocês aqui na outra aula passada, é uma coisa meio bonitinha assim. Isso aqui é meio que te dá uma noção de ordem dos números, tipo, ah, esse aqui, depois esse, depois esse, depois esse. Como se pensasse assim, né? Mas isso no conjunto dos números reais. Nesse conjunto dos de um usando um campo finito, os pontos eles ficam tudo espalhados por aí. Tipo, é uma nuvem, hein? Completamente bagunçada de de pontos. Tem uma certa simetria ainda. Isso quando você multiplica por aí, no caso, hã, quando você Não, não, não. Isso é isso, isso é quando eu escolho o G, então imagina que o G é esse aqui, tá? Quando eu faço G + G, ele vem para em algum outro lugar aqui qualquer, sei lá, ele vem daqui para cá, ó. Aí quando eu faço 2G + G, que é o 3G, ser o próximo ponto da da sequência, ele sei lá, ele vem para cá, as operações e aí depois vem para cá e aí depois vem para cá. De tal forma que se eu te dar um ponto qualquer, você não consegue saber qual ele é na sequência, só olhando o ponto. No caso, fazer são muitos e muitos pontos. fazer essa operação e é fácil, só que fazer reversa dela. Exato. Porque é relativamente fácil você ir lá e fazer a multiplicação porque você não precisa. Aqui eu tô mostrando tipo como se fosse um caminho fazendo G + G + G + G + G. Se esse E for um número muito grande, que normalmente é, você vai demorar muito tempo fazendo isso, mas tem um algoritmo rápido para fazer isso, tá? um algoritmo rápido que para um número de 256 bits você faz aproximadamente 256 operações em vez de fazer 2 elevado 256 que seria o caminho normal, entende? O caminho andando ali procurando ele, que é o que você tem que fazer quando você não sabe qual é o Essa é a essa é a brincadeira, tá aí todo mundo bem? Tá bom. Não, tá bom. Na aula passada eu mostrei para vocês o um esquema que a gente chama de SDSA, mas eu quero comentar para vocês um outro esquema que chama shinor. Assinatura chinó. Onde é que ela tá? Minha anotação tá aqui.

Assinaturas

shinor. Shinor. Shinor. Tá. Esse esquema criptográfico aqui, ele foi inventado nos anos 80, se eu não me engano, no começo dos anos 80, só que ele foi patenteado e a patente dele só venceu em 2008. 2008 ainda é antes de do Bitcoin. Bitcoin, a rede mesmo foi lançada no começo de 2009, no final de 2008 é o white paper em outubro de 2008 e depois em janeiro 2009 é o foi quando a rede começou a operar mesmo, tá? Só qual qual a questão? Muito provavelmente o Satos começou a fazer essa coisa aqui uns um ano e meio, dois antes. Tem inclusive um relato dele no nas listas de e-mail lá falando que ele já tava trabalhando nisso aí há cerca de um ano e meio a dois quando ele lançou a coisa. Então ele quando ele começou, provavelmente começou a trabalhar no no sistema, na concepção da coisa e na implementação ali por volta 2006 ou 2007, como isso aqui era patenteado, não tava implementada em nenhuma biblioteca de criptografia na época. No Sat usava uma biblioteca chamada Open SSL, que é bastante usada ainda hoje, tá? é um das, sei lá, um dos backbond da internet, tipo usar OPSL assim, excelente qualidade, tá aí há muitos anos, tá? Não tava implementado em basicamente nenhuma biblioteca importante porque era patenteado, ninguém podia nem implementar. E aí foi usou o esquema do do Nich que era padronizado na época, que era com com assinaturas SDSA, tá? E aí só foi ser introduzida essa coisa aqui no no Bitcoin mesmo por volta de 2017 com quando teve um 17 ou 19, acho que foi 19 num upgrade chama Taperot, que aí eu vou explicar um pouco, talvez eu explique um pouco mais pra frente porque o taper tem a ver com aumentar a capacidade de criar contratos no Bitcoin de uma forma um pouco mais esperta. Eu consigo criar contratos mais sofisticados sem usar tanto espaço nas transações. A gente hoje a gente vai falar de transações e você v entender um pouco melhor o que que isso quer dizer, tá? Mas basicamente finor ele te dá vário, ele te permite fazer vários truques que são bem interessantes, tá? E aí todo mundo tá convergindo para esse tipo de para alguma variação do desse tipo de assinatura aqui, tá? Como é que funciona o processo de assinar?

Como é que o próximo? Lembra-te, para eu definir uma assinatura digital, preciso de três funções, né? Alguma coisa que gera as chaves, alguma coisa que assina e uma função que verifica a assinatura. Gerar chaves é igual ao outro. Você sorteia um número aleatório lá dentro daqueles escalares, escolhe aquilo, fala: "Ah, isso aqui é minha chave privada". Para calcular tua chave pública, você multiplica por esse ponto G, tem lá um ponto que vai ser sua PUBG key, sua chave pública, tá? Isso, esse processo é um pouco mais sofisticado do que eu tô falando aqui, porque isso é bem mais complicado de fazer na prática do que parece, tá? Sorte é o número aleatório é é difícil, é relativamente difícil. E eu vou mostrar para você hoje. Vai ficar bem claro também que é extremamente útil que a gente gere muitas chaves e gerencie muitas chaves, que a gente não reutilize essas chaves, essas chaves privadas, tá? Isso quer dizer que eu preciso gerar muitas chaves e gerenciar isso. Então, se eu ficar só sorteando números aleatórios, eu preciso ficar guardando esses números aleatórios comigo, tá? algum esquema que pode ser um pouco mais interessante é eu gerar um número aleatório uma vez e a partir dele eu consegui gerar muitas chaves de forma determinística, que é o que as wallets basicamente fazem hoje. Então elas você geram o numeratório uma vez só, ele vai servir com uma semente e aí a gente constrói algum tipo de processo que vai gerando outras chaves de tal forma que se uma dessas chaves for comprometida, você não compromete as outras, tá? Mas enfim, vamos lá. Que que eu faço aqui? Eu escolho, primeira coisa, eu escolho um que eu vou chamar de K. Esse nãoce, em princípio, é para ser um número aleatório. Em princípio, tá? O mais, ele não precisa ser um número aleatório. Ele o o importante é que ele seja um número que não seja fácil de prever qual é para quem tá olhando de fora, tá? E aí eu vou mostrar para vocês que esse nos um pode ser reutilizado. Se você reutilizar ele, você é a mesma coisa de mostrar sua chave privada e ele não pode ser publicado. Você publicar ele é a mesma coisa de publicar sua chave privada. Vou mostrar aqui agora para vocês, tá? Não é muito difícil de ver não. Aí dado esse eu calculo um ponto que vai ser K x G. Repare que é o a gente chama esse K, esse K de é uma chave privada, é um escalar, tá? É bem comum você usar, a gente usar nomenclatura de chave efêmera, uma chave privada efêmera e aquele R é uma chave pública efêmera que eu só vou usar uma vez na hora da construção da assinatura. Gerei um par de chaves efêmeras aqui. Aí eu vou calcular um escalar que é S, que eu vou chamar de S, que vai ser K menos o resto de da mensagem

combinado com aquele ponto de alguma forma. Aí variantes disso são variantes de como é que você combina a mensagem com esse ponto, tá? Os bytes vezes a minha chave privada. E aí, o que que é a minha assinatura? A minha assinatura é o par R grande S. Que que tá escrito depois do H? O H H de M, que é a mensagem que você tá assinando, com R, que é o a chave pública efêmera que você gerou ali ali atrás. Então você faz essa conta aí. Tu faz essa conta aí, tá? Repara uma coisa que isso aqui, ó, isso aqui parece, tá? parece com ax + b ou alguma coisa do tipo assim a x f de a mensagem mais um b. Tem uma constante aqui que eu tô chamando de make de b. Tem uma função onde entra a minha mensagem, tá? Então essa coisa aqui meio que tem uma cara de coisa meio linear, uma cara de função linear, tá? E de fato essa essa isso aqui vai gerar várias propriedades de linear que são interessantes. Por exemplo, posso somar duas assinaturas, vou mostrar aqui para vocês, agregar essas chaves, somar as chaves, ela continua sendo uma chave válida. Eu consigo somar assinaturas e continua sendo uma assinatura válida. Consigo fazer vários truques que são interessantes, tá? Mas antes disso, como é que eu verifico?

Como é que eu verifico isso aqui? Tá? Eu vou receber a assinatura, eu vou receber a mensagem e eu vou receber a chave pública da pessoa, o P grande. Aí eu calculo o seguinte,

eu não calculo, mas presta atenção. A chave, a assinatura foi construída assim, ó. K - H de M R X E. Supostamente o assinador usou essa conta aqui ou calculou isso aqui. Eu repara que do lado esquerdo, do lado direito são escalares. Eu posso multiplicar por um ponto, eu posso multiplicar por G dos dois lados. Aí eu fico com S x G é igual a.

A gente não exigiu, mas a coisa é é comutativa, distributiva na multiplicação, do jeito que a gente tá acostumado, tá? Então isso aqui fica K x g - h de m com r e x g. E aí repara uma coisa. Repara uma coisa. S x G. S x G. K x G é o R grande que veio na assinatura.

O R eu não tenho muito o que fazer, mas eu tenho como calcular esse R porque eu tenho o M e eu tenho o R que veio junto da assinatura. E E x G é a chave pública da pessoa que assinou, que eu recebi para poder verificar. Que eu recebi para poder verificar. Isso quer dizer que eu consegui isolar esse R que tá aí. Então cons fazer essa conta aqui, ó. R vai ser SG mais o resto de M R xes P. E aí a conta que o verificador vai fazer é ele calcula esse R veio na assinatura. Esse R veio na assinatura, o S veio na assinatura, o G, eu conheço a mensagem, eu sei a mensagem, eu tô tentando verificar para validar para uma mensagem específica. O R veio na assinatura, o P eu recebi para verificar, que é a pessoa que tá, esse P identifica uma alguma pessoa, tá? Isso quer dizer que eu consigo calcular o que tá do lado, o que tá do lado direito. Então, vou lá e faço essa conta, comparo com R. Se isso aqui for igual, a assinatura é válida. Se isso aí não for igual, a assinatura é inválida. Se eu mexer no M, o resto não vai bater. A conta não vai bater com a conta que foi aqui atrás. Se eu mexer no P, se eu mexer no P, se eu tentar manipular o P, não vai bater com a chave, a chave privada que foi usada aqui atrás, tá? E se eu tentar manipular o R, o R aqui não vai bater com o R que tá dentro do R. você não consegue isolar essa parada aqui. Eu não vou mostrar para vocês, mas tem prova de que você não consegue manipular essa parada. Todo mundo OK com isso? Basicamente essa a ideia, tá? Basicamente essa ideia, tá?

Aí, primeira coisa a se perceber, tá? Primeira coisa para perceber que que acontece se eu reutilizar o K,

se eu reutilizar o K, reutilizar o K quer dizer que eu vou calcular duas assinaturas para duas mensagens diferentes. Uma que eu vou chamar de S1, que vai ser K, menos o resto da mensagem 1 com o R grande. O K é o que gera o R, então ele vai ser o mesmo para as duas assinaturas. vezes a minha chave privada. E a segunda assinatura vai ser S2, o mesmo K, H de M2, R vai ser o mesmo R e o mesmo E o mesmo E. São dois, são é tudo escalares essa, essa conta aí, repar, é tudo escalares isso que tá aí do lado esquerdo do lado direito, tá? Então eu posso calcular S1 - S2, S1 - S2, S1 - S2

fica - H de M1 com R X Z E + H de M2 com R com E com E. Faz a álgebra, pá, pá, pá. arruma a parada toda, eu vou dar só o resultado direto. Não é muitos passos não, mas você consegue isolar o E. O E vai ser H de M2 com R menos o R de M1 com R. S1 - S2. Qual que é o problema? Qual que é o problema? Se eu sou verificador, eu recebi o S1 e o S2, que é são as parte das assinaturas. Eu recebi o R, então eu conheço o R porque veio junto das assinaturas. Eu conheço as mensagens que eu tô tentando validar. Eu conheço o M1, M2. Então eu eu sei qual resto for utilizado. Eu consigo vir e calcular tudo. Eu tenho todos os dados para calcular o E. Isso quer dizer que se eu usar o mesmo K duas vezes, é a mesma coisa de você ir lá e mostrar sua chave privada pra pessoa. A pessoa vai lá e essa continha aqui, vai lá e calcula tua chave privada. Ponto. Acabou. Acabou a brincadeira para você. Toda sua segurança tá baseada em só você saber o e. Você mostrou seu e sem querer, tá? tu mostrou teu e sem querer, por isso que não pode reutilizar oce. Por isso que várias bibliotecas aí, a boa parte do trabalho do da da do design da API delas é não deixar você controlar esse NC, porque você vai fazer besteira. Se você utilizar isso aqui, já era. A primeira vez que você utilizou, meio que você já era. Sua chave tá comprometida. É, só tá esperando alguém ir lá e calcular, tá? Só tá esperando alguém ir lá e calcular, tá? Pode parecer meio óbvio assim do tipo, ah, professor, vocês estão vendo que não é para reutilizar, tô mostrando para vocês na frente de vocês, não é para reutilizar, não é para reutilizar, mas empresas de bilhões de dólares vão lá e fazem isso sem querer de vez em quando. Tem um caso aí do PlayStation, PlayStation 3, eu acho, ou dois ou três, enfim, teve algum desses do alguns PlayStation aí que ele usava um esquema de assinaturas digitais para poder fazer a verificação se o se o disco que você tava colocando ali se ele era legítimo ou não. Aí tinha umas assinaturas que tinham que ser verificadas, só que eles reutilizavam o para fazer todas as assinaturas de todos os discos. Ou seja, na hora que alguém percebeu isso, foi lá, extraiu uma assinatura, foi lá, pegou outra assinatura. É um pou um pouco mais sofisticado que isso porque assinatura não tá no disco, tá? Dá um trabalho, um certo trabalhinho, tem que ir lá mexer no rádio e tal, mas alguém foi lá, pegou as percebeu não sei se nem se percebeu. Às vezes você testa algumas ali e e vê se cola, tá? pegou a assinatura, tal, não sei o quê, pá, e descobriu a chave e acabou a brincadeira de de todo o produto. E aí para sempre ele tá quebrado, quebrado assim essa segurança. Aí aí começou a ter disco pirata para sempre e acabou, não tem mais o que fazer, tá? Não tinha update de não tinha update que você pudesse fazer. Então tem que tomar cuidado, tá? Outra coisa, que acontece se eu revelar o K?

Se eu revelar o K, repar que a conta da assinatura é SK men o r de M com R x E. Se eu isolar o E aqui nessa nessa continha, fica K - S dividido por resto da mensagem com R. E se eu sou o verificador, eu tô vendo o R e o S que estão vindo na assinatura. Eu tô vendo a mensagem, eu sei o RH, você me mostrou o K e não devia ter me mostrado. Eu vou lá e calculo tua chave também. Então repare que esse K você não pode revelar esse K. Só que não revelar esse K implica que eu que tô olhando de fora também tem que ser difícil de eu chutar que K é esse. Tem que ser difícil de eu chutar esse K. E esse processo é meio é mais difícil, um pouco mais difícil do que parece na hora de de fazer uma implementação para escolher esse K, tá? Tudo isso para dizer, usem bibliotecas que já estão aí há muito tempo, que elas já tratam disso aqui. Elas geram esses cas de forma determinísticas, mas de forma que alguém não consegue chutar. Elas já evitam reutilizar esse K. Então elas guardam o estado e elas evitam, tipo, elas já gerenciam isso para vocês. Normalmente boas bibliotecas já fazem isso, tá? Em resumo, não tenta fazer a sua própria lib de cripto, tu vai fazer besteira. Tem vários outros fotguns aqui, várias outras formas de você dar tiro no pé. Dar tiro no pé. É muito fácil dar tiro no pé com essas contas aqui. E repare, tá? Por tudo isso aqui, eu não sou exatamente o criptógrafo, tá? Eu não sou exatamente criptógrafo, porque provavelmente o criptógrafo ele não se impressiona. Mas para mim isso daqui, ó, quando eu olho isso aqui, eu olho e falo assim: "Meu Deus!" Tipo, é uma é continha de somar e multiplicar. é continente de somar e multiplicar. E essa parada é meio que, entre aspas, impossível de resolver se eu não souber uma informação. E é continha de multiplicar e somar.

Eu me assusto com essa parada até hoje.

E isso aqui não é só para Bitcoin, Etheréums, criptos, moedas em geral. Isso aqui acontece toda vez você entra num site, tem aquele cadeadinho que tá rodando HTPS, tá rodando TLS, tem um esquema de assinaturas digitais lá. Parte do protocolo envolve assinaturas para autenticação dessas coisas. Isso que tá acontecendo lá também para proteger as essas autenticações aí do servidor e tal, tá? Isso que também tá acontecendo no TLS. As mensagens são cifradas. Eu não tô mostrando para vocês como é que faz as cifragem, que é baralhar, tipo, cifrar, né? esconder os as informações de tal forma que alguém consegue decifrar depois, mas também é baseado em alguma coisa assim quando a gente somar e multiplicar. E tudo é baseado em não mostrar a chave uma uma um número. Se eu souber o número, acabou tudo. Se eu não souber o número, tudo funciona. Para mim, isso é uma coisa bem assustadora até hoje. Bem assustadora, mas é o que é e funciona, tá? Funciona saber que não sou não. Isso aí é para mim é bem assustador. Bem assustador. Todo mundo OK? Pergunta. Não pode repetir o K e também não pode ser dependente do K anterior, né? Não pode ser um múltiplo, por exemplo.

[Música] Seu K não pode ser um múltiplo de um K já usou. Não, ele pode, ele pode, ele pode, desde que você nunca mostre esses casos e que você não reutilize. Esses casos, esse, esses casos na prática, eles são calculados de forma determinística. Eles não são números aleatórios, eles são por quê? Porque a gente tá tentando evitar de você reutilizar. Então, ele tem alguma conta que envolve as mensagens que você tá assinando, algum estado passado, entendeu? Ele ele ele é eles são hoje el na prática eles são gerados de forma determinou deixar para vocês verem detalhe disso num curso de cripto num curso de cripto de verdade que vai tratar disso. Como é como gera esses casos aqui? Para mim eles eles magicamente existem lá. É uma forma de fazer. Todo mundo ok? Todo mundo OK? Você falou que não é para mostrar o K mais se tu não mostrar como é que a outra pessoa vai verificar. A outra pessoa verifica assim, ó. Ela faz essa conta aqui.

Aí o que que você tá de fato mostrando? Você tá mostrando o RS. Lembra que o R depende do K? Mas você não pode mostrar o K. Você pode mostrar o R, mas não pode mostrar o K. Por quê? O R é K x G, que é a mesma proteção de eu posso te mostrar um ponto, mas eu não te mostro. o escalar que gerou aquele ponto. E isso é isso que garante segurança. Por quê? Se eu sei o K, eu calculo o R, mas se eu sei o R, eu não consigo calcular o K de volta. Tudo tá baseado nessa nessa nessa dificuldade aqui de você dado R, dado G, calcular o K de volta, calcular o escalar que gerou aquilo. E aí é onde entra o onde o computador quântico quebra, tira um pouco da graça da da brincadeira toda, porque o computador quântico ele existe um algoritmo conhecido que acelera essa volta aqui, ó.

Acelera essa volta. é um pouco, eu não vou explicar aqui para vocês como é que é porque é relativamente sofisticado, preciso falar, explicar muita coisa como é que funciona computação quântica, enfim, tá? Mas existe um algoritmo conhecido que que acelera essa volta. Eu consigo fazer em bem menos etapas do que eu normalmente faria, do que eu do que fosse só testando combinações aí. Todo mundo bem, tá? Uma das coisas que uma das coisas que a gente vai fazer e aí vai ter duas formas diferentes de fazer. Eu vou mostrar uma uma agora com vocês que é uma forma um pouco mais moderna, mas como não tinha esse mecanismo aqui no Bitcoin, a gente teve que dar um jeito de fazer o que eu vou explicar agora para vocês de alguma outra forma, que é uma forma menos elegante, tá? que é a ideia de eu ter algum esquema de multiassinatura. Por exemplo, imagina que eu tenho o, sei lá, imagina que eu tenho um um carro e, sei lá, a propriedade dele, eu vou transferir pro Rômulo. É Rômulo, vou transferir pro Rômulo. E isso envolve eu eu gerar uma assinatura digital, gerar uma assinatura digital. Se o carro é só meu, só eu vou lá e assino e agora é seu. Vamos pensar alguma coisa assim que eu monto lá um esquema, tá? que é basicamente o que acontece hoje. Você vai no Detran, assina um, literalmente você assina um papel e aí transferir o carro de um lugar para outro, de uma pessoa para outra, certo? E aí legalmente isso é binding. Só que pode ser, pode ser, não, tem coisas que são de mais de uma pessoa. Por exemplo, às vezes você é casado e o teu apartamento é teu e da tua esposa, você comprar juntos, certo? Então, para tu vender aquela parada, seria interessante que tivesse algum esquema que você requer a assinatura das duas pessoas. Se eu só tiver uma delas, não, não faz negócio. Eu tenho que ter as duas assinaturas, tá? Isso no mundo físico, a gente vai lá e duas pessoas assinam um papel e pronto, as duas assinaturas, tá? Aqui no mundo no mundo digital, a gente quer tentar replicar esse tipo de coisa, a gente quer tentar implementar esse tipo de coisa também, tá? eu ter algum tipo de assinatura que para ser válida eu preciso que mais de uma pessoa assine. A gente chama isso de multisig multiignature, tá? E aí isso tem inúmeras aplicações aqui em cripto. Inúmeras aplicações. Inúmeras aplicações, tá? E assim, vocês não têm a menor ideia, isso tem inúmeras aplicações, das coisas mais mirabolante que vocês podem imaginar, tá? E aí eu vou explicar esse pouco para vocês, porque vocês vão ver, é o que eu vou mostrar aqui hoje um pouco mais paraa frente, que boa parte do que a gente vai estar fazendo é descrevendo contratos e esses contratos são programas de computador e eles vão envolver um certo quórum de assinaturas em geral. eu falar assim: "Ah, tal coisa só pode acontecer se tiver assinatura do fulano, do fulano, do ciclano ou se tiver duas dessas três pessoas aqui, duas combinações dessas três pessoas ou uma qualquer dessas três pessoas aqui ou variações disso, tá? Então, esquema de multiassinatura.

O esse esse esquema esquema criptográfico chinó, ele permite a gente fazer um scam bem elegante de de multiassinatura que é o seguinte. Imagina que eu tenho hélice e o Bob, tá? A hélice tem um uma chave pública A, que é azinho vezes G, e o Bob tem uma chave pública bezão, que é bezinhoz G. Bezinho x G. Reparem que A e B são pontos. Eu posso somar os pontos, então posso criar um ponto D, que é uma outra chave pública, como sendo A + B. Repare que qualquer um dos dois, tanto eles quanto Bob, pode calcular isso, porque eles, em princípio sabe a chave um dos outros, tá? Só que se eu substituir A grande e B grande, vai ficar e já fazer a arrumação das coisas, tá? Isso aqui vai ficar A pequeno + B pequeno xes G. Isso quer dizer que eles conseguem combinar. Olha só o negócio. O A pequeno a hélice não vai mostrar pro Bob e o B pequeno Bob não vai mostrar para eles. É a parte privada da coisa. Só que eles sem mostrar o a chave privada deles conseguem calcular uma chave pública que só eles juntos conseguem calcular qual é a chave privada.

Vou repetir. Aélice e o Bob sem mostrar a chave privada de cada um. Eles conseguem calcular uma chave pública,

cuja chave privada eles precisam se juntar e e criar essa chave privada, que eles não vão mostrar o A e B para ninguém. Inclusive, isso é uma a dificuldade desse protocolo aqui que eu vou mostrar para vocês é eles conseguirem fazer essa soma sem mostrar um pro outro qual é a chave do outro. Mostrar o resultado, né? Hã, pode. Pode nem mostrar o resultado também. Não posso nem mostrar o resultado. Repare, tá? Essa é a dificuldade desse protocolo. Diga, filho. Tudo bom? Tudo. Eh, você aula. Pode ser depois da aula. É, pode ser. Ou agora na aula. Não, depois da aula. Então passa aí 11:40 que eu vou estar aqui. 11:40.

A a a dificuldade de implementar esse esquema aqui na prática é esse A + B aí, mas tem esquemas, por exemplo, tem um esquema hoje, chama Musig e aí tem duas versões que é um protocolo, tem vários rounds assim, tipo, a gente vai trocando umas informações pra gente poder estabelecer uma chave comum entre nós aqui, uma chave nesse esquema aqui, tá? Ah, eu não vou entrar em detalhe como é que ele funciona, mas vocês podem ir lá e procurar Musig ou Musig 2, tá? Então, beleza. Eu posso vir aqui bolar um protocolo em dois em duas etapas, tá? Na primeira etapa, eu estabeleço um certo segredo comum que eu vou chamar de K, que eu vou chamar de K, que é aquelece pra gente criar uma assinatura, eu preciso de um tá e preciso que a hélice bob gerem o mesmo tá? Esse K é relativamente ele é um pouco mais fácil de lidar porque esse K aí eu faço um DIF Helman tradicional e ou alguma variação de ifelman estabelece um segredo comum, tá? E aí eu vou definir o R grande lá da assinatura como seno 2K x g. Uma pequena diferença aí. Então o fator de 2

só pra conta fica bonito, tá? Mas eu vou lá e calculo esse R dessa dessa forma. No segundo round, o que que eu faço? No segundo round, a hélice pode ir lá e criar a assinatura, que vai ser K, que agora ela sabe, menos o resto da mensagem com o R grande que ela gerou ali atrás vezes A pequeno, que é o que ela sabe. Ela não sabe o B pequeno. O A e o B não fazem são A direto. São o A e B. Qual A e B? O A e B grande ou A e B pequeno? O AB grande é só somar direto. O AIB pequeno que não é tão simples. Mas por que a gente fazção do A pequeno não fazente? Porque eu posso ir lá e fazer. A gente vai ficar um pouco mais claro quando você vê como é que é a transação de Bitcoin que eu que eu vou mostrar na sequência, porque na transação de Bitcoin a gente vai mostrar primeiro a PUB e lá no futuro eu vou mostrar o eu vou criar uma assinatura. O momento é diferente no tempo, entendeu? Aqui, aqui tá tudo muito meio mágico assim e tal, não sei o quê. Eu preciso olhar e falar assim: "Tá, mas como é que eu vou usar isso? Eu vou mostrar para vocês formas de gente usar isso de verdade, mas eu preciso estabelecer um pouco de um pouco de o que que é possível fazer nas contas, na na no mundinho na matemática, para depois a gente montar um protocolo de pagamentos mesmo. Tudo bem? Tá. Aéis foi lá e e criou uma assinatura. Ela criou uma assinatura, tá? O Bob foi lá e assinou a mesma mensagem com a chave dele. Então ele criou K, H, Mr. Eles estão assinando a mesma mensagem, tá? B. E aí, repare que eu posso somar o A com B. Depois de assinado, qualquer um dos dois pode ir lá e assinar, pode somar essas, fazer essa soma, tá? Porque ele vai mandar o SA para um lado. Eles só trocam os S. Eles não precisam mostrar o A e o B. Mas olha só, se eu somar as duas coisas, SA + SB e arrumar isso aí, tá? Isso aqui vai ficar 2K men o R M com R A + B, que é exatamente o que a gente faria se eu tivesse assinando com a chave combinada dos dois.

S minúsculos, hã, esse S minúsculos. Esses S são minúsculos. Eles são escalares. O que que isso aqui fala para mim? Tá, na hora de implementar é um pouquinho mais sofisticado, assim, tem algumas dificuldades na hora de implementar, tá? Eu tenho que fazer isso numa ordem certa, enfim, tá? Mas enfim, é possível. É possível. O que que isso aqui tá falando para mim? Ele tá falando o seguinte: duas pessoas podem gerar assinaturas separadas para alguma coisa, para uma mensagem.

E quando eu somar a assinatura dos dois, essa assinatura também é válida.

Repare, eles fazem essa conta separado. A hélice vai gerar a assinatura que é S RSA e o Bob vai gerar uma assinatura que é RSB.

Eles publicam isso aí. Isso é assinatura. Qualquer um, não precisa nem ser eles. Qualquer um pode vir aqui e calcular. SA + SB. Só pegar as duas assinaturas, separar aquele pedaço ali, SA + SB, criar uma outra assinatura que é R SA + SB. E essa assinatura, essa terceira assinatura, é válida para a chave combinada dos dois. Ela é válida para essa chave aqui, ó.

que como que a gente usa isso, tá? Isso aqui em geral, em geral não, a gente vai usar para E aí eu vou mostrar isso, como é que funciona, um pouco mais de detalhe, vai ficar um pouco mais claro já, já, tá? Mas o que que a gente vai fazer? A gente vai lá na hora que a gente tiver tratando do dinheiro, a gente vai travar fundos e vai falar assim: "Só pode gastar alguma coisa quem conseguir gerar uma assinatura válida para essa chave aqui, ó, D."

Na prática, eu vou estar falando quem é o dono do desse dinheiro. É quem é o cara que sabe qual é o D? Ô, é o cara que sabe gerar uma assinatura pro D, que é o ponto dos dois. Só que repare que aquele D ninguém sabe quem achar privada, porque ela é A + B. Não, uma parte sabe o A, a outra parte sabe o B. E elas nunca revelam a os dois para poder fazer essa soma do A + B. Como que elas podem, sem mostrar uma coisa, um a chave um do outro, a chave privada, como é que elas ainda assim conseguem assinar? Elas vêm aqui, assinam separadamente e a gente soma as assinaturas. E essa assinatura é válida para esse ponto aqui, ó, para essa chave.

Então o R seria igual a D. Hã? Então o R seria igual a D. Não, o R é outra coisa. O R, o R é oce da assinatura. O D é um é o é a Pub key que valida a assinatura. Cuidado com isso. Tudo bem? Pra gente aqui os os pontos em geral vão ser os nossos identificadores no sistema, vão ser a nossa identidade no sistema. E a gente prova que a gente é que a gente é quem a gente é criando assinatura, porque aí eu provo que eu sou o dono de uma chave privada que gerou aquela chave pública. Todo mundo bem? Vocês vão ver qual a vantagem desse tipo de sistema aqui, tá? Qual a vantagem desse tipo de sistema? Primeiro que é muito mais compacto, porque em vez de deu, eu vou mostrar uma uma um contrato com mais de umas com que precise mais de uma assinatura. E aí vocês vão ver que os o tamanho mesmo da dos bytes que eu preciso colocar, a quantidade de bytes que eu preciso colocar é maior, porque se eu preciso falar assim: "Ah, precisa de duas assinaturas, uma para essa chave aqui, outra para essa chave pública aqui, eu preciso botar duas chaves públicas lá". Isso já é bem maior do que eu botar uma chave pública só, tá? Mas tem uma segunda, isso é uma vantagem já, tá? Mas tem uma segunda vantagem que é bem mais importante aqui, que é o seguinte. Quem tá vendo isso aqui de fora, quem não é nem a hélice, nem o Bob, não consegue saber que o D, na verdade é uma chave que que é do tem dois donos. É indistinguível de qualquer outra chave pública lá no sistema, é igual a qualquer uma outra chave que tá lá. Então não dá para você saber quem é o dono, quantas pessoas são dono disso aqui, se é uma, duas, 3, 4, 5. Porque isso aqui é escala ainda, né? Posso fazer para aumentar a escala disso aqui, posso botar quantas pessoas? N pessoas, tá? Quem tá olhando lá na na as essas essas contratos aí que a gente vai fazer, não consegue saber que isso aqui é uma multic e aí isso é melhor pra sua privacidade, porque aí você pode estar assinando contrato com alguém que tem, por exemplo, uma má reputação e ninguém fica sabendo. Uma má reputação por algum motivo, tá? Não sei, não tô fazendo nenhum ju de valor, mas ou às vezes você tá, por exemplo, às vezes você simplesmente não quer mostrar, ah, eu tô fazendo uma doação para uma ONG num país onde essa ONG é uma uma coisa de alguma coisa de ativismo político e essa ONG é perseguida pelo governo. Aí eu quero fazer uma doação, aí eu posso usar alguma coisa parecida com isso para entre aspas esconder que eu tô doando para aquela on específica para eu não ser perseguido também, por exemplo. Isso por isso que é privacidade importante. Eh, essa chave, se eu sei uma das partes dela, uma extrair a outra. Qual chave? A pública. A pública. Porque eu a verificar isso eu tenho que ter uma chave pública do D, né? Tem que ter a chave pública do D. Aí a gente vai publicar a chave pública do D, mas a gente não, em princípio, a gente nunca vai dizer que esse D é a soma do A com B. Aí você só olhando o D, você lá na lá na bloquinha nas transações, vai aparecer lá o D de alguma forma. Aparece esse D. Só que esse D é um ponto como qualquer outro ponto na curva a chave pública. Você não consegue saber se esse D é a soma de outros dois pontos que alguém foi lá e combinou e tá combinando fazer uma mos dessa. Você não sabe se é uma uma chave normal, individual. É indistinguível. Se por acaso souber isso, se você souber aí você aí é que tipo assim, se você começar a revelar informação sobre o que você faz ali no sistema, aí pode ser que alguém consiga descobrir essas coisas. Bem, outra coisa que é interessante, que eu não vou mostrar aqui para vocês, mas que envolve alguma coisa semelhante a isso aqui, é eu fazer uma chave que para você que eu eu crio uma certa chave e a gente vai ver que os endereços são direcionados a essas os pagamentos são direcionados a essas chaves públicas.

E o que que eu posso fazer? Eu posso pegar e criar uma chave pública que na hora que você que alguma pessoa vier fazer um pagamento para mim, ela vai pegar essa chave pública e combinar com a chave privada dela e vai criar uma outra chave pública e vai pagar para essa uma outra chave pública que eu que tô recebendo não sei qual é porque eu não sei se é seu segredo, mas que eu consigo escanear a blockchain, escanear as transações e descobrir que aquela transação é para mim. e descobrir que é minha. E não só isso, calcular a chave privada que eu preciso para poder gastar parada, sem saber a sua chave privada. Um esquema meio que de misturar essas chaves públicas e as privadas, que é uma coisa parecida com dif Helman. Aí não vou explicar aqui no detalhe porque você precisaria, sei lá, mais uma meia hora para explicar como é que funciona defelh aí. de ferrar uma forma de nó de duas pessoas estabelecerem um segredo em comum sem revelar seus segredos, seus segredos individuais, tá? A gente consegue fazer um esquema parecido, misturando chaves aqui nesse tipo de esquema criptográfico. Tem várias coisas interessantes que a gente pode fazer, vários truques, tá? Vários truques. Outro truque que vocês vão acabar vendo por aí, tá? É assinatura é RS. E aí, em vez de eu te mostrar o RS, eu vou fazer um tweak nesse R aqui. Eu vou mexer nesse R, só que eu vou mexer de nesse R de tal forma que ali eu tô escondendo uma outra assinatura, R linha, S linha.

Aí você tá vendo uma, eu por exemplo te mostro, te mostro uma parte de uma assinatura. Só tô te mostrando o S. Mas quando você vê isso aí, você consegue calcular uma outra assinatura para fazer alguma outra coisa no sistema. E quando você usa essa uma outra assinatura, eu consigo ir lá e calcular o resto do do da primeira assinatura ou você calcular o resto da primeira assinatura. E aí a gente fazer um esquema de revelar a assinatura por partes e você precisa fazer alguma coisa antes de ver a assinatura toda. Por exemplo, para que que serve isso? Por exemplo, imagina que eu tô fazendo câmbio com você. Eu tenho, sei lá, eu eu tive um aluno que tava trabalhando exatamente com isso aqui para fazer um esquema com ICh, que é imagina que eu tenho e cash de uma de um banco e você tem cash do outro banco. A gente viu que o pagamento de um pro outro não precisa pagar, não precisa passar pelo banco, eu posso fazer direto aqui. Só que para isso você precisa ter fundo, você precisa ser cliente lá do banco e eu preciso ser cliente do seu banco. Aí imagina que a gente não é, não seja, tá? O que a gente bolou foi um esquema de assinatura, onde eu consigo te dar uma o meu token, te eu te faço pagamento, só que você não consegue ir lá na minha mente gastar agora e pegar o dinheiro. Antes de você fazer de antes de você conseguir ser capaz, você precisa ir lá e me dar uma outra assinatura. E aí tem um esquema parecido com isso que eu tô falando aqui agora, misturado aqui duas assinaturas. Você me dá aí eu vou lá na sua e eu gasto o seu pego o dinheiro da sua parte. Só que na hora que eu faço isso, eu preciso mostrar alguma informação que você vê, termina de calcular a chave que você precisar para ir lá na minha e gastar. E aí você vai lá entre aspas, ao mesmo tempo e tcuc pega o pega o fundo, pega o seu fundo, tá? Isso a gente chama de troca atômica. Tipo, eu tô trocando uma coisa com você e em nenhum momento você tem informação que você sozinho consegue lá e pegar a sua parte do do da troca e eu ficar vendo navios e vice-versa, tá? Tudo porque também truques que a gente consegue fazer. mexendo nesses RS aqui. É bem interessante as coisas que a gente consegue fazer. Todo mundo OK com isso? Todo mundo OK? Então tá bom. Independente de qual esquema a gente tem, guarda a a coisa mais importante. Independente do esquema, de qual é o esquema, eu tenho alguma coisa aqui. Eu tenho três funções. Generate keys, que gera chaves para mim, que a gente viu aqui. Eu tenho uma função que assina e eu tenho uma função que verifica. Independente do qual esquema isso aqui a gente vai ter na mão o tempo todo para construir o dinheiro agora, que é o que eu vou fazer na sequência, tá? Ainda lembra de outra coisa, a gente tem uma função que eu vou chamar de hash. Vou chamar aqui de que calcula um hash H ou digest

a partir de uma pré-imagem. E aí, lembra? A ideia é que a propriedade que isso aqui tem é que se eu te mostrar o H, você não consegue calcular o X e você não consegue encontrar dois X diferentes que dão o mesmo H lá no final. São as duas propriedades mais importantes, tudo bem? Essas vão ser as peças básicas pra gente construir alguma coisa. Agora todo mundo OK? Vou parar a gravação para poder só cortar o vídeo num lugar decente, tá? Yeah.