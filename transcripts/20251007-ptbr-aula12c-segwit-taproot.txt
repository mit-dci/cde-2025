Vamos voltar a falar, aliás, vamos continuar falando de programabilidade, tá? Então, deixa eu fazer um recap aqui pra gente andar pra frente, fazer um recap, um uma recapitulação aqui, tá? Que que a gente tá vendo? Eu tenho em algum momento transação que tem certas entradas. Entrada é dinheiro que alguém tá gastando. Tem certas saídas e a saída é dinheiro que alguém tá recebendo. E o que que a gente viu que é o que do que a gente tá falando o tempo todo, que como que eu especifico quem é o dono do dinheiro, quem é que tá recebendo aquele dinheiro, tá? É por meio de um programa de computador escrito numa linguagem que a gente chama de script, tá? E eu tô chamando, na verdade, eu quero chamar aqui de contrato. Tem um contrato que é uma função de computador, uma função que estabelece certas condições para autorizar um certo gasto. E o que que significa isso? Significa que uma segunda transação num segundo momento, ela pode querer gastar aquela uma saída, aquela uma saída. E aí para isso, ela tem uma uma das entradas, um dos campos dessa entrada da transação. Tem um outro programa de computador que quem tá escrevendo transação precisa fornecer, tá? E esse programa de computador, em princípio, produz os dados que vão ser validados pelo contrato. Eu tô escrevendo que essa cor meio roxinha aqui, tá visível para vocês? Hã, tá. Tá bom. Em princípio a ideia é essa, tá? Obviamente, mas obviamente o são programas de computadores, podem fazer tipo programador, programa, né? programador expressa ideias, tá? A ideia que você vai expressar ideias, tudo bem? Essa é o é o princípio básico, tá? E quando que esses programas são de fato executados? Eles são executados na esse programa que tá aqui, que eu vou chamar de, sei lá, C, ele é executado quando a transação um for estiver sendo validada na rede e não quando a transação zero estiver sendo validada na rede. Então, muita atenção com a com essa história de quando que essa coisa acontece. o quando as coisas acontecem vai importar, porque repare, eu posso colocar o contrato lá e isso fica anos. Ou eu posso eu mesmo já criar uma transação com contrato e já na de ato contínuo criar uma segunda transação já gastando ela e já para pagar as duas coisas juntas, inclusive. Nada me impede de fazer isso, tá? Mas qual seria o benefício? o benefício disso aí a gente vê quando a gente vai falando de outros protocolos, porque eu posso usar isso para expressar expressar outras ideias, tá? E aí repara uma coisa, ó. Qual que vai ser a ideia, a ideia básica de a gente ter camadas, né? Se fala dessa coisa de, ah, Bitcoin vai escalar em camadas, em camadas, tá? O que a gente tá vendo aqui é a camada base do dos protocolos, tá? Camada base é o protocolo básico, tem as transações, tem os blocos, prova de trabalho, essa coisa toda que a gente tá vendo aqui, tá? Só que como é que funciona essa coisa de de camadas? É muito baseado na ideia de redes, redes de computadores que também são protocolos em camadas, tá? Então, por exemplo, por exemplo, se eu pegar aqui um um certo protocolo, que é o protocolo IP, ele me permite transmitir dados e ele me dá algumas garantias de funcionamento, tá? O IP ele me dá a garantia de tentar encontrar rotas entre duas duas máquinas, tá? Dá no que a gente chama de melhor esforço, né? Então, o que que como é que é o a ideia do IP? Quando eu quero transmitir algum dado lá nesse protocolo, eu tenho um monta o que a gente vai chamar de pacote. Tenho um cabeçalho. I, professor. Oi. É IP ou IP? IP. TCP. IP. Internet protocol. O TCP é outra coisa, não é? É IP de TC, que é o que eu ia falar agora do do que eu vou falar de chegar no TCP. Mas a gente vai botar um cabeçalho e eu tenho um payload.

Eu tenho um cabeçalho, eu tenho um payload, tá? No IP, nesse cabeçalho aqui, vai coisas, por exemplo, como o endereço IP, que é quem é o destinatário dessa coisa, tá? Mas não tem informação de rota. Como que eu chego nesse nessa nessa nessa nessa nesse endereço aqui? Como que eu chego nesse local aí? O que que o teu celular, por exemplo, tá fazendo? Você tá lá mandando mensagenha no WhatsApp, tá? Que que ele vai fazer? Ele vai, ele, o teu telefone, ele tá conectado pramente só num ponto, ele só tem uma conexão com a uma estação rádiobase lá dele que tem um IP também. E aí ele manda aquele todos os pacotes para lá. E aí lá ele tá conectado no, por exemplo, provavelmente no roteador que tem várias rotas lá que ele consegue mandar para vários lugares. Ele fala: "Hum, tá, então vou mandar para essa rota aqui porque eu acho que é para lá que tem que ir". E aí isso vai indo, cada roteador vai olhando e falando: "Hum, acho que eu tenho que mandar para cá". Não, tem que mandar para lá, tá? E aí os caminhos eles vão meio que se descobrindo, meio que se descobrindo. Claro que um monte de coisa pode dar errado nesse caminho. Pode ser que você fique um tempão nesse processo aí você não encontre a máquina que você tá procurando. Pode, você não sabe a rota, você não sabe como chegar lá, tá beleza? O que que o TCP faz? Que que é o TCP faz, tá? O TCP ele vai ser um protocolo que organiza esses pacotes, que organiza esses pacotes, que é pra gente ter uma certa garantia de ordem de chegada, de reliability, de que se alguma coisa não chegar no meio do caminho, eu consigo detectar e eu consigo retransmitir, tá? Eu quero ter essa essas garantias. Como que é como que a gente faz, tipo assim, não vou entrar no detalhe como assim os detalhes, os bits, os bytes, tal, não sei o quê, mas qual que é a ideia básica? A ideia básica é aqui dentro do payload do do IP, eu vou colocar alguma outra coisa que não é só dados. Aqui vai entrar no TCP, ele chama de frames, mas é a mesma coisa. Eu tenho um uma estrutura que tem um cabeçalho e tem um payload aqui do TCP. aqui do IP. E essas coisas meio que elas são meio que um ecne. Nesse caso aqui particular desses dois protocolos, tá? Eles são tipo eles são muito feitos para funcionar um com o outro, mas o TCP não precisa do IP para funcionar, é porque assim é é a implementação mais comum. E o IP não tem nada a ver com TCP. Você não precisa rodar TCP para usar o IP, você pode usar outros protocolos. Inclusive, é bastante comum usar o DP, que é um protocolo de datagramas, que não tem essa história de continuação de um fluxo, tá? Enfim, também é construído da mesma forma. Aqui, ó, tem um um cabeçalhozinho lá dentro do payload do IP, tem um cabeçalhozinho, um payload e aí dados, tá? Essa é a mesma coisa que a gente vai querer fazer aqui, ó, para construir um outro protocolo que usa esse como um protocolo base. Que que significa isso? Significa que eu vou estar mandando transações para lá e para cá. Nesse outro protocolo, assim como lá no IP, no TCP IP, nesse conjunto, eu tô mandando um monte de pacotinho IP. Os os roteadores, quem tá roteando firew, essas coisas, eles não precisam saber, eles não precisam conhecer o TCP. Se eles conhecerem o TCP, eles conseguem fazer mais coisas. Ele consegue fazer, por exemplo, Fireall, eles sabem de TCP, eles conseguem fazer coisas mais espertas. Por isso que aqui na Por isso que aqui você consegue fechar um monte de coisa na rede, por exemplo, aqui da da universidade que vocês estão agora, tem um monte de serviço que você entra lá e não consegue usar, tá? Por quê? Porque o Firewel que tá gerenciando, que tá no meio do caminho, ele sabe, ele sabe olhar esses pacotes e ele sabe que isso aqui é TCP, ele sabe que olhar que é um, tipo, aquilo ali tem a ver com uma sessão, ele sabe decodificar tudo aquilo ali, tá? Ele sabe que é você que tá tentando fazer alguma coisa. Ele sabe a direção, se os se é uma sessão que tá de dentro para fora. E aí normalmente ele permite isso, mas ele não permite começar de fora para dentro, esse tipo de coisa. Para você não poder rodar um servidor web aqui, por exemplo, tá? Esse tipo de coisa, tá? Pergunta. E você tem que enganar, tem que enganar, né? Mas onde tava esse esse patatinho? Hum. Onde tava esse paatinho? Onde tava editável? Tipo assim, quanto eu consigo o quão editável são esses pacotinhos. É, então eles são como aleável, como aleável esse pacotinho aqui dentro do payload. Você pode botar basicamente o que você quiser, basicamente o que você quiser, tá? Só que tem várias camadas de abstração meio que já construídas hoje para pra gente ir facilitando a nossa vida. E porque cada camada desse protocolo tá tentando resolver um problema específico, que é a mesma coisa que vai acontecer aqui também. a gente vai botar mais camadas para resolver problemas mais específicos, tá? O é uma camada assim uma camada, um uma pilha mais ou menos comum, tá? Ethernet,

que é o padrão que inclui inclusive padronização física de cabo e de tensões e tal nos cabos, mas também tem uma parte lógica nele. Hã, modelo é modelo não encaixa muito bem nisso aqui, não. O a internet não encaixa muito bem no modelo OS. É, são só quatro camadas, né? São séri. É. É. Entendeu? Porque, enfim, esses protocolos estão resolvendo mais de um problema da de cada camada ali ao mesmo tempo. Mas enfim, mas por exemplo aqui internet que resolve o problema de eu conseguir fazer você ver bits, sair bit daqui e chegar ali. Aí o IP, o que que tá resolvendo? O IP tá resolvendo o problema de tá bom, vamos imaginar que eu consigo que você, mas eu consigo que todos vocês vejam bits. Como que você decide se aquele bit é para você ou não? O IP tá resolvendo esse problema de endereçamento. O TCP tá resolvendo um outro problema. Repara agora eu já sei que fazer bits chegar em você e você sabe decidir se aqueles bits são para você. O que que o TCP tá fazendo? O TCP tá resolvendo problema de de confiabilidade aqui na nessas redes aqui, que é se falhar comunicação, o TCP aí tem um monte de regras aqui. Tem uma máquina de estado bem complicada, tem que rodar. Ele cuida de fazer handshaking, ele cuida de fechar a conexão, ele cuida de eh retransmitir pacote se o pacote demorar demais ou se chegar fora de ordem, ele cuida de reordenar os pacotes para você que tá vendo o TCP, a pilha já do TCP, você vê um fluxo como se fosse um arquivo no teu computador, entendeu? E aí vem a camada de aplicação aqui, né? Que aí pode ser qualquer coisa, um exemplo dessa qualquer coisa. Esse protocolo que a gente tá vendo aqui agora, esse protocolo que a gente tá vendo aqui agora, que é o protocolo Bitcoin, que é um monte de mensagens. Aí vai ter os dados, como é que tem que ser realizar os cabeçários, a coisa toda. Mas então, toda a rede do Bitcoin roda nesses dois. Toda a rede do Bitcoin roda aqui no TCP. PCP não, toda a rede de Bitcoin não, porque esses, como eu tô dizendo, esses protocolos eles eles normal eles são eles são meio que independentes uns dos outros. Eles são meio que independentes uns dos outros. Eles resolvem problemas específicos, eles meio que prestam serviços uns aos outros, tá? Eh, então, por exemplo, aqui no caso da do Bitcoin, ele é as mensagens eles são muito específicas e e não tá atrelado a nenhum mecanismo de transporte. Mecanismo de transporte é como é que essa pilha que tá aqui embaixo na minha de transporte é independente disso. Então, tem nodes que vão usar outros mecânicos de transporte, tipo TOR, tipo I2P, outros protocolos que resolvem esse problema de transporte com outras características. store, por exemplo, ele é mais ligado à privacidade, é você não conseguir rastrear esses caminhos aqui, entendeu? É, é por aí, tá? Mas quando a gente for falar de fazer, ah, vamos fazer uma layer dois no Bitcoin. O que que a gente tá falando? O que a gente tá falando é fazer a mesma coisa. Eu quero embutir aqui, ó, no payload alguma coisa que um outro cliente consegue entender e fazer mais coisas a partir disso. Onde que eu embuto dados aqui, ó, nas transações? Porque os dados que eu vou ficar transmitindo aqui é transações. Nesses scripts, ó, eu vou colocar os dados ou no contrato ou no ou no data. E é aqui que eu preciso expressar as regras desses outros protocolos. Mas no fim do dia é transação de Bitcoin para cá, transação de Bitcoin para lá. Essa é a coisa mais importante de se perceber. Mesma coisa pro Etheréum, mesma coisa pro para todas as blockchain que você pensar aí. Todas elas exatamente tipo desse ponto de vista conceitual, tudo exatamente a mesma coisa. O que que vai mudar? vai mudar a flexibilidade do do OK e como você consegue colocar os expressar esses protocolos, outros protocolos nas transações dessas redes. É isso. Então vira na privacidade se ele for implementado no A gente vai falar de privacidade um pouco mais pra frente. Diga, filho. Eh, tipo, nessa linha do tempo aí, como que eu sei que eu vou ter dado o suficiente para, tipo, que aquele contrato de eu e tal, porque isso é meio que depois, né, tipo, o cara faz o contrato e como é que eu tenho certeza que, tipo, ah, no futuro eu posso realmente Essa é uma boa pergunta, ó. Como é que teu nome, meu filho? Gustavo, Gustavo tá perguntando, cara, como é que o o cara que tá me pagando, como é que ele sabe escrever um contrato que no futuro eu vou conseguir produzir os dados que para eu conseguir gastar? Eu que tô recebendo dinheiro, certo? A resposta é esses dois, isso aqui precisa de uma coordenação. Se eu tô te pagando, você precisa me dizer como é que tem que ser esse contrato,

entendeu? Não é, não é assim, eu que tô te pagando, eu que produzo a transção do TX Z0, mas envolve alguma coordenação. Eu preciso coordenar com você. Você precisa me dar algumas informações do, por exemplo, que tipo de contrato eu boto aqui? Me dá sua chave pública. Ou esse tipo de informação. A gente precisa coordenar. Professor, mas como é que funciona esse mecânico de coordenação? O Bitcoin não se importa com isso, não especifica como é que vai ser isso. Então aí tem mecanismo 1000, aí tem essa história de endereços. Os endereços de Bitcoin eles codificam os contratos. Então quando eu quero te pagar eu eu falo para você: "Me dá um endereço para eu te pagar". Aí você me dá lá gelar ou aí aparece com QRcode ou com umas strings assim grandes, tá? Aparece uns restos. O que que é aquilo? é o é uma codificação para você me dizer o contrato, os dados que tem que ter naquele contrato, aí você tá me dando aquilo, mas isso é fora da rede do Bitcoin. Isso você me manda por e-mail, sei lá, você me dá um Qcode, escreve aqui no quadro e eu anoto, você me fala pelo telefone, sei lá, entendeu? Isso não importa. Isso já tá até no RH, né? Hã, isso já tá até no RH, né? Tem hashs envolvidos, mas é um pouco mais sofisticado. Todo mundo bem com isso? Beleza. Isso aqui é para mim, é, isso aqui para mim é a coisa mais importante de todas, tá? Isso aqui para mim é a coisa mais importante de todas. Isso aqui, ó, que tá aqui desenhadinho agora. Isso aqui. E reparem, eu mostrando para vocês, parece simples e trivial. Na hora que você tá lá codando as paradas, você fica difícil de entender. É isso aqui. Coisa mais importante de todas. Não pode tirar isso aqui da mente, tá? Beleza? Na aula passada a gente viu vários contratos, né? Vários tipos de contratos, tá? A gente viu o contrato anyone can spend e aí eu coloquei para você. E são contratos que parecem meio bobocas, né? Deixa eu revisar aqui. Any one can spend. Eles são contratos meio bobocas porque em princípio eles não protegem dinheiro, né? Do tipo, ah, eu tô pagando para alguém, para quem? primeiro que pegar, vamos chamar assim, né? Só que essa ideia do N1 can spend é a ideia da gente conseguir manter compatibilidade com os nossos passados, tá? Por quê? Porque para fazer o softwk, a gente viu, eu o que eu posso fazer é transformar coisas que eram válidas em inválidas, mas não o contrário. No caso aqui do da semântica, da a semântica, eu digo é quem é o dono do quê, tá? Eu falar que alguém podia gastar alguma coisa e agora ele não pode mais, é restringir a regra, é deixar mais difícil a regra. Isso eu posso fazer isso como um softw, mas o contrário não, tá? Então vocês vão ver que a gente vai entrar em mais detalhes de segurity t hoje. Vocês vão ver que a ideia do anyone can spend é a ideia central para conseguir fazer esses upgrades serem soft forks, tá? Então assim, parece meio boboca, extremamente importante. A gente viu o outro extremo, né, que é o no one can spend, é o sppendable. No one can spend.

Para que que serve isso, professor? Aqui eu não tô entrando muito em detalhe, mas serve pra gente expressar vários desses protocolos aqui, ó, de segunda camada no na rede do Bitcoin. Porque o no one can spend é uma forma de eu colocar dados em algum lugar lá na blockchain e garantir que eles vão ficar lá e que aquela XO não vai ser gasta, tá? o registro de um documento, por exemplo. Registro documento, por exemplo. Mas enfim, vai ver depois outras outras talvez alguns usos disso aqui, tá? Mas é usado esse tipo de contrato. E repare, isso não é um contrato especial, uma família, né? Tá? É o construir uma coisa que ninguém consegue gastar ou então eu construir uma coisa que todo mundo pode gastar, tá? É, são famílias de contratos. Esses dois são bastante usados pra gente como peça básica pra gente construir nos protocolos, tá?

Ah, deixa eu até anotar aqui para esse aqui é soft for. Isso aqui eu vou chamar de data injection. Então, no fim no acaba gerando até uma inflação nesse sistema. Oi. Oke. Can spend gera até uma deflação sistem. No one can spend. Se eu criar uma XO que não pode ser gasta, eu tô deflacionando o sistema. Sim, eu tô meio que queimando uma moeda

porque ela tá lá disponível, mas na prática ninguém consegue usar. Isso é inclusive uma discussão mais recente de tá, mas e diante de um computador quântico, será que conseguiram destravar essas moedas? E aí o que a gente deveria fazer? Alguma coisa em relação a isso. Eu espero que lá no final vai ter uma aula sobre isso. O quanto que costumam deixar o valor dessas que deixam o contrato zero?

valor que se costuma colocar no contratos unspendable zero. Aí você vê que é um pouco mais sutil do que isso, porque pode ser que tenha um contrato que no no todo ele é ele é spendable de alguma forma, mas ele tem trechos que que se você entrar ali ele é unspendable. Lembra que a gente pode fazer condicionais, né? If, else e tal, tá? Então, em geral, esses no one can spend são bloc são peças dentro de contratos maiores.

Próximo. Próximo. Aí a gente entrou na linha dos contratos standard, né? Só para lembrar. Pub key. Você me dá uma PUB key, eu pago direto pra sua Puby. Você destrava com uma assinatura digital. Public hash, que conceitualmente eu chamo disso aqui de um hash locked contract. É um tipo de contrato que é travado com um hash também, tá? Que além de eu precisar saber uma chave pública, no caso aqui assinar alguma coisa para uma chave pública, eu preciso também conhecer um segredo. Eu preciso saber a pré-imagem de um R para conseguir gastar, tá? Isso que é esses HLCs aqui para mim, que também vão ser peças básicas paraa gente construir outros protocolos, tá? Também vão ser peças básicas. Qual é o segredo nesse caso particular? A Puby, que a Pubyke que é o dono da coisa. Então, para poder gastar, você precisa me dizer qual é a PUBy, que é o segredo, e uma assinatura válida para aquela PUB key. E o terceiro é ainda legacy, tá? Transções legacy, pay to script hash. E aí a gente viu que a ideia aqui é, eu tenho um hash também, preciso saber um segredo, só que agora o segredo é um script.

É um script. Tá falhando aqui. O segredo que eu preciso conhecer é um script. E aí esse script ele vai ser, se eu souber o script certo, isso vai ser validado. E se for script certo, ele vai ser parciado e também executado depois num segundo momento. Todo mundo ok com isso? Beleza. E aí a gente viu, aí eu mostrei para vocês, acho que tem aqui no um pouco no passado. Olha aqui, ó. Aqui nessa parte preta, nessa bagunça do lado de cá, tem os campos de uma transação legacy, tá? E aí um campo que gera problemas é esse aqui, ó, o script sig, que é os dados que estão aqui, ó, os dados que eu preciso dar para cumprir um certo contrato. Qual é o problema disso aqui? Em geral, envolve ter uma assinatura digital. E aí vocês estão vendo lá no assignment 2, eu espero uma das coisas que eu tô pedindo é para você, dado uma assinatura, produzir outra válida. E olha o que eu tô pedindo lá para vocês, tá? Eu tô pedindo para vocês produzirem uma assinatura válida, dada uma assinatura, tô pedindo para vocês produzirem uma outra válida sem nem saber a chave privada dela, do assinante,

tá? É isso que eu tô pedindo para vocês fazerem. Se eu tenho a chave privada do assinante e aí vocês também vão ter um tem um exercício lá que é de assinar. Eu gostaria que vocês explorassem um pouco assinatoria que vocês fizeram, que é o exício um lá do assamento dois, tá? Vocês vão ver que é bem fácil de fazer. Ah, eu assinei, assinei, validou lá, o grader passou. O que que eu gostaria que vocês percebessem? que se você assinar a mesma coisa várias vezes, você vai criar várias assinaturas diferentes e todas elas vão dar válido lá no no Autograder, porque tem uma uma tem um não se envolvido e esse nãoce ele ele tem uma certa aleatoriedade envolvida.

Então não tem uma assinatura para uma mensagem e uma chave. Tem em princípio 300.000 tipo um número enorme de assinaturas. válidas pra mesma chave a partir da mes pra mesma mensagem a partir da mesma chave.

Vou repetir. Nesse esquema que a gente tá fazendo, a mesma mensagem e a mesma chave privada podem gerar um número monstruoso de assinaturas válidas. Não tem só uma, não existe a assinatura digital válida. Existem um monte de assinaturas digitais válidas. Ex um conjunto inteiro de assinaturas digitais válidas. E cada hora que você assina a mensagem, em princípio, gera uma assinatura diferente, porque tem um um certo número aleatório lá no meio, tá? E aí, o que que por que que isso é importante? Por quê? Porque na hora que eu coloco assinaturas aqui, o ID dessa transação vai mudar. O ID é o resto de todos esses dados que estão aí dentro. Se mudou um dado aí dentro, vai mudar o resto dele, vai mudar o ID, tá? E isso impacta essa ideia de a gente construir outros protocolos aqui. Por exemplo, para ficar um pouco mais materializado aqui, uma das coisas que tem no header do TCP é um campo chamado sessão, porque você pode ter aberto um um stream TCP com o Google lá, o seu, você tá lá olhando o e-mail e você tá com um outro browser aberto acessando um outro site que vai abrir um outro stream TCP com outro servidor em outro lugar, tá? E você tá ouvindo música no Spotify que vai abrir um outro stream em outro lugar com outro servidor. Você pode ter 300 streams abertos, tá? Na tua máquina. Pensa que é só pensa que você tá lá com cabo de rede, mas a mesma coisa com Wi-Fi. Você só tem um lugar para entrar e sair bit. Todos os bits entram e sai pelo mesmo lugar. Todos os a tua máquina normalmente aqui a máquina na ponta, né, que é essa que a gente usa, normalmente ela tá conectada com uma coisa só. tá conectada com um access point do Wi-Fi, tá conectado com um roteador lá na tua casa do do lado do teu provedor de serviço, ele só manda e recebe para um mesmo endereço que é o gateway lá dele, tá? Tudo tem que passar no mesmo lugar com pelos mesmos pacotinhos IP aqui. Como é que você diferencia o que que é da tráfego do Spotify, do seu e-mail do Google, do sei lá, outra coisa que você tá fazendo trabalho no banco, como é que você diferencia? Tem um número aqui que diferencia esses caras todos. Ah, não. Esse esse esses esse esse pacotinho aqui é para é é de tal serviço e esse outro é daquele outro, tá? Esse é daquele, esse é desse e aquele é daquele. Por que que eu tô falando isso mesmo? Ah, tá. Porque olha só como que a gente vai, uma das coisas que a gente vai querer fazer para criar outros protocolos, usar esses IDs para identificar do que que se refere à aquela transação ali. Ah, isso aqui é um, entre aspas um pacote que tem a ver com um canal de pagamento assim. Não, isso aqui tem a ver com um contrato compartilhado, não sei o que lá do fulano de tal ali. Não, não, não. Isso aqui é um coin join. Não sei como. Isso vai ajudar a gente a identificar essas coisas, tá? Só que se eu posso ficar mudando o TX ID, a torta e a direita, aí isso me complica do lado de lá, porque eu não consigo prever como é que esse TXID vai mudar. Se eu conseguisse prever, não tinha problema, tá? Qual que é a ideia do Seg? Uma da, uma das principais justificativas para fazer esse upgrade é vamos resolver esse problema de maleabilidade aqui, ó, das transações. Como que eu faço isso? Como é que eu faço isso? Como é que eu faço para incluir para o ID da transação não poder mais ser mudado?

Qual que é a ideia básica? é tirar do ID da transação, do cálculo dela, tudo aquilo que pode ser mexido, que são as assinaturas. São as assinaturas, tá? Então eu preciso tirar esse campo script sig do do cálculo do TX ID. Só que se eu fizer isso, eu tô fazendo hard, né? Eu tô mudando a regra, os nós antigos, eles não vão saber fazer a mesma coisa que eu. Então não posso simplesmente ir lá e falar: "Não tem mais esse campo aqui". ou na conta do TX do TXD não entra mais tal campo. Isso eu não posso fazer, mas eu posso fazer uma outra coisa que é uma coisa um pouco mais sofisticada, é mais complicada que a gente fez, a gente criou uma outra um outro campo a gente de witness e lá a gente vai colocar essas assinaturas aqui, ó. vai ter o script sigu

script sig lá em cima ou aqui embaixo agora só qual que é o truque como a gente viu na aula passada os nós antigos eu, o meu nó sabe se eu tô falando com nó novo ou não. Eu sei porque eu fiz o handsha shake e a gente trocou bits dizendo que que quais serviços a gente suporta na rede. Esse inclusive eu se eu sou um nó novo, eu conecto em você. Eu sei se você é o nó antigo ou um nó novo. E aí, se você é o nó antigo, eu nunca te mando essa informação aqui. Você nunca vê isso aqui. Para você, isso não existe. Se você é um nó novo, eu te mando isso aqui também adicional, te mando mais dados, tá? E assim que a gente vai diferenciando a coisa. Só que perceba uma coisa, perceba uma coisa que a gente vai olhar agora os dois contratos do Seg. Percebo uma coisa, pro nó antigo, se ele não vai receber isso aqui,

ele tem que conseguir validar um gasto sem essa informação.

Ele nunca vai validar. Ele tem que conseguir validar esse isso aqui sem essa informação. Mas soft não é mais isso. Isso quer dizer que o nó antigo ele não vai validar, não quer dizer que validar é decidir se é válido ou não, tá? É isso que eu tô chamando de validar. O que eu tô dizendo aqui, um nó antigo ele tem que ele uma coisa no soft fork, uma coisa que era válida pode se tornar inválida. Então, pro nó antigo, uma coisa pode ser válida e pro nóo, ela ser inválida, porque tem regras adicionais, mas o contrário não. Isso quer dizer que pro nó novo uma coisa válida não pode ser inválida pro nó antigo, entendeu? Isso quer dizer que os nós novos, na hora que a gente faz essas transações segu novo pode falar: "Isso aqui não é válido". E o nó antigo decidir que é válido. Outra coisa que pode o nó novo falar que uma que aquilo ali é válido e o nó antigo também concordar. Isso é válido. Deixa eu escrever as possibilidades porque acho que não vai ficar confuso. Ó. Oi. Quem vai decidir? Não é o consenso dos nosos. Vamos lá. legacy e o upgraded é o novo.

Eu posso ter uma coisa válida aqui que o nó novo concorda que é válido. Isso aqui tudo bem pro soft fork. Eu posso ter uma coisa válida aqui que é inválido aqui. Isso aqui é OK pro soft for. Eu tô deixando a regra mais difícil. Tô restringindo as regras. Aqui eu posso ter uma coisa inválida e o nó novo concordar que é inválido. Isso aqui tá OK. O que eu não posso fazer é uma coisa que era inválida aqui passar a ser válida aqui. Isso eu não posso fazer. Se eu fizer isso aí, eu tô separando a fragmentando a rede em dois. Esses aqui vão ser é um upgrade incompatível. Mas esses upgrades no final das contas eles só vão importar tipo assim pros mineradores. Só os mineradores que vão não importa para todo mundo. Eu quero usar a transação nova porque se eu tô fazendo um upgrade porque ela me dá alguma vantagem. Sim, mas por exemplo, se eu fico na antiga, alguém atualiza, ela vai pra nova inválido. E aí o o minerador ele quando ele for colocar no bloco, dependendo da versão que ele tiver, ele vai, eu posso se ele tiver na versão nova, ele vai invalidar, não vai entrar no bloco e tudo não vai ser válido nem para mim nem para você, porque só entra, só é válido para todo mundo se entra no bloco em próprio de trabalho. Repete. Eu eu deixa eu ver se eu entendi seu seu comentário. Você tá me dizendo que vou imaginar que tem um minerador que não fez o upgrade, ele tá aqui. E aí ele colocou lá no bloco dele uma transação desse tipo aqui, ó, que para ele é válida, mas que pros nós que fizeram upgrade é inválido. É isso que você tá me comentando? Porque aqui não tem problema. Aqui não tem problema. Aqui os dois concordam. Aqui a gente não vai fazer porque a gente já sabe que dá problema. A questão é essa que tá marcada ali. Era válido e ficou inválido. Eu restringi a regra. de trabalho. Então, se o minerador minerar um bloco que tem uma transação dessa, o que que vai acontecer? Ele vai ser, ele vai propagar, ele vai calcular pr trabalho, aquela coisa toda. Para ele, aquilo é tudo válido. E aí ele propaga pro resto da rede. Pro resto da rede. Se a maioria dos nós for nós legacy nos dos nós, dos nós e dos minadores, inclusive, mas se a maioria dos nós for legacy, eles vão aceitar isso aí porque é válido para eles, tá vendo? Mas se a maioria dos nossos for nós que fizeram upgrade, eles vão ver esse bloco novo e eles vão considerar aquele inválido, inclusive os os mineradores, os outros mineradores. O que que isso quer dizer? Quer dizer que quer dizer que a gente precisa coordenar esse upgrade. Não é de qualquer jeito. Coordenar esses upgrades é um problema. Por quê? Porque eu preciso ter uma certa maioria que faça o upgrade para ele de fato funcionar. Seria foi quase uma dois pontos. Primeiro serei que viraria quase uma questão religiosa. Não acredito numa coisa outra no outro. Uma questão religiosa não é uma questão religiosa não. Mas assim, uma questão de enfim, não acredita numa coisa, outro acredita no outro. E como é que você você falou da maioria, né? Mas como é que se decide se a maioria? V, como é que você decide essa maioria? Cara, você é autônomo e e você é autônomo e soberano para decidir o que você quiser. Ninguém consegue falar para você fazer ou deixar de fazer. Isso não quer dizer que a gente não vá conversar. Isso não quer dizer que na hora que a gente tá conversando sobre upgrade, que a gente tá conversando sobre upgrade, que não tenha discussão e o fórum na internet e um monte de gente falando dessa coisa e você tá lá e tentando se convencer do tá e o que que eu deveria fazer, entendeu? Eh, eu tava pensando a mesma coisa, eu acho que a resposta eh mesmo se oador lega fizer o neg, eventualmente ele também vai voltar pra sintonia com os tantos dados, porque quem tá atualizado vai continuar. Isso, isso que eu ia colocar agora. Então a a cadeia de de criança isso é importante na hora que tiver o upgrade que tem alguma certa uma certa maioria nos entre os mineradores que fazem o upgrade. Por quê? Porque se isso aqui acontecer, o bloco válido, ele vai ser invalidado. Se a maioria dos mineradores tá minerando na regra nova, essa essa cadeia que vai produzindo esse tipo de de transação aqui, ela vai acumulando mais prova de trabalho e aí ela vai reorganizando a cadeia do outro. Você entendeu? É um negócio muito assim, o negócio que não atualizou vai até isso é isso aí. É muito doido. O, vou repetir o que me falou, cara, porque é isso mesmo. O nó que não atualizou, ele fica na cadeia certa. Por quê? Porque a cadeia certa acumula mais prova de trabalho. E aí isso, repare, se você é minerador, nesse momento, você tem um incentivo monstruoso para fazer o upgrade. Por quê? Porque senão você tá minerando e seus blocos que você tá minerando, você tá perdendo o tempo todo e você já tá gastando trabalho. Então quando acontece o upgrade, meio que meio que tem um momento crítico ali que os minadores percebem, cara, tipo, vamos meio que todo mundo faz o upgrade porque senão ele vai continuar trabalhando em blocos e os blocos vão ser rejeitados pelo resto da rede o tempo todo. E aí ele tá só perdendo dinheiro, entendeu? tá só perdendo recurso. É, quando você manda um bloco tem algum mecanismo para você cutucar algum nome e fal no se tem um mecanismo? Se eu mandei um um bloco inválido para você, você tem algum mecanismo para avisar te avisar. Então, no passado tinha mecanismo que eu que avisava, mas isso é meio que um vetor de ataque. Aí tem ataques possíveis que você pode fazer em termos disso. Hoje em dia é mais restritivo, tipo, se você manda um bloco inválido, a política normal é meio que você só desconecta e bane aquele nó ali e tipo para de falar com ele. Eu posso sem querer então na perderão. Pode pode acontecer isso também. E aí, repara, isso aí é outro mecanismo que acaba no nível da rede que acaba incentivando que tu faça o upgrade, porque você começa a ficar meio mais desconectado, né? Você tá mandando bloco em vale o tempo todo, os outros estão desconectando de você, eles acham que você tá bagunçando a rede, eles vão desconectando e você vai ficando mais isolado na rede. Naturalmente. Naturalmente. Professor, eu vou na minha máquina e assim com uma certa frequência eu percebo o o meu software de segurança lá, ó. Eh, dá como que alguns endereços foram bloqueados. É comum ataque na rede do Bitcoin? É isso. Fala de É como ataque na rede Bitcoin deve ter todo dia. É. Agora que tipo de ataque? Não sei te dizer. Fala trojando. Ah, não. Isso aí, meu amigo. Isso aí. Isso aí. Se você tá rodando noite, você tá entre entre as tem um servidor na tua máquina que tá recebendo dados. Uhum. E e e é relativamente fácil de descobrir, de encontrar o seu nó na rede. É feito para ser fácil, porque você quer você quer aumentar a conectividade. Então, só que por outro lado tem um monte de gente que não tem nada a ver com atacando o Bitcoin que tá tentando atacar tua máquina. Se tu tá rodando hoje de Bitcoin provavelmente tem chave, chaves que ali que destravam valores. Então, ataque na red Bitcoin tem todo dia. Tipo, deve ter a cada segundo, deve ter o tempo todo. Esse é o normal. Tem que fazer o senhor funcionar, apesar disso. Todo mundo bem? Posso ir? Beleza. Então, segue o baile aqui. Segue o baile aqui. No seguis tipos de contrato. Como é que eles funcionam? Primeiro deles é, vou chamar de pay to witness public hash. Hã?

Segwich. É seg wit. Nossa, eu não consigo falar isso. Essa palavra pr mim é muito difícil em inglês. Segregated witness. Witness é testemunha. Witness é o um jargão em criptografia que é quase um sinônimo de assinatura. Quase um sinônimo. Segregated witness. Tipo, separei as assinaturas. Então, vamos lá. Como que é o pay to witness public hash, tá? Que é um upgrade do pay to public hash. Então, a lógica é a mesma. A lógica é mais ou menos a mesma. Eu preciso mostrar um PUB key e eu preciso mostrar uma assinatura. Só que agora vai ter essa itens. Como que é o lock script? Como que é o script de travamento que vai ficar na saída de uma transação? Quem tá pagando, presta bem atenção. Ele vai ser assim, ó. Coloca zero. Coloca zero na pilha.

Coloca zero na pilha. Coloca um hash de 160 bits na pilha. Acabou.

Esse é o script de é o locking script. É o script de travamento para comparar com era antes, tá? Como que era antes o pec? Ele era assim, ó.

Ele era esse aqui, ó. Duplica, coloca um resto na pilha, perdão, duplica, calcula o resto do que tá no topo da pilha, coloca um R, compara os dois RS, chequea a assinatura. Ele era assim. Agora ele é assim, ó. Coloca zero na pilha, coloca um H de 160 bits na pilha. Pro nó legacy, pro nó antigo, como que eu destravo essa parada aqui? Como que eu gasto isso aqui?

Como que você gasta isso aqui no N com nó antigo? Como?

Oi? Põe o quê? Pegadeira. Eu preciso botar alguma coisa na pilha só de ó, se eu não fizer nada e se eu se eu deixar um script vazio e executar direto o lock script, vai colocar zero na pilha, vai colocar um hash no topo da pilha. Já tá diferente de zero o topo da pilha. Quando terminar, preciso fazer mais alguma coisa? Ah, não é só verdadeira. Não, não. O o o topo da pilha para para validar precisa estar diferente de zero ou diferente de vazio, né? A pilha não pode estar vazia, não. Não. Aqui já tem o esse a probabilidade ser zero é assim impossível, né? Praticamente precisa fazer alguma coisa para destravar isso aqui? Não. Que tipo de contrato é esse para um nó antigo? Ó lá o anyone can spend. O não antigo, ele olha aquilo lá e fala assim: "É, tá válido. Vou liberar o gasto aqui. Vou liberar o gasto aqui. Só que o antigo olha isso e acha estranho, tá? Tipo, aparece um ordem lá no no log. Você inspecionar o log, aparece um ordem lá, tipo, ah, ó, tem um ordem e uma que expende aqui no meio aqui, ó. Tá esquisito isso aqui, mas é válido. Todo mundo tá vendo? E o nó novo, o nó novo, o que que ele vai fazer? O nó novo ele sabe da regra do seg. Então ele vai olhar as o set, tá? O nó novo vai olhar e falar assim: "Opa, pera aí, deixa eu olhar esse lock script aqui. Se o lock script for exatamente zero e depois 160 bits de 160 bits, tá? 160 bits, essas duas coisas colocando na pilha, ele sabe que isso aqui é esse tipo de contrato, é uma regra lá, tem um if lá, tipo, olhei isso, olhei aquilo, então, tipo, vai para essa parte do do do código aqui no no avaliador, tá? Se isso acontecer, o que que ele vai fazer? Ele vai primeiro olhar o que que tem na witness. Que que tem na witness, tá? A Witness é um campo das entradas da transação e não das saídas. Ele é um campo das entradas. Nesse caso aqui, o que que ele vai fazer? Ele vai pegar o que tiver na witness e vai colocando na pilha. E vai colocando na pilha. Então o que que ele vai fazer aqui? Ele vai primeiro colocar uma, ele vai é o que a gente vai colocar na povar. Então, boto uma assinatura, boto uma pub key aqui na witness. Que que o nó novo vai ver? Ele vai falar: "Ah, é a witness dessa entrada tem dois elementos. Então, vou pegar o primeiro e botar no topo da pilha, que é a assinatura. Vou pegar o segundo elemento e botar na no topo da pilha, que é a PUB key." Então, o que que a Witness faz? Ele pré preenche a pilha antes de executar os contratos. Depois disso ele começa a executar o unlock script. Professor, mas o unlock script sou eu que coloc você na hora que tá querendo gastar, tá na entrada da transação. Sim. O witness também. E ele vem na frente do lock. Ele é executado antes do lock. Ele é executado antes. Isso já era assim. Tudo bem. Agora eu botei uma outra, uma terceira coisa que é a witness, que também tá na entrada da transação, que é executada antes do unlock, mas ele não é um programa arbitrário, ele é simplesmente uma lista de dados que eu vou botando na pilha na ordem que elas aparecem. Conseguir colocar alguma coisa. Isso é aqui, é, não é dado aqui. Eu eu posso ir preenchendo a pilha, mas eu não posso executar o script arbitrário aqui nesse momento da witness, tá? O unlock pode ser vazio. O unlock pode ser vazio. No caso aqui vai ser vazio, tá? Por quê? Porque quando eu ver esse unlock aqui, o que que eu vou olhar? Eu vou olhar e eu vou eu vou olhar e vou perceber. Hum, isso aqui é um witness page to public hash. O que que eu tenho que fazer? Então eu tenho que executar aquele script que era antes lá do do PUBG hash Op dup não sei o qu ba bá aquela coisa toda. Mas você colocasse não seria também pro NU porque estaria diferente zero. Como é que é? Não seria gastável para não se se eu colocar o quê? Um unlock vazio sempre vai tá diferente zero. Um unlock vazio. É. Não, mas eu tô colocando um unlock vazio aqui, ó. Sim, mas se eu deixasse um lock sem witness foi você que envia. Se eu colocar um lock vazio, uma witness vazia, ele vai executar essa lógica com com a witness vazia e com unlock vazio. Vai falhar o script, na verdade, mas ele vai executar essa regra. O que que vai ser? O que que o nó novo o que que ele talvez você possa bagunçar? É, se você não seguir esse template aqui, por exemplo, se eu botei aqui, botei 10 aqui, ó, em vez de o valor 10, em vez de zero, aí ele vai olhar e falar começando com 10, eu não sei o que que é. Se é diferente de zero, então vai ficar se é diferente de zero, aí o que que eu faço nesse caso? O nó novo, o nó antigo ele não, ele não sabe nada disso, ele só faz o que ele vai fazer. O que que o nó novo faz se ele vê uma coisa que ele não conhece ali no lock script? Ele simplesmente faz o a regra antiga, que nesse caso aqui é um N1 can, entendeu? Nesse caso aqui, esse esse essa flag que vai falar para ele que é vai interpretar de outro jeito que vai e não é nem só flag, é o formato que tá aqui. Você vai ver que tem um outro contrato que tem a mesma flag, mas tem um formato, tem um outro dado ali. Mas essa flag é importante. Inclusive isso aqui tem nome, tá? Isso aqui é o número de versão. Número de versão. A gente vai ver já um outro caso que versão é diferente. E esse cara aqui a gente chama de witness program. Eu não gosto desse nome, mas é o que é. Tá na especificação. Witness program é o é o nome desse hash, tá? O que que vai o que que esse hash 160 vai validar? Ele vai validar se essa pub key bate com esse, se o resto daquela pub, que é o que já fazia antes, né? que é o que a gente vai fazer antes. E eu vou validar se essa assinatura de fato assina essa mensagem, que é o que a gente já fazia antes. Isso aqui é o o contrato novo do Seg. Professor, qual que é a vantagem disso, professor? Fora a história de maleabilidade, tá? Fora a história de mabilidade. Por que que não é maleável essa transação? Porque essa assinatura aqui, ó, não entra no cálculo do TX ID, só esses dados aqui estão aqui, ó.

E agora o unlock tá vazio. Não tem o que eu escrevo aqui, ó, para poder mexer na transação. Ele tá vazio, tá? Se eu mexer nisso aqui, ó, mexo na na semântica da transação. Ela significa uma coisa diferente, não significa mais a mesma coisa. Tudo bem? Outra vantagem, aqui tem menos dados do que tinha antes. Aqui tem bem menos dados do que tinha antes. Olha como é que era antes, ó. Cadê ele? Antes era isso aqui tudo, ó. Aliás, não, antes era esse aqui, ó. Antes era isso aqui tudo, esse programa aqui todo. Agora só tem um hash lá e um byte zero. Então tem menos dados. Então isso é mais barato, paga menos taxa, tá? A gente vai ver ali um pouco já já ali na frente. Isso aqui tem uma outra questão de de taxa que mudou o cálculo, mas daqui a pouco eu falo sobre isso. Todo mundo bem com isso? Mas repare, isso é uma regra especial, né? Uma regra particular, tá? O outro contrato é o pay to witness script hash. Como que é o lock dele? Lock dele é assim, ó. Coloca zero no topo da pilha. Coloca um hash de 256 bits no topo da pilha. Só

como que é o unlock pro nó legacy, pro nó que não fez o upgrade, como é que ele destrava isso aí? Não precisa fazer nada, né? É só gastar. Isso aqui já é válido. Repare, isso aqui é um N1 spend, ó, pro nó antigo. Isso aqui é um N1 spend pro nó antigo. Por isso que eu falei que o N1 spend é chave dos soft do soft focus aqui nessa aqui nesse mundinho, nesse pedacinho do do protocolo. É importante e demorou-se para perceber isso, tá? Isso não é tão fácil de perceber. É fácil perceber eu falando aqui para vocês e vocês vendo já a coisa feita, mas isso foi uns dois anos até as pessoas perceberem que dava para fazer assim. Qual a importância tão grande deixar os antigos na rede com esses contratos que não seriam válidos? Porque tem dinheiro do legacy lá ainda, cara. A maior parte do dinheiro inclusive tá em endereços lega. parte não, mas assim, sei lá, uns 25% do valor da rede tá em endereços.

Por que que é importante você não expulsar a rede, os nós antigos da rede? Porque a rede é mais valiosa com com mais nós e não mais valiosa com menos nós.

Segue o baile aqui. E o nó novo, o que que ele precisa fazer para destravar? Na entrada da do gasto lá onde ele tá gastando, vai ter um campo da Witness. Ele pode colocar dados. à vontade aqui vários dados, né, o que for necessário. E última coisa que ele precisa fazer é colocar um script. Colocar um script. E aí, qual vai ser a semântica? A mesma semântica que tinha antes, que é eu pego esse script aqui, olho ele como um monte de bytes. Eu não vou interpretar ele agora no primeiro momento. E eu checo se o resto dele bate com o resto que tá aqui. Se não bater, já falhou. quer dizer que você não conhece o segredo para poder gastar isso. No caso aqui, o segredo é um script. Se bateu, eu vou parar esse script. Vou passear esse script. E aí eu vou usar aquilo como programa que vai ser de fato executado, tá? Vou usar aquilo como programa que vai ser executado. Daí eu coloco, vou colocando os dados que estão aqui na pilha, na pilha, e executo esse programa que tá aqui com as que esses dados estão lá na pilha. que é o que a gente fazia antes também, é a mesma coisa do script hash. Só tô mexendo onde eu coloco os dados. Tô fazendo hardodinha antes. Todo mundo OK? Isso é são os dois contratos do Seges dois tipos de contratos aqui, tá? Só tem esses dois tipos de contrato. Tem umas coisas interessantes que dá para fazer, mas que eu não vou entrar em detalhe aqui para explicar para vocês, mas uma delas que vale a pena eventualmente vocês olharem em algum momento, que é dá para eu embutir esses dois contratos aqui, que são contratos novos que os nossos antigos não conhecem, numa transação que é pay to script hash, que é essa daqui, ó. que os nós antigos depois de 2012 conhecem. O seg é 2017, esse aqui é 2012, tá? Então tem como pegar uma transação seg, um contrato seguit, colocar ele dentro de um page to script hash e aí o antigo conseguir validar o o contrato novo. É meio doido essa parada. é bem inteligente, é relativamente simples, tá? Mas vou deixar para vocês olharem como é que funciona isso. Tudo isso é meio que isso é uma consequência não intencional de como foi feito o upgrade anterior, tá? Mas enfim, dá para fazer esse tipo de coisa. Segue o baile aqui. Por que que é com 256?

Porque eu preciso ter uma forma de diferenciar esse desse. Não. Sim. Tipo o se aqui atrás. É aqui atrás era R 160 também, né? Que ele aqui, ó. Tá. Porque se o certo, o itens, ele depois que o novo, ele identifica que é eh no eh page o principal hash ele executa o o log script do pop. Aham. É a mesma coisa que acontece com pro com script. Não, não, a mesma coisa não. Repara que esse aqui, ó, já era R 160. Então, esse aqui não, não mexeu. Esse aqui, esse R 160 tava aqui para validar o script. Só que lá na na lá no no aqui no seguma forma de diferenciar esses dois. Aí, como é que se decidiu? Vamos botar esse aqui com R de 160 e esse aqui com R de 2 256 bits, porque eles vão ser diferentes. Eu diferencio pela quantidade de bits que tem nesses restos. Então repara que é uma variação do que tinha antes. Qual que você tinhaado? Esse que eu acabei de falar para você aqui informalmente que é que é não tem um lock que tal vai vai executar isso que eu tô te dizendo aqui. Tem uma regra lá hardod vai colocando o os esses campos, esses data, esses dados na pilha. Vai botando lá pá pá pá. Bota na pilha, bota na pilha, bota na pilha. Chegou no script, passeia o script. e vê o que tem ali e executa o que tem ali. Então o script vai dizer o que que tem ali e aí você vai executar. A gente viu um certo exemplo aqui atrás também que era um que era esse aqui, ó, que era o multisig. Então nesse para fazer esse mesmo exemplo aqui, que que eu colocaria? Que que eu faria ali, ó? Tá? Que que eu faria? Esse pedaço aqui é o script. Esse pedaço aqui é o script. Eu coloco tudo naquela coisa que tá assim, ó, script lá, tá? Esse aqui, ó, é um dado, outro dado, outro dado. Então, como é que apareceria minha witness? Minha witness teria quatro, quatro itens, quatro elementos. Primeiro zero, depois a assinatura um, depois a assinatura dois, depois um script. O script tem todo esse bloquinho aqui. Aí o que que a coisa vai fazer? O validador vai fazer, ele vai pegar o script, fazer o rash disso aqui tudo, fazer o r disso aqui tudo e comparar com o rash que tá lá no no no witness program, que é um hash também. Se bater, ele olha e fala: "Beleza, bateu, então vou executar". Coloca esse esse aqui na pilha, coloca esse dado na pilha, coloca esse dado na pilha. Aí a tua pilha começou pré-preenchida.

Parceia esse script aqui. Aí ele vai ver essa estrutura interna agora e executa a estrutura interna. Entendeu? E aí, continuando, que no caso aqui é coloca dois na pilha, coloca pub na pilha, coloca pub na pilha, coloca pub na pilha, coloca três na pilha, cheque muito seguir essa pilha toda e vai dar verdadeiro falso nesse caso, nesse exemplo aqui. Mas esse script pode ser o que você quiser.

Todo mundo bem com isso? Todo mundo OK? Beleza? Uma segunda coisa que o Segit, que o upgrade do Seg tava tentando resolver mais ou menos, que é o seguinte, o Seg foi proposto num ali entre 2015 e 2017, tá? 2015 começou uma discussão de aumentar o tamanho do bloco do Bitcoin, que era 1 MB, no máximo 1 MB, contando todas as transações que estão no bloco mais o cabeçalho, tinha essa regra, tá? E existia um certo consenso de aumentar o tamanho desse bloco. O que não tinha consenso era quanto aumentar, qual como aumentar, né? se a gente aumentar só uma vez ou se a gente já colocar uma regra aqui aumentando, tinha várias propostas na época, tá? Eh, e tinha um certo consenso na comunidade inteira de vamos aumentar, tá? O que eu tô dizendo que não tinha consenso é o como e nem quanto, tá? O seg foi o que acabou prevalecendo esse upgrade aqui. Como que ele aumentou o tamanho do bloco? Porque repare que aumentar o tamanho do bloco simplesmente é fazer um hardf. Por quê? Porque agora eu tenho blocos que eram inválidos, que vão ter mais de 1 mega, eles passam a ser válidos. Isso é um hard fork, tá? Só tô de obrigando todo mundo a fazer o upgrade ou não fazer o upgrade e separar a rede em dois, em duas moedas diferentes, que foi o que aconteceu. Vamos lá, então. Qual que foi a ideia do Seg para conseguir aumentar o tamanho do bloco? Eles olharam e falaram assim: "Oi?" olhar e falaram assim: "Eu não posso mexer nesse limite de 1 mega. Não posso mexer nesse limite de 1 mega. Mas eu posso nessa ideia de eu não vou mostrar algumas informações pros nossos antigos, quer dizer que tudo aquilo que tava nos ou quase tudo que tava no script SIG, tudo aquilo que puder ir para Witness, tá diminuindo o tamanho das transações, porque são dados que não vão ser enviados pros pros nós, certo? Isso quer dizer que na prática é como se eu tivesse aumentando o tamanho do bloco, porque eu um lugar onde cabia, sei lá, 1000 transações, 2000 transações, vão caber agora 3.000, 4000, sei lá quantas. Por quê? Não é porque aumentou o tamanho do bloco, mas é porque eu tem menos dados nas transações e são dados grandes, tá? Assinatura um uma informação relativamente grande aqui nesse nesse nesse meio todo aqui. Opa, que que a gente que que se colocou então? Beleza? Vamos fazer o seguinte, mas vamos colocar um limite porque a gente também não quer bagunça nas witness. A gente não quer deixar sem limite, porque eu podia deixar sem limite de dados na witness. E aí o que que eu tô fazendo? Efetivamente eu posso botar tipo quantos dados eu quiser nas withtness e tipo fazer uns negócios gigantescos. A gente também não quer isso. A gente quer limitar os dados que estão nas witness, tá? Então apareceu a ideia de a ideia de um conceito que a gente chama de peso. A gente vai calcular duas coisas na transação. Uma primeira métrica é o size, é o tamanho da transação. Quantos bytes tem na transação, que é o que a gente já fazia antes. Quantos bytes tem na transação? Tem tantos, tá? Só que isso aqui é incluindo os dados da transação legacy e não aos não as witness. Tudo que tiver na witness não entra aqui, que é o que a gente já fazia antes, não existia Witness. O peso da transação será o seguinte, tá? Peso da transação vai ser calculado assim. Na verdade, eu vou dar aqui o cálculo do bloco porque é o que tá na spec, tá? O peso do bloco vai ser o seguinte, o base size, opa,

vezes 3, que é pega os dados das transações, os dados que já tinha antes, soma aquilo, multiplica por três. Então, vamos supor que tinha uma transação que tinha 100 bytes antes. 100 bytes antes. E tem uma outra e eu consigo escrever uma outra transação seguit com 70 bytes mais 30 bytes na witness, por exemplo, que eu vou chamar assim, tá? 30 bytes na witness. Esse 100 entra aqui. Opa. Esse 100 entra aqui, ó. Esse 70 entra aqui sem azuis multiplicado por 3. Então aquilo vai ter peso 3 mais

o peso o o tamanho total da parada. Então se nesse exemplo aqui tá entrando aqui, tá entrando total size aqui, vai tá entrando 170. nessa componente aqui. E aqui tá entrando 200, porque aqui tá entrando as witness. Todo mundo tá vendo? Não tenta entender muito o porqu dessa conta aí, não. É só aceita que é isso aí. Todo mundo OK? Tá. Isso aqui tem que ser menor ou igual a 4 me, no caso vai ser 4 M. Ele cham de virtual bytes.

4 MVB. Que que eu tô fazendo aqui? Que que eu tô fazendo aqui na prática? Na prática eu tô dizendo que a witness, os dados estão na witness tem um desconto. Oi.

É isso aqui que eu tô explicando agora. Conceito só de bitcoin. É um conceito só de Bitcoin, não é um bagulho normal de computação. É para poder, é para isso aqui, ó, vai, vai est um tamanho em bytes, só que é para diferenciar do, do, do, de bytes de fato que vão estar lá, entendeu? Mas porque isso aqui não é o tamanho de bytes, aí, tipo, tô pegando 170 bytes xes 3, tipo, tá entendendo? Não tô contando mais os bytes, eu tô montando uma conta, uma conta agora, uma conta da minha cabeça que tá em unidade de bytes, mas eu vou botar um, vou chamar de virtual bytes só para poder diferenciar do outro. Oi? A escolha proporção. Aí, então vamos lá. A escolha dessa proporção, ela é o racional é o seguinte. Aqui a gente tá aumentando o tamanho do bloco para até 4 MB. Se o bloco fosse todo composto de de de de witness, porque a witness só entra aqui. Só que como eu vou combinar dados que dados que eram legacy mais as witness, o que de fato tá acontecendo? Eu tô dando um desconto pros dados da witness, porque os dados da witness vão entrar aqui, ó, multiplicados, multiplicados por um. E esses dados aqui, eles estão entrando aqui multiplicados por três. Então,

primeiro, perdão, isso é, vamos colocar dessa forma que eu acho que vai ficar melhor. Os dados da Wness eu tô multiplicando por um no total. Esse 70 eu tô multiplicando por quatro, porque eu tô pegando três vezes aqui e ele tá entrando aqui também. Então, repare que eu tô dando um desconto, um desconto para witness, tá? Tô dando um desconto para eu tô falando o seguinte, se o seu bloco for todo de transações legacy, vai entrar tudo aqui mais aqui. E aí 1 me dá 4 M, dá 4 M Vb, então fica como tava antes. Só que se eu tiver muitos dados na Witness, entra mais coisas aqui e menos coisas aqui. Isso quer dizer que eu tô dando desconto. Quer dizer que eu posso botar mais dados lá, porque tem tem um budget ainda aqui, ó. Tá entendendo? E aí o racional foi esse. Se for a transação, se for um bloco só de transações legas, fica como tava antes, vira 1 mega, que é o extremo. Se desse para entrar no bloco só witness, eu conseguia aumentar até 4 m de dados, entendeu? E aí, isso aqui, essa, esse é o racional para esses, para essa continha, tá? E aí, isso aqui tem um outro racional que é o seguinte: os dados da são mais baratos. Por quê? Porque na hora de olhar as taxas, que que a gente vai olhar? A gente vai olhar as taxas, a gente vai calcular o o que que o minerador na prática vai fazer, que é o que vocês vão fazer na na no assignment 3. Vocês vão calcular e selecionar transações, calcular nesse freate, ver qual é a melhor, tá? O que que no final das contas importa para você? O que importa para você é, lembra, o minerador quer coletar o máximo de taxa. Para isso você precisa colocar o máximo de transações possíveis no bloco. Ele quer encher o bloco o máximo que ele puder. Então o que que ele vai fazer? Ele vai calcular a soma das taxas de todas as transações que ele tá colocando lá, tá? Dividido. Ã, pera aí. fee rate vai ser, desculpa, a taxa que uma transação tá pagando dividido pelo peso dela. Porque se tem muita coisa na witness, quer dizer que eu posso botar mais transações e coletar mais taxa no volume, tá? Isso aqui efetivamente faz eu pagar menos taxa para botar dados na Witness. E é o desconto de 75% mais ou menos. Quer dizer que o dado da Witness me custa em termos de taxa 75% menos do que o dado normal. Esse dado transmitido da mesma forma ele vai sim. Isso vai ser transmitido da mesma forma. Sim. Os pros nós novos o tamanho do bloco aumentou. Pros nós novos o tamanho do bloco aumentou. Então dá um desconto por Ah, tá. Por que dá um desconto, professor? Por que dá um desconto? Por que dá o desconto? Por que dá um desconto? Isso não acontece hoje. O desconto acontece, tá? Mas por o que que o que eu vou falar aqui agora que era o racional para dar o desconto? Não acontece. Que é o seguinte, depois que eu validei aquela transação, ela tá no bloco, eu validei, eu posso eliminar esse dado, eu não preciso da assinatura nunca mais. Depois que eu calculo o ITX Excel 7, eu não preciso mais manter as assinaturas na minha na no meu no no na minha cópia da blockchain. Eu posso prunar isso, eu posso jogar fora esses dados. E é bem relevante. Se se a gente fizesse isso, seria relevante. Qual o problema de fazer isso? Para mim, se eu me manter em sincronia com a rede, eu nunca mais vou precisar daquelas assinaturas. Pode jogar fora aqueles dados. Qual o problema de eu de todo mundo fazer isso? Problema de todo mundo fazer isso é e um nó novo que quer entrar na rede? Um nó novo que vai entrar na rede, ele precisa da assinatura para validar. Se ninguém mais tem aquelas assinaturas, como é que ele vai validar aquilo? Entendeu o problema? Mas aí não seria uma questão de ou é possível? Mas é improvável. Como assim é possível? Mas é improvável. Quantidade de nós eventualmente alguém vai ter Por isso que na prática todo mundo mantém, todos nós mantém isso aí. Quem mantém uma cópia da blockchain mantém a blockchain com ess com esses dados aí também das witness são os nós de arquivo que a gente chama, né? Arcavel nodes. Eles têm tudo, inclusive isso aí. Mas entendeu? Racional. Um um nó que tá lá só operando, é porque tem nós que eles vão naturalmente prunar a blockchain. É o o mais normal é a gente prunar a blockchain, tá? Tipo, só manter os os dados da blockchain nos últimos poucos dias, talvez semanas, e não todo histórico. É 780 GB, se eu não me engano, hoje a hoje os tudo, né? Só que você pode prunar para uns 50 GB, que já é bem suficiente para você operar ali com dados dos últimos, sei lá, algumas semanas. Aí você pruna 50 GB, é tranquilo, 10 GB, 100 GB, sei lá. Então pode cortar bastante. Agora, só que isso isso não quer dizer que você só vai validar os últimos os últimos bolos, não. Você vai validar do começo ao fim e você vai jogando fora os dados mais antigos, você não precisa mais deles. Para você abrir, para você sincronizar o nó do zero, você vai validar a blockchain do vai baixar e validar. Baixar nem demora tanto, validar é que demora mais. Você vai baixar os 780 GB todos, vai validar transação por transação, bloco por bloco, até lá no final. Isso demora de arquivo, vai baixar dos outros dólares da rede. Isso. Mas repare, você não precisa ter todos os nós com todo esse histórico. Você pode ter menos nós, porque isso precisa de mais recursos. Então você pode ter menos nós e os nós que estão ali mais para validação do dia a dia, nó de minerador, não sei o que, que eles não precisam na bloquinha inteira, ele pode prunar inclusive as wness. Então esse é o racional do desconto do desconto aqui. Por quê? Porque eu tô transmitindo e e alguma informação que precisa de um momento, mas eu posso jogar ela fora, ela não fica consumindo recurso indefinidamente. No bloco, então ela é registrada sem. O bloco é registrado sem witness? Não, o bloco depende. Se eu tô te mandando um bloco, eu meu nota mandando um para você. Eu tô te mandando um bloco novo. Eu vi um bloco novo, tô te mandando um bloco. Se eu sou um eu sou um nó novo e você é um nó legacy, você não sabe o witness. Eu venho aqui no bloco, tiro todas as wness das transações e eu te mando bloco sem as wness. Você nunca vê isso. Então você vai ver aquele no máximo 1 meg ali. Se você é um nó novo que sabe do seg, eu sei que você é um nó novo que sabe do seg, eu te mando um bloco com as transações, com as witness e te mando tudo, entendeu? Os nós velhos nunca vem os dados das witness, eles nem recebem esses dados. Eles não têm o que separar. Eles nem recebem.

Todo mundo ok com isso? Beleza. Esse é o segot, tá? Esse é o segu aula, vou vou até meio-dia e aí vocês saem para almoçar porque não vai ter a segunda parte hoje. Em 2021 teve um segundo upgrade que foi o upgrade do Seg. Um segundo assim já sei lá, já teve 300 upgrades, tá? Tô mostrando os mais relevantes para o assunto que a gente tá aqui, que a gente tá falando de de scripts e programação do dos dos contratos, né? Mas o próximo upgrade que foi relevante aqui é um upgrade chama Taproot. Tapot, tá? Ele introduziu três coisas, são três mudanças, tá? Que estão lá. A especificação é bips 340, 341 e 342. Ele tem principalmente duas coisas interessantes. Eu não vou explicar tudo em detalhe aqui do Tep, cara, é bem mais sofisticado, vocês vão ver aqui, tá? Mas ele traz duas coisas interessantes. A primeira delas, que é essa spec aqui, é eu vou mudar o esquema de assinatura. Lá no assignment você estão fazendo CDSA e CDSI, que é o esquema de assinatura padrão do Bitcoin, do Etherum, de várias de várias redes, tá? Várias redes. Por que que era SCDS? Shinó é uma é um algoritmo já conhecido há mais tempo, bem mais tempo do que CDCA, inclusive, tá? Qual o problema? Ele foi patenteado pelo Klaus Chinor, que é o autor da parada. E aí isso demorou até ser implementado, porque a patente só caiu em 2008, eu acho, ou sete ou oito por aí. Só que depois caiu a patente é que começou a ter implementação e aí demorou, isso demora um tempo, tá? Bitcoin começou a ser desenvolvido provavelmente ali por 2007 e a rede foi lançada 2009, então não tinha implementação disso em lugar nenhum. O Satos não implementou a a parte de cripto do zero. Ele usou uma biblioteca que chamou Open CSL, que não tinha isso, não tinha lugar nenhum implementado isso aqui, tá? Mas tinha CDSA, que era um padrão do Nich, que é um órgão americano que padroniza as coisas lá pro governo americano, tá? As criptografia. Só que Shin dá vários truques interessantes pra gente de multisig, enfim, várias coisas interessantes que dá para fazer, tá? Esse esse upgrade aqui vai introduzir essa ideia de agora a gente pode não só pode que é nos contratos que são te só pode assinatura chinor tá é diferente a coisa só pode assinatura chinor que que o fez uma outra biblioteca sendo que especulam eu faria biblioteca eu usaria biblioteca pronto também tipo eu não faria a minha própria lib de cripto nem pa mas não especulam que ele era criptó Sim, ainda assim, mesmo que ele fosse criptógrafo, você ir lá e desenrolar sua libre de cripto não é não é uma não é uma tarefa trivial não.

Tá muito longe de ser uma tarefa trivial.

A segunda coisa que é interessante, que eu quero comentar um pouco mais aqui, que é essa spec aqui que chama m, que é mercalized abstract syntaxe. Árvore de sintasse abstrata AS. Vocês estudam em teoria de de teoria de compiladores, né, de programa de de linguagem de programação, etc. Tá? que é uma forma da gente estruturar a os programas de computador para poder compilar e parciar eles e entender o que que é a estrutura estrutura por trás da sintasse, tá? A ideia é que a gente vai expressar nos contratos essas árvores sintáticas agora, não só o programa, mas a gente vai expressar a árvore, tá? Repare que isso é mais sofisticado, só que eu não posso ir lá, tipo assim, só que eu tenho limitação de tamanho do que que eu posso colocar aqui. Vocês estão vendo lá 1 mega é pouca coisa, tá? Vai ser essa ideia do mercalized. Mercalized. A gente viu a história de Mercal Trees para poder fazer o commitment de quais as transações estão no bloco e quais não estão. E eu consigo provar que uma coisa tá no bloco. Mostrei isso para vocês. Vocês vão inclusive fazer calcular uma Mercal Tree provas no assignment 3. próximo. Vocês vão fazer lá, vou dar um bolo de transações, vocês vão fazer a M, a Micro Root, fazer a MC Tree, me dá uma prova de que uma delas tá lá e tal, tudo isso lá para vocês fazerem, tá? Na próxima sign, mas a gente vai usar essa mesma ideia, só que agora no contexto dos scripts, tá? Vamos lá. Olha como é que é. Só tem um contrato. Só tem um contrato que a gente chama pay to. pay to tap, tá? O lock script dele é assim, ó. Um um e não se enganem, tet é segurity, tá? Então tudo que a gente viu no seguão

agora é um em vez de zero. E assim que ele sabe que a transção é desse desse upgrade aqui e vai ter um hash de 256 bits ali. Ponto. Repare que a mesma ideia do do seg, né? O nó antigo, olha isso aqui já sabe, já é one can spend, vai pra frente. Mesma lógica. Como que é o unlock? O unlock é vazio. Não preciso de nada no unlock script. Eu posso botar coisas aí, mas eu não preciso. E como é que é o witness? Como é que é o witness? Eu tenho dois casos. Eu tenho dois casos, tá? Presta bem atenção aqui comigo. Tenho dois casos. E aí isso tem a ver com a forma que eu construí esse resto. Então vamos lá. Esse hash aqui ele vai ser o hash do que a gente vai chamar de twicked pub key. Twick twaked

pub key. Esse hash tem que bater com essa o hash dessa tw key que é uma pub key. Que é uma pub key, tá? Só que ela é uma PUB keyda que não é uma PUB key que você sorteia aleatório lá uma chave privada e calcula uma pub key. Não é assim. A gente vai construir essa essa pub aqui, tá? E aí eu vou constrular de duas juntando. Aí o detalhe de como é que é a conta eu não vou mostrar para vocês porque tem muito detalhezinho. Vou deixar para vocês lerem a parada. Mas eu vou juntar de um lado, eu vou ter uma PUB keyra

a partir de uma private key normal, que é o que a gente já fazia antes. Sorteio o número aleatório. Sorteio o número aleatório. Calcula uma um ponto na curva elíptica multiplicando um ponto gerador por esse número aleatório que eu gerei. Essa é minha pub key. Isso vai ser parte da da do twick. Aqui no outro lado vai ter uma miracle root

que a gente viu como é que calculou no contexto das transações, mas é a mesma ideia aqui, tá? Mesma ideia aqui. Só que o que que vai ter aqui na minha árvore do lado direito? Vai ter scripts em vez de ter transações. Então eu vou dar um exemplo aqui para vocês de uma árvore que é assim, ó. Ela tem uma folha aqui, lift. E aí aqui tem um script, um script qualquer. Você vai lá e programa isso. Do lado de cá eu vou colocar uma uma branch,

uma branch. E essa branch aqui tem duas folhas. Tem um outro script aqui,

Lif. Tem um outro script aqui. Beleza? Eu que tô construindo isso aqui, eu tenho que Isso aqui, repara, ó. Isso aqui, isso aqui é um contratão que tem três pedaços, tá? E perceba que implicitamente o que que tá implícito aqui? Tá implícito assim, ó. Se alguma coisa acontecer, então esse script, se alguma coisa não acontecer, então vem para cá. Aí aqui dentro tá escrito assim: Se alguma coisa acontecer, vem para cá. E aí esse é o script. Se não aqui. Então repara que essa arvorezinha que eu tô mostrando para vocês é um if dentro de um if, tá? Isso aqui, ó, eu poderia traduzir com um script que é if alguma coisa. Vou chamar aqui de 0 1 e 2, tá? If alguma coisa script, então script zero, se não for if. Outra coisa, script 1, else

script 2, if.

Isso que tá aqui nessa árvore é o equivalente a um script assim com um monte de fiels. E repare que eu posso construir uma estrutura bem complicada com essa árvore, que é uma estrutura de condicional bem complicada com infielses, tá? É isso que a gente tá fazendo. Beleza? Ótimo. Como que eu gasto essas coisas? Eu vou ter então duas possibilidades. A primeira delas é o que eu vou chamar de keypending, que é usar PUB key para gastar. que PEF spending, tá? Então vou chamar aqui de eu vou botar de de roxinho. Como que eu gasto com essa KPF spending? Eu boto na witness a assinatura que valida esse gasto, que valida essa mensagem toda, a transação. Se eu tô executando a parada e eu tô vendo lá só tem uma assinatura, eu sei. Software sabe que é o KPF spending, ele vai lá. Ah, aliás, eu preciso colocar a Puby aqui em algum lugar. Se eu não me engano, tenho que botar a Pub key aqui. Enfim, tem algum errinho na minha anotação, mas eu dou a Pub key também. e gasto como eu já gastava antes, como se fosse um page pub, como se fosse, tá beleza? O outro caso é, não, eu não quero gastar com a PUB key, eu quero gastar avaliando um desses scripts aqui. Avaliando um desses scripts aqui. Como que eu faço? Então, na Witness eu vou colocando os dados, os dados necessários para aquele script que eu vou executar. Aí cada um deles pode requerer dados diferentes. Então você tem que saber qual script você vai executar e quais os dados ele precisa. Aí você vai lá e coloca lá. Tu coloca aqui o script. Tu revela o script aqui. Aí vamos imaginar que eu tô gastando. Qual que eu tô gastando aqui? Eu tô gastando esse aqui, ó. Tá? No meu exemplo. Então eu venho aqui, pego esse script e coloco aqui, ó. Bum. Os outros eu nunca vou mostrar.

Os outros eu nunca vou mostrar. Só vou mostrar esse aqui. E aí eu vou colocar o que ele chama de control block. São mais dados aqui na Witness, tá? Que que tem que ter nesse control block? Ele tem que ter a Pub key, a PUB key que eu tô tentando usar para gastar. E eu preciso botar o que eu chamo aqui de mercalle pat, que é uma prova de que esse script está nessa mobot aqui.

É isso aqui tá errado da minha anotação aqui. Eu tenho que botar essa microot, né?

Aí eu tenho que botar uma prova de que aquele script faz parte daquela macroot.

Nesse caso particular, o que que eu vou colocar aqui? Eu vou colocar o R desse script aqui. Eu vou chamar aqui de R do script. Aqui eu chamei de zero, de um e de dois. Então vou chamar aqui resto do script 2. O validador calcula esse essa essa esse posição aqui da árvore. Aí eu dou para ele o rest desse script aqui, R do script zero. E ele calcula a microot e aí vai validar se tá aqui ou não. Isso aqui é o control block. Aí você vai botar a prova. Se for grandor nessa árvore, você vai botando os restos necessários, tá? Por que que isso aqui é eficiente? Por que que isso aqui é eficiente? Essa árvore aqui é uma árvore binária. É sempre binária, tá? E if ou else. É sempre para lá ou para cá? Para lá ou para cá. Ela pode ter 128 níveis aqui. Isso quer dizer que eu posso ter 2 elevado 128 folhas. Isso quer dizer que eu posso ter até 2 elevados 128 scripts aí embutidos aí nessa parada. É muito script. É muito script, mas para provar que uma folha tá lá, eu só preciso mostrar no máximo 128 HS, um para cada nível, voltando até chegar na na mot, até chegar na na no root, tá? Isso aqui aumenta monstruosamente a tipo a complexidade do script que eu consigo colocar aí. E repare, eu nunca vou mostrar todo o script. O que eu vou mostrar é, ah, eu quero gastar esse pedaço aqui, que é um ifel e aí eu te mostro o o caminho para chegar lá dentro daquela árvore e os dados necessários para aquele pedaço do script. Tranquilo? Já te passo a palavra. Implicações. Ó, claramente isso aqui me me dá um gan de de escala do script que eu consigo expressar agora. Eu consigo expressar escritos muito grandes, 2 elevado 128 pedaços. Uma parada muito colossal. Acabou o problema. Princípio, vou aí eu tô exagerando, mas princípio, acabou o problema de conseguir expressar alguma coisa ou não aqui. Consegui expressar muita coisa, tá? Muita coisa. Segunda coisa que é um ganho, que é um ganho, é um ganho, no meu entender. Eu não revelo todo o script. Ó, esses pedaços aqui eu nunca mostrei para ninguém. Eu só mostrei os hash e se eu te mostro o hash, você não sabe o pré-imagem dele ainda e você nunca precisa ver a préimagem. Então, do ponto de vista de privacidade, melhora minha privacidade. Você não tá vendo o que tá escrito no contrato. Você não você nunca nunca tá vendo o contrato inteiro. Nem na hora de gastar você tá vendo o contrato inteiro. Ao contrário do page, o script hash que a gente escondia o script. Eu não te mostro o contrato na hora de pagar, mas eu preciso mostrar o contrato inteiro na hora de gastar. Mesma coisa no seg. Eu consigo fazer page, witness, script hash. Eu escondo o contrato na hora de g de pagar, mas eu preciso mostrar o contrato inteiro na hora de gastar. Aqui não. Aqui eu escondo o contrato inteiro na hora de de pagar e na hora de gastar eu só te mostro um pedacinho do contrato.

E aí isso me permite fazer coisas do tipo, do tipo, olha só, eu Edil sei esse script, o Pedro sabe esse script, o Henrique sabe esse script e a Mel sabe a PUB. E eu só sei o meu e não sei os outros. O Pedro só sabe o pedaço dele e não sabe os outros. O Henrique só sabe o pedaço dele e não sabe os outros. E a Mel só sabe a parte dela e não sabe os outros. E ainda assim nós quatro conseguimos gastar essa, conseguimos gastar isso aqui.

Então cada um de nós pode ser dono do do da moeda da UTXO usando um contrato diferente para cada um. e a gente nem saber como é que é o contrato dos outros. Louco, né? Esse é o tipo de coisa que dá para fazer aqui. Não tô dizendo que é fácil e trivial de fazer, mas dá para fazer. Tem implementação. A wallet tem que ser bem muito mais sofisticada. As wallets, as carteiras. Agora, qual é o downside dessa parada aqui? Na sempre é uma coisa que tem coisa, parte boa e parte ruim, tá? Tem dois problemas aqui, dois problemas principais. O primeiro deles é a minha carteira precisa guardar mais dados. Porque não basta eu saber minhas chaves, minhas chaves para assinar transações como antes. Eu preciso conhecer esses scripts também. Eu preciso guardar esses scripts. Se eu perder o script, eu eu não gasto assim como não gasto se eu não tiver a chave. E o backup dos scripts é mais complicado do que o backup das chaves, porque o backup da chave eu gero, eu uso uma semente e eu gero chaves deterministicamente. Eu consigo reconstruir todas as minhas chaves. Se eu tiver, sei lá, quantas chaves eu quiser, eu reconstruo todas elas no futuro, só guardando um número. Aqui não, o script não dá para fazer isso. Script eu preciso guardar o script, preciso guardar os dados. Então o backup disso é mais crítico, é mais complicado, tá? Segundo problema, que é um, eu acho que foi discutido na época, não acompanhei essa discussão aqui, mas é uma coisa tá sendo discutida. É provável que em algum momento tenha um um outro softwk para dar um para arrumar isso. Isso que é o seguinte, esse caminho aqui é um problema. É um problema no contexto de computação quântica. Por quê? Porque essa PUB key não tá protegida atrás de um hash. Essa PUB key aqui, ela ela tá meio que exposta aqui nessa Twick PUB key. Eu não tô mostrando como é que calcula a parada, mas enfim, vocês vão olhar no detalhe, ela não tá protegida por um rest. Isso quer dizer que na hora que eu publico o pay to taper alguém consegue ir lá e calcular essa twicket pub key, porque ela tá aqui. Eu disse que é um hash, mas na verdade é um é um s twak aqui. Ele consegue ir lá e calcular essa pub key. E aí se eu tô com a PUB revelada já tá já conhece a PUB. Tudo isso tá dentro daquele hash. Tudo isso tá Não é um hash. Na verdade eu tô chamando de hash, mas é uma coisa que tem 256 bits, tá? É essa tw de pub aqui no caso. Tudo bem? E aí isso aí é vulnerável nesse contexto de computação quântica. Eu consigo lá calcular a pubqu da da pessoa já com o dado que tá lá público e tentar ficar entre aspas minerando ela, quebrar essa chave, tá? E aí tem proposta, tá começando a se discutir, tá, o que que a gente faz, o que que eu acho que eu vai ser o mais plausível de fazer, mas eu não sei, tá? Eu não sei. Eu acho que o mais plausível vai ser fazer uma nova versão, é fazer um tap V2 aqui, onde eu proíbo esse tipo de gasto aqui, ó. Eu não vou ter mais isso. Eu acho que isso é o mais plausível de acontecer, tá? Porque o lado da me root tá protegida por restos. Tem um monte de restos que a gente vai calculando, tá? Isso aí é seguro a pelo menos a princípio, pelo menos com que se conhece hoje, isso é seguro em termos de computação quântica. Todo mundo bem com isso? Pergunta, filho. É, tá cada um gastar. Tem algum possível? Tem a possibilidade de alguém? Não. Então eu que o exemplo que ó o a pergunta ali tem a ver com eu falei que nesse exemplo eu conseguiria ter quatro participantes na transação. Cada um deles conseguir gastar com script diferente. E a tua pergunta foi se ele gasta tudo ou não. O gasto é sempre tudo. Ó, vou voltar na coisa mais que eu falei que é a coisa mais importante de todas, que é isso aqui. Isso aqui tá acontecendo. Tudo que eu falei ali na frente tá acontecendo nesse contexto. Não existe gasto parcial. Aquilo ali que a gente estava falando agora é o contrato travou um dinheiro. O gasto destrava o dinheiro. Destravou, gastou, tchau. O que que é gastar? É validar essa transação aqui. Essa transação vai criar outras saídas. E essa saída aqui foi gasta, ela nunca mais pode ser gasta, entendeu? Então o gasto é tudo ou nada.

pergunta, professor. Eh, então a lógica deção doit é puramente pelo conhecimento da dessas não tem outra lógica. Não tem outra lógica. Você vai mostrando aqui no control block, você vai mostrando a prova de inclusão. Com a prova de inclusão você é porque você não precisa saber quem tá validando, não precisa saber, não precisa saber conhecer a árvore, a estrutura, a topologia da árvore. Eu só preciso, quem tá validando, eu só preciso saber o script, porque senão não consigo validar. E eu preciso de uma prova de que aquele script foi incluído no contrato. Então você me dá a prova que é essas miracles aqui e eu vou calculando. E repare, tá? Eu não preciso nem saber a topologia para ir pegando o teu esses hashs aqui, ó, e calculando a a recalculando a mercal root lá no caminho, né, a mercalle pat dele. E só que isso implica você tem que me dar esse rest na ordem certa.

Conhecer pelo menos, tem que conhecer o script e a prova de inclusão, entendeu? Aí tem vários cenários. Se você conhece a árvore toda, você guarda a árvore toda, você calcula as provas à medida que quando você precisar. Se você só conhece uma parte do escrito, se eu revelo para você só esse pedaço aqui, eu tenho que te dar isso mais a prova de que isso aí tá incluído lá no naquela naquela me tem guardar um monte de coisa. Aqui quem vai gastar só perce só precisa guardar 128 precisa saber a topologia da da Isso. Isso aí isso aí. Você não precisa saber a topologia, só preciso saber a prova. Só preciso ver a prova. E a prova não inclui a eu per da topologia lá de cima. Isso. Isso aí você já pegou e a prova. Hã? A prova, a prova são essas esses restos aqui intermediários que nesse lembra ó, no meu exemplo eu tô gastando esse script. Então, o que que é a prova? São dois restos. o resto desse script, porque a na hora que eu combinar os dois, eu que tô validando, vou calcular esse essa esse elemento. E aí depois eu preciso do resto desse script, porque eu que tô validando vou combinar com esse branch e calcular esse. E aí eu tô sempre olhando, comparei, combinei duas coisas, calculei o rest, bateu com a Merc Root, não. Então me dá outro Rh, combinei, calculei o R do da concatenação, bateu com Mercot, não. Então me dá outro rest. Se você parar de me dar RH no meio do caminho, eu vou falar: "Então, acabou, falhou". Entendeu? É só eu ficar repetindo esse processo. Tem uma coisa, você me mostrou uma coisa e me mostrou um RH. Eu junto, calculo o R da primeira coisa, junto os dois hash. Isso bate com a Merc Root? Não. Então me dá mais um RH. Eu pego o que eu já calculei junto com o que você me deu, outro hash. Isso é bate com a merot. Não. Então me dá mais um hash. Combina. Eu não preciso saber se é da esquerda, direita, né? Eu só fico fazendo isso. Eu que tô validando. Pego mais um hash, combino com faço o hash e comparo com a Merc Root. Se não chegou ainda, me dá mais um, me dá mais um. E obviamente eu sei que nesse caso aqui são no máximo 128. Se você for me dando 128 H, não chegou ainda, eu já sei que falhou. Professor, eh, e também que tá a pergunta, porque aqui no caso aqui ela tá misturada com essa pub aqui. Aí eu, tipo, eu tô bagunçando o detalhe do que que tem que entrar aqui, porque eu nunca lembro sem ler a spec.

Tem como provar que essa é a Sim, é nesse control block aqui. Tem mais coisas que tem que entrar aí que eu tô escondendo. Tem um campo aqui, ó, que chama annex, que é o anexo, que ninguém nunca usava para nada. Até que inventário de botar figura de JPEG de macaco nesse anexo. É, entendeu? Enfim, eu nem tô mostrando, mas esse anexo tá começando a ser esse anexo, né? um um uma coisa que você, enfim, esse ano é que você tem a ver com a Witness, né? Tipo, é uma forma de colocar mais dados na Witness. Você pode usar ele para colocar dados arbitrários e construir outros protocolos. Ainda eu nem tô mostrando isso aqui para vocês porque é é bem recente. Ninguém nem ninguém tinha usado isso para nada até recentemente,

mas acho que vocês pegaram a ideia, a ideia da coisa. Todo mundo bem? Esse é o estado da arte no na rede do Bitcoin hoje, tá? Então, repare, não dizer que os contratos do Bitcoin não são contratos inteligentes, eu acho que é um,

não sei dizer, eu acho que é até uma ofensa. Eu concordo que contratos no Etéreo, na Solana, Polgon, outras redes, dá para fazer outras coisas, principalmente naquele contexto, naquela coisa que eu falei, que é o contrato, esses contratos na rede do Bitcoin não tem acesso ao contexto completo da transação, eles não têm acesso ao UTXET, eles não têm acesso a outras sanções da blockchain, eles tão um contexto muito restrito de execução. Outras redes, Etheréum, Solana, Poli, tudo isso aí, base, todas elas têm um contexto, um contexto de execução desses contratos mais rico do que no Bitcoin. Então, concordo que dá para fazer outras coisas que não dá para fazer no Bitcoin. Pelo pelo menos a gente algumas coisas a gente não sabe fazer ainda, tá? ainda, mas como vocês vão ver, a gente vai começar a falar de privacidade, de escalabilidade, a gente vai começar com os outros protocolos, vão começar a olhar falar: "Cara, essa parada aqui é meio que infinita, não não termina o que a gente consegue fazer". O que a gente não sabe é às vezes fazer alguma coisa ainda, tá? Mas eu acho que a gente vai chegar lá. Todo mundo ok com isso? Mais alguma dúvida? Não. Então vamos para almoço.