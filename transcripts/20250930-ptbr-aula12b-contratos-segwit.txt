Falamos do primeiro contrato any can spend, quando acontece validação, coisa toda, tá? Vamos falar de um segundo tipo de contrato. Um segundo tipo de contrato. E agora eu quero andar um pouco mais rápido em cima desse contrato. Você já entenderam a lógica básica do a semântica da coisa. Vamos ver exemplos, tá? O próximo terceiro, não, porque para mim é um anyone can spend. Ah, tá. O próximo é o no one can spend. Eu consigo escrever um contrato ou contratos ou uma família de contratos que são ingastáveis, que não existe nenhuma condição que que que ffeu aquele contrato, né, que cumpre aquele contrato, tá? Um exemplo disso, um exemplo relativamente simples, exemplo relativamente simples é opet.

Por quê? Independente do que eu colocar no unlock script, ele vai botando dados na pilha, mexendo na pilha, não sei o quê. Na hora que ele começar a executar o lock script, que tá na saída da transação, op return falha imediatamente. Então não tem o que você coloque naquele unlock script que vai fazer o programa terminar com sucesso, tá? Repare que esse aqui é um caso bem trivial. Um caso bem trivial, tá? Para que que interessa fazer um contrato que falha todas que interessa fazer um contrato que falha todas as vezes? Por um motivo muito simples. Porque olha só, por um motivo muito simples, tu concorda que eu posso colocar dados aqui? Sim. Depois do programa? Eu posso continuar o programa depois. Eu sei que isso vai falhar, mas eu posso botar dados aqui. Aham. Eu posso botar dados aqui. Eu posso botar, por exemplo, coloca esses dados na pilha depois do apurado. Não, mas ele vai ficar lá no contrato. Repare que isso aqui tá escrito na saída da transação. E aí eu posso usar isso, esse isso aqui para registrar dados arbitrários. Agora é a forma mais primitiva de registrar dados arbitrários, tá? De registrar dados arbitrários. Eh,

o quando uma das regras de a gente vai diferenciar entre transações que são standard e transações nãoar, tá? As próximas que eu vou mostrar para vocês são as transações standard, são as transações padrão que elas seguem certos templates. Tudo que que é o standar tem un certos templates. Se tiver naquele template, OK. Se não tiver é não standar, tá? Não standar não quer dizer que não é válida, continua válida se for válida, tá? Só que essa diferença é importante por quê? Porque tem uma questão de política. Lembra que a gente falou da main pool? Que é o que que eu faço quando eu vejo uma transação válida, um bloco válido? Eu validei, eu já decidi que é válido. O que que eu faço com isso? É alvo de um conjunto de políticas, não mais de regra de consenso, tá? E a política esse padrão hoje na rede é do ponto de vista das transações, repropagar, anunciar e repropagar aquelas transações que são standard, que são padrão e não repropagar aquelas que não são, tá? Isso dificulta você ficar propagando, transmitindo transações meio estranhas. A gente vai ver que isso não é exatamente um problema. pode fazer, tem vários mecanismos aqui que eu posso fazer muita coisa, tá? Mas dificulta. Oper tem uma regra de standardness que é as transações podem ter umas exatamente uma saída de amount zero,

só que ela tem que ter o script tem que ser um up return e no data pode ter no máximo 83 bytes de dados aqui.

Essa regra que tava vigente até recente, tá? uma regra de de foi uma regra que foi colocada lá atrás, não me pergunte de onde sa esse número 83 e tal, tá? E tem uma baita discussão hoje recente na internet, vocês entrarem aí tem um um drama monstruoso, não sei o quê, tá? Em torno exatamente desse número 83 aqui, tá? no Bitcoin Corna versão 30 que vai sair agora, vai sair agora eles, tipo, a função mudou, ele não checa mais esse 83, ele deixa qualquer coisa em princípio aqui, tá? Em princípio, quantidade de dados que você quiser, tá? E aí tem um monte de drama, tem gente falando que isso vai destruir o Bitcoin, não sei o quê, blá blá blá, vai começar a botar lixo na blockchain, não sei o quê. uma baita balela, porque no final das contas esse mecanismo aqui a gente vai ver por, mas esse mecanismo aqui é bem pouco utilizado para botar dados arbitrários hoje na blockchain, porque ele paga mais taxa do que outros mecanismos. Então, se eu tenho outros mecanismos que paga menos taxa, eu vou usar as coisas que pagam menos taxa, tá? E aí tem um pequeno, só que tem uma uma questão, porque que eu tô mostrando isso aqui para vocês? Porque quando tem o op return, o op return no script, eu já sei antecipadamente que esses, que essa moeda não, não pode ser gasta. Ela é unspendable e é provable. Eu, tipo assim, eu eu tipo é só ver que não que não que que que não dá para gastar, tá? Tem uma prova que não dá para gastar. O que que isso implica? Isso implica que quando essa transação for confirmada, ela vai paraa blockchain, vai ficar lá junto com as outras no bloco que ela foi minerada, mas que ela ela não precisa ser incluída no UTX, que é um outro banco de dados que os nós mantém. O que que tem nesse UTX? Todas as moedas que ainda não foram gastas. Por quê? Porque essa é a informação que eu preciso para validar algum gasto. Eu preciso, na hora que chega a transação um aqui de trás, eu preciso saber se essa moeda que eu tô fazendo referência, se ela existe aí no na blockchain e se ela não foi gasta. Como que os nossos fazem isso? Quando chega um bloco novo, ela vai validando as transações e vai vendo, tá? Eu fui gastando essas moedas, remove essa informação lá desse exel set, desse banco de dados. Toda saída nova que não for gasta inclui nesse banco de dados. E eu vou fazendo essa essa essa dança. Isso já tava no não. Isso é uma questão de implementação. Isso é uma questão de implementação. Não, o white paper não descreve isso, tá? Mas mas os nós implementam isso. Você dizer assim, ele não precisa implementar, mas se ele não implementar, ele precisa escanear a bloquinha inteira. Facilita. Ele precisa escanear a bloquinha inteira sempre que aparecer uma transação nova para ele validar. Professor, essa transação então ela vai ser transmitida? Ela vai ser retransmitida? Se plano não vai ser pagada, não. Ela vai ser propagada. Se ela for incluída num bloco, ela vai ficar lá na blockchain, mas ela não vai ser incluída no sex, nesse banco de dados que eu tô colocando aqui. Mas ela é propagada, ela é repropagada, tá? Qual a vantagem disso? Qual a vantagem disso? Essa informação aqui hoje tem um cerca de 700 GB, né? né? Blockchain do Bitcoin tem uns 700 GB mais ou menos de dados, tá? Só que eu não preciso manter a blockchain inteira comigo. É bem comum a gente fazer um nó proado. Ele não guarda todo o histórico. Ele valida tudo do começo ao fim, mas ele vai jogando fora os blocos mais antigos para economizar espaço em disco. Mas esse cara aqui é mais complicado de prunar. Eu não consigo. Se eu tirar um dado daqui e eventualmente eu precisar validar uma transação que tá fazendo referência a um dado que tá ali e eu joguei fora de propósito, tá? Eu vou precisar escanear a bloquinha inteira de novo. Eu vou precisar ir lá e caçar que é uma lista ligada. Eu não tenho um índice disso. Eu preciso escanear realmente a blocha inteira, tá? E aí é um processo bem demorado. E essa outra estrutura é o quê? Uma arma binária, uma coisa assim tá facilitada. É um banco de dados que que é feito com inclusive é um banco de dados que é feito com level de DB. É o DB Manager. Pessoal chama de No sequel. Como é que é o nome disso? Ele guarda pares, ele é um hashmap gigante. Sell, é um no SCL, mas é um hashmap gigante que mapeia e o TX ou nos script pubs. Sim, em princípio, tá? Que na verdade ele mapeia os TX ID com index numa estrutura que tem os scripts e tal. Enfim, aí é bem detalhe de implementação, tá? Mas qual a questão? Isso aqui hoje tem duas questões. Isso aqui hoje tem mais ou menos uns 11 GB. Mais ou menos que nem é muito você parar para pensar, tá? Nem é muito, mas já é muito pro teu telefone, por exemplo.

Sim, mas tirou onda comigo, né? Mas ele tem 1 ta de memória RAM. Porque, qual é a questão aqui? Esse esse banco de dados aqui tem io, uma tonelada de IO, lê e escrever nele toda hora. Toda hora que aparece uma transação nova, eu preciso ler nesse banco de dados. Toda hora que aparece um bloco novo, eu preciso ler e escrever um monte, preciso tipo tirar e escrever um monte de de dados novos. Então tem muito IO nesse nesse DB aqui tem muito IO, tá? Então é bem interessante tentar manter isso aqui um cash de memória ou alguma coisa que suporte IO rápido e reliable, né? Tá? Normalmente o que tem, então, normalmente nos no nos nesses dispositivo mobile, às vezes você tem até bastante espaço lá para guardar dados, alguns gigas de SSD, de SSD, mas ele não é necessariamente reliable de você ficar lendo e escrevendo o tempo todo naquilo, sacou? Ele tem meio que um limite de ciclos, tá? E isso aí é um problema desse banco de dados aqui hoje, tá? Enfim. Seguindo aqui, seguindo aqui, ah, para fazer um te aqui de projeto de brasileiro, tem um projeto de implementação de full node que chama floresta, que é o projeto de um brasileiro, Davidon, que implementa o full node, que em vez de manter o UTXO set inteiro, ele usa uma outra técnica que chama 3XO, tá? Como tem árvore no nome, vocês podem imaginar que tem alguma coisa a ver com com construir uma estrutura de dados que é uma árvore e tem a ver, tá? Só que é uma árvore que representa esse Xel 7 ao invés de guardar todos os dados. No mesmo sentido que eu coloquei aqui atrás, ó. Eu quero conseguir validar, mas eu não eu não quero mais guardar todos os dados, mas eu quero ser capaz de validar uma coisa se é válido ou não, tá? Qual que é a ideia básica do do XO set do U3XO é eu guardar uma mer root que representa aquele XL set. É um pouquinho mais sofisticado que são várias árvores, na verdade, mas árvores de Merkel que a gente viu, né? árvores com de hash, aquela monstruos aquela coisa, aquela coisa, tá? E por que que isso aqui eu consigo validar? Eu não tenho o exet, só que se você mandar uma transação para mim, o que que eu vou pedir para você? O seu, meu novo vai pedir para você? Me manda a prova de que a moeda que você quer gastar, me manda a prova de que isso aqui está naquele exet. Aham. Aí ele vai me mandar uns restos, que é o caminho que eu preciso percorrer na na nessa numa certa árvore, uma certa árvore binária para falar: "Ah, beleza, realmente essa coisa estava nessa posição da árvore, essa e o estava nessa posição da árvore", tá? Então eu inverto o ônus do do o custo de quem tem que manter a informação. Em vez do nó que tá validando manter informação, quem tá tentando gastar a moeda é que tem que manter essa informação, entendeu? E aí quando você quiser gastar, você me prova que que tem que aquela coisa existe e eu consigo validar, tá? É experimental ainda a coisa, mas é um projeto bem bem interessante, bem interessante. Recomendo que deem uma olhada, tá? Enfim, próximo, próximo, o próximo,

vamos ver outros contratos. Vamos ver agora os contratos padrão, tá? Eu quero começar com os contratos que a gente vai considerar como legacy, legado, tá? Alguns deles a gente já até viu aqui, então vamos tentar passar relativamente rápido. O primeiro deles, que é o mais antigo de todos, é o pay to pub key. Pay to pub key. Como que é o contrato? O contrato é assim, eu boto uma pub key na pilha

e eu checo uma assinatura. O check sig. Como que é o unlock? Alguém vem e coloca uma assinatura na pilha. Então, como é que funciona a execução toda do programa? Primeiro começa no unlock, coloca a assinatura no topo, na no topo da pilha. Aí isso não vai falhar. Aí agora começa a execução do contrato. Coloca a PUB key no topo da pilha. Perceba que a Puby tá no contrato. Quem tá pagando tá dizendo: "Eu tô pagando para essa Pub". Quem consegue destravar esse? Quem consegue gastar isso aqui? Quem conseguir mostrar uma assinatura válida para aquela PUB key. Enfim, tá lá na pilha assinatura, a Puby. Optig, ele vai pegar uma PUB key do topo da pilha, uma assinatura do topo da pilha, vai usar a transação para validar. Vocês vão fazer uma coisa parecida no exercício dois, que é mexer numa assinatura válida. numa transação desse tipo aqui para criar uma outra transação válida desse tipo aqui com a mesma vocês vão fazer um explot na assinatura, tá? E aí vocês vão reparar que a mensagem que é validada lá para vocês é a transação, mas é uma versão modificada da transação. Eu não vou explicar aqui os detalhes de como é que é, mas eu deixei e também não é obrigatório, sei lá, olhar no no exercício, responder a pergunta lá, mas tem uma pergunta que é bem interessante, que é como que eu construí essa mensagem aqui que tá sendo validada pela assinatura? que lembra que a assinatura é entra na validação a PUB a assinatura e a mensagem que foi assinada. A mensagem no caso é uma versão desse cara aqui, ó, do TX1, tá? E aí eu vou deixar para vocês investigarem um pouco mais, tudo bem? Qual é o problema disso aqui? Qual o problema disso aqui? Primeiro problema ou ou meio que o mais óbvio é ter um problema de privacidade que eu tô mostrando para BQ de quem tá recebendo. Você recebe dinheiro, eu tô pagando e eu tô mostrando para quem eu tô pagando, tá? Esse é o primeiro problema. Mas tem um segundo problema que é um pouquinho mais difícil de ver aqui, que é esse esse contrato é relativamente grande, tem como a gente fazer uma coisa um pouquinho melhor, tá? que é rapidamente isso aqui foi muito, aconteceu muito em 2009, 2010 e aí não teve upgrade nenhum, tá? Alguém olhou, fala assim: "Ah, a gente podia começar a fazer assim, ó, esse contrato aqui, esse contrato aqui é um pouco mais eficiente, que é o pay to pub key hash." E ele funciona assim, o lock dele é assim, ó. Duplica o que tá no topo da pilha. Duplica o que tá no topo da pilha. Calcula o r de 160 bits daquilo que tá no topo da pilha. Coloca no topo da pilha o rub key.

Toda hora que eu tô usando esse parêntese triangular aqui é algum dado, né? Vocês estão percebendo, tá? Em vez disso, é um comando, um opcode, tá? É para tentar diferenciar. Checa se os dois dados que estão no topo da pilha são iguais.

Checa se os dois dados estão no topo da pilha são iguais. O que que tem no os dois dados no topo da pilha? No topo da pilha, na cabeça da pilha, tem o resto de alguma coisa que eu calculei no contrato. E embaixo dele tem alguma coisa, um dado que foi colocado pelo unlock script. Tão conseguindo ver?

Vocês estão comigo? Alô. Chegando lá. Todo mundo OK? Então vamos seguir. Eu tô verificando. O que que eu tô verificando aqui nesse momento, se você sabe qual é a pré-imagem deste hash. Você que tá tentando gastar essa coisa, tudo bem? Repare, ainda não cabe o contrato, tá? Mas por que que eu parei aqui? Porque eu tô testando antes de checar uma assinatura, eu tô checando se você sabe um segredo. E que, o que que é o segredo aqui nesse caso particular? Uma Pub, uma chave pública, tá? Esse tipo de contrato onde eu verifico se você sabe a pré-imagem de um hash se você sabe um segredo, tá? A gente, eu vou chamar genericamente de hash locked contract. um contrato que tá travado por um hash, tá? Esse tipo de técnica aqui a gente vai usar o tempo todo. A gente vai checar a assinatura direto, mas também vai checar se você sabe um segredo direto. Todos os outros contratos aqui envolvem essa ideia, eu esconder alguma coisa num segredo e para você conseguir gastar, precisa me mostrar o segredo aqui. O segredo é uma pub key, só que a gente vai ver já já que esse segredo pode ser várias outras coisas, tá? Seguindo, chequei se você sabe o segredo. Depois disso, eu checo a assinatura. Opt. Então tem que ter uma assinatura também lá na pilha. Como que é o unlock script disso aqui? O unlock script. Isso aqui agora eu preciso te mostrar, tá? uma assinatura que tem que tá no fundo da pilha quando chegar na execução desse cara aqui. E eu vou botar minha pub key, minha pub key no topo da pilha. Todo mundo bem? Vou executar rapidinho esse contrato. Vou executar rapidinho esse contrato, mas os tipos comecem a visualizar isso aqui sendo executado, tá? nos outros, que eu não vou ficar fazendo o tempo todo. Vou começar com a pilha vazia. Primeira coisa que eu vou fazer, vou botar uma assinatura lá no no topo da pilha, que é o que tá aqui, ó. Segunda coisa que eu vou fazer, vou botar a minha pub key no topo da pilha. Acabei, não falhei. Agora vou começar a executar o lock. Vou executar em vermelho. Duplica o topo da pilha. Então, eu dupliquei o topo da pilha. calcula o resto 160 do que tá no topo da pilha. Então vou tirar a pub, calcular o resto dela e botar o resultado no topo da pilha. Vou escrever assim, ó, H do PUB K. Aí coloca a PUBC R ali, H da Pubo da pilha, que é isso aqui que tá aqui, ó. Verifica se os dois elementos do topo da pilha são iguais. Então, vou consumir os dois elementos do da pilha, esse e esse, e vou continuar se eles são iguais. Se eles forem diferentes, eu falho porque é verify, certo? Então, consumir, vou supor que bateu consumir aqueles dois caras do topo da pilha. Cheque. Cheque a assinatura. Cheque a assinatura. pega uma pub key no topo da pilha, uma assinatura embaixo dela e usa a transação como mensagem e verifica essa coisa, tá? Então, no final aqui, se for válido, vai sobrar verdadeiro, vai sobrar um no topo da pilha e aí validei. Todo mundo entendeu a execução disso aqui? Repare que é um pouco mais sofisticado. Pergunta projeto se você tivesse tivesse ao contrário que antes desse vai falhar, tem que tá na ordem certa. Todo mundo ok? Todo mundo ok com isso? Pergunta, filho. É só no passo final. Eh, antes não tinha esse verdadeiro. Aí você tirou os dados todos e sobrou nada. Vamos dizer por definição. Esse nada é verdade. Não, não é que eu não sobrou nada, é que eu consumi os dados do topo da pilha para para o check seguir consumiu dois dados na pilha. Valor de retorno de é a execução de cada um desses opcodes é atômica. Então ele atômica no seguinte sentido. Você viu ele que tinha dois dados no topo da pilha. Aí vai executar um um operador que consome dois dados e produz um dado novo na pilha. Essa operação é atômica. Vou tirar um, tirar outro, fazer alguma conta e colocar um terceiro na pilha. Aí eu terminei aquele aquele upcode, aquele comando, aquela instrução, entendeu? Então, a pilha vazia é vazia mesmo. Pilha vazia pode estar vazia, ué, qual o problema? A pilha vazia é um estado OK pra pilha. Valor def assim, tipo, não, a pilha vazia é uma a pilha vazia. Você viu que ela, a pilha começa vazia no começo da execução? Sim, sim. Então, a gente viu os contratos, todo mundo pode gastar e nem pode gastar. Um contrato vazio. Um contrato vazio. O o contrato vai ser diz o lock script é vazio. Uai, é é one can porque aí no unlock eu boto verdadeiro, coloco aí vou botar verdadeiro no topo da pilha e eu gastou, validou. O que acontece na sua tá vazio, o programa pode estar vazio, tá? Se os dois tiverem, aí ele vai falhar porque a pilha vai terminar a execução do programa vazia, aí ele não vai validar, mas isso que você me descreveu, o unlock, o lock script tá vazio, ele não checa nada. Isso aí é um ener que expande. Eu boto um no topo da pilha e gasto na hora que eu tô gastando, boto um no topo da pilha e vou pra frente. Eu eu controlo o unlock script. Seguindo, seguindo, tá? Seguindo esses dois aqui. Repare que isso aqui é standar, só tô usando que já tava lá no script, tá? O próximo contrato é um contrato padrão, mas ele foi fruto de upgrade de um soft fork, tá? Então, presta bem atenção como é que ele funciona, porque ele é usado até hoje. Ele é o pay to script hash. A ideia foi, pô, se eu posso esconder uma pub, por que que eu não posso esconder o script, o próprio programa? que eu tenho que executar atrás de um hash.

Hã, o G dis é esconder o programa. Eu vou mostrar aqui agora para você.

Hã, seria o ganho esconder o programa. Ganho de esconder o programa. Tem dois ganhos. Primeiro porque pode ser um programa grande e aí quem tá pagando não precisa pagar a taxa por isso, só paga quem tá de Isso é essa pergunta é um pouco melhor. Deixa eu voltar um pouquinho aqui. Quem que paga a taxa de cada uma dessas dessas duas transações aqui, ó? Imagina, Pedro, que eu tô te pagando, tá? Fazendo um pagamento para você por um motivo qualquer. Eu tô te pagando. Eu fiz essa transação aqui para te pagar e aí eu criei uma saída. Quem paga a taxa dessa aqui? Eu ou você? Eu não é eu que escrevi a transação e propaguei, não foi? Eu que tenho que pagar a taxa. Tu concorda? Tu concorda com E Mas aí a pergunta é quem que quem que determina esse contrato que tá aqui? Não, não sou eu. Porque olha só aqui, olha o olha esse contrato aqui que é o mais simples deles aqui, ó. O page pub, esse primeiro, eu preciso da sua pub key. Se você não me não me forneceu sua PUB, como é que eu vou saber sua Pub? Se eu botar uma PUB que você não sabe, a chave privada, você não consegue gastar depois. Então você vai olhar e falar: "Aquele pagamento não é para mim". Então você tem que me dizer esse contrato aqui. Não sou eu que escolho o contrato. Eu faço a transção, mas não sou eu que escolho o contrato. Então o cinza que tá aqui, ó, essa informação que que eu vou ter que colocar aqui, eu não controlo. Se eu tô pagando para você, você tem você tem que me dizer que contrato é esse, ou pelo menos qual é o tipo de contrato e me dá os dados. Me dá naquele exemplo a Pubki. Mas eu aceito se você me outra alternativa é me dá o contrato inteiro, entendeu? E aí o primeiro problema que é se você me der um contrato gigante, quem vai pagar a taxa disso? Eu por um contrato que você quer que seja grande, não, eu. Eu só quero te pagar e embora. Entendeu? Então, eu tenho um mecanismo de esconder o contrato, por exemplo, atrás de um hash vai me permitir aqui colocar só um hash bem menos dados e eu deixo para você pagar o a taxa quando você tiver que mostrar o o hash aqui, o programa aqui. Mas aí você não por que que você tá usando um teste não, por exemplo, outros eh de como é que zipagem. zipagem é tipo assim alguma coisa de compressão, outros algumas, porque aí tem uma outra por que que eu uso, por que que eu boto escondo isso atrás de um hash e não de um zip, por exemplo, um algoritmo de compressão de dados normal primeiro, porque isso aqui praticamente não comprime aqueles opcodes ali, eles não, eu não escrevo o texto op e opt, eu escrevo bytes. Cada um daquele é um byte já bem determinados, tá? Então assim, a compressibilidade desse negócio é baixíssima, na prática não vai funcionar. Mas tem um outro aspecto que o que usar um hash me dá, que usar outras coisas não me dá, que é o seguinte, se eu esconder atrás, imagina que eu falo para você, me dá o contrato e você me dá só o resto do contrato, eu que tô te pagando, eu nem tô vendo que contrato é esse. E aí você melhora sua privacidade, porque eu tô te pagando e eu nem sei o que que eu tô botando ali. Eu só tô falando o que você me mandou fazer. Você não precisa nem me mostrar o contrato. Você só mostra o contrato na hora que você for provar que você precisa, que você é o dono daquilo para gastar, mas só naquele momento e não antes. Entendeu? Essa é uma segunda vantagem de privacidade. Ninguém consegue. Claro que isso coloca um burden a mais em você, né? Um um um isso gera custo para você agora que tá recebendo. Por quê? Porque se você esconder o hash, o contrato atrás do hash, você precisa manter aquele contrato com você. Se você perder o contrato, é a mesma, você não consegue mais gastar porque você não vai, você não vai ter o segredo mais para mostrar na hora de validar, entendeu? A gente vai ver aqui agora. A tua wallet precisa guardar mais dados e o teu backup é mais complexo. Sim, mas tudo não tem almoço grátis, né? Vamos lá. Como é que é o como é que é o pay to script hash? Tá? Quem quiser ver nos documentos depois o a spec dele tá no documento chama BIP BIP 16 e foi implementado em 2012. É bem antigo, mas bastante usado hoje, tá? Bastante usado hoje. Ele é bem útil. Ele é assim, o lock script é assim. pega o que tá no topo da pilha, calcula o resto 160 dele, coloca um script no topo da pilha. Mas olha a o detalhe, tá vendo que eu tô botando o script entre o o esse parêntese triangular, né? Como é que é o nome desse parêntese aí? Maior, igual maior ou igual, sei lá, essas é parênteses para mim um parêntese, tá? Hm. É o parêntese HTML. Sim, que seja isso aqui. Eu tô usando essa anotação para dizer que isso aqui não vai ser interpretado como um programa, vai ser interpretado como dados. Toda hora que você olhar, que eu escrever isso aqui, quer dizer é dados que estão entrando lá na pilha, numa posição na pilha, tá? Mas eu tô escrevendo que isso aqui é um script. Por quê? Porque em algum momento vai ser parseado, mais vai ser interpretado o que tá aqui dentro num segundo momento. Mas em princípio são bytes que estão lá, tá? Você pode fazer um programa Python? Não, tem que você vai ver que não pode ser um programa em qualquer linguagem, tem que ser um programa na própria linguagem que tá aqui.

Calma aí, mas calma. Vamos lá. Você vai ver a semântica aqui. Eu vou botar o hash do script aqui, não é o script. Vou botar o rash do script aqui, tá? E aí eu vou fazer op e repar que eu nem checo assinatura, nem checo mais nada. Só cheque se você sabe o segredo ou não. Como é que é o unlock? O unlock eu vou colocar

dados blá blá blá que forem necessários pro para validar um um script, porque esse script agora vocês vão ver que é arbitrário, né? Então eu não sei em princípio o que que você vai precisar colocar de dados ali, tá? Por exemplo, aqui eu precisei colocar uma assinatura e uma pub key de dados. Aqui eu precisei colocar uma assinatura como dados, tá? Aqui eu não sei em princípio porque eu não sei qual script que vai entrar aqui. Eu vou mostrar um exemplo específico de multisig para vocês verem como é que é multig, tá? Mas em princípio eu não sei o que que vai entrar aqui, mas eu vou botando os dados para entrar na pilha. E a última coisa que eu vou botar na pilha é o script. O script que eu quero que seja de fato executado. Tudo bem? O que que os nós, lega-se, os nós antes do upgrade, o que que eles vão fazer? Eles vão colocar os dados na pilha,

dado zero na pilha, dado um na pilha, assim por diante, o que tiver aqui. E eles vão botar o script na pilha. Só que para eles não é um script, para eles são bytes. É uma string de bytes como outra qualquer. Um programa de computador é uma string de bytes como outra qualquer, só que tem um interpretador que sabe que aquilo é um programa e interpreta aquilo, né? Aqui nesse caso ele não sabe que é um programa. Aí eu vou fazer r do que tá no topo da pilha. Então vou calcular o hash desse script. Vou colocar um hash.

Vou colocar o hash

do script que tá no contrato no topo da pilha. Vou consumir dois dados do topo da pilha e vou checar se eles são iguais. Então vou consumir aqui. Ba bá. Vou consumir aqui. Beleza? Se for um no legacy antes do upgrade, ele vai parar aqui. Se tiver dados aqui, opa, se tiver dados aqui na pilha e o topo da pilha não for falso, isso aqui vai validar. É só você cuidar para não ficar falso ali no topo da pilha pro pro nó antigo. E aí ele validou. Repara que ele não checou assinatura, não checou mais nada. Ele só sa checou. Você sabe o segredo ou não? É um hash locked contract também. os nós novos, que que eles, os nós que fizeram o upgrade dessa especificação, o que que eles vão fazer? Eles vão fazer exatamente o que acabou de acontecer. Só que eles, na hora que ele vê lá o interpretador, esse padrão específico aqui de bytes, op 160, um hash de 20 bytes op equal, quando ele vê esse padrão, se aqui não falhou a execução do script até agora, o que que ele vai fazer? Ele vai pegar esse script aqui, ó, que ele sabe que tá aqui, vai parar ele, vai interpretar os opcodes, blá blá blá, vai interpretar esses up codes e vai executar com o estado da pilha que sobrou aqui. Então ele continua fazendo mais coisas que eventualmente pode invalidar a transação. Por que que são soft fork? Por que que são soft fork? Os nós antigos estão vendo uma coisa válida. Os nós novos estão vendo uma coisa que era válida, mas que agora pode ter se tornado inválida. Ele checa mais coisas, ele tá com uma regra mais restritiva. Isso é o softwk. Professor, eh, e se por acaso eu quiser agora fazer um um uma moeda que o scpt dela é só com hash não has scpt. Eu só quero ver se tá o resto do dado qual que você passar. Ele vai sempre tentar interpretar esse nesse caso aqui. Sim, mas você pode usar outro r aqui porque tem chá 256, tem hash 2560. É esse padrão exatamente que tá aqui. É esse exato padrão que tá aqui. Se você só checar um um hash se você sabe um segredo sem disparar essa regra, você usa outro hash que tem lá no script. Se for esse padrão, é esse. Isso vai acontecer. E a esmagadora maioria dos nossos hoje vai executar isso aqui. Eles estão upgraded. Todo mundo OK? Vamos ver um exemplo de script que eu posso esconder ali, tá? E aí você vai ver uma vantagem além de eu esconder o script, que é isso aqui, ó, tem 20 bytes de dados. Aqui tem 1 byte e aqui tem 1 byte. Então esse script todo aqui tem 22 bytes. 22 bytes é o que você vai pagar na de taxa lá, o equivalente a 22 bytes. E eu vou mostrar um skit para vocês que tem tem ã 32 + 32 + 32 já dá 90 e tantos bytes. Mais duas assinaturas. Cada assinatura tem cerca de 70 bytes, que dá mais 280 bytes, já dá 300 e cacetada bytes aí e mais uns outros, mais uns outros bytes. Então, já o script vai dizer o que eu vou mostrar agora para vocês, que não é um script complicado. O script já tem 300 e cacetada bytes. Então, quem quem vai pagar o o custo desses 300 bytes não é mais quem tá pagando, é quem tá querendo gastar. Repara que eu tô jogando uma coisa pro outro lado, tá? Oi. SCP você já provou que você é o nome daquela moeda. Isso não. Deixa eu dar um exemplo de script de script que eu poderia botar aqui, ó. Eu posso botar qualquer coisa, tá? Mas deixa eu dar um exemplo bem concreto. Um um exemplo bem concreto. O exemplo que eu vou usar é uma multissig 2 de3.

Que que é uma multissig? é eu requerer mais de uma assinatura para para autorizar um gasto. Então, por exemplo, e o que que significa dois de três? Significa que eu preciso de duas assinaturas válidas para um conjunto de três pubs, para um universo de três pubs, tá? Então eu tenho a Pub, que pode ser da pessoa um, tem a Puby 2, pode ser da pessoa dois, tem uma PUB 3, que pode ser da pessoa três, ou que pode ser a mesma pessoa, pode ser eu, a Pubki, que eu guardo a chave privada no meu telefone, uma outra PUB que a chave privada tá no meu computador em casa e a Pub 3, uma chave privada que tá escrita num papel, num cofre, num banco, por exemplo. Hã? Fa uma autenticação, tipo um to factor authenticate que eu tô fazendo para mim mesmo, para dificultar alguém me roubar coisas. Tudo bem? Tudo que vocês verem aqui, pessoa um, pessoa dois, pessoa três, não precisa ser necessariamente pessoas de fato diferente. Pode você em em situações diferentes, como eu acabei de descrever. É o dispositivo tal, o outro dispositivo tal e o outro dispositivo que eu guardo não sei aonde mais seguro. Então, se alguém quiser roubar meus fundos, ele tem que roubar dois desses fatores aqui. Agora, não só um. Não basta roubar meu telefone na rua, não basta invadir minha casa e pegar o minha hard wallet ou levar meu computador. Ele precisa fazer isso e e fazer mais alguma outra coisa, entendeu? Então vamos lá. Exemplo de tipo de coisa. O que que significa o dois de três? Significa que eu posso gastar com uma assinatura da chave um e da chave dois,

que eu vou chamar de S12. Eu posso gastar com a assinatura do S1 mais a assinatura do S3, vou chamar assim, mais S2. São duas assinaturas, tá? Separadas. Ou esse outro conjuntinho aqui, ó. assinatura do da chave dois mais a assinatura da chave três. Eu tenho três possibilidades de gasto aqui no caso e tem que ser exatamente dois. Se eu mostrar três, vai falhar. Como eu vou most enfim, mas se eu se eu consigo três, eu consigo dois. Se eu sei fazer três, eu sei fazer dois. Todo mundo entendeu o que que é essa multig aqui? extremamente usado também pra gente fazer tanto isso que eu descrevi agora, que é uma coisa mais óbvia, que é tentar fazer um sistema de proteção de fundos, eu mesmo me protegendo, quanto eu fazer coisas do tipo assim, ah, vamos fazer o, sei lá, isso aqui é o caixa de uma empresa, mediador ou o mediador que vai mediar um empréstimo, esse tipo de coisa, entendeu? Ah, tem que ter quase como se fosse uma conta compartilhada com mais de pessoas. faz bastante sentido em várias situações, tá? Quanto para a gente criar outros protocolos. Por exemplo, quando a gente fala em Lightning e outros protocolos, em princípio, a gente tá falando de compartilhamento da UTSO. A UTXO vai ter mais de um dono. Como é que eu A oxo tem mais de um dono? Exigindo que mais de uma mais de uma assinatura para gastar aquela mesma UTXO. É o mecanismo básico pra gente criar outros protocolos, tá? Então vai lá. Como que é o script que eu botaria aqui, ó? Aqui, ó, tá no azulzinho. Esse script vai ser assim, ó. Ele vai ser assim. Cadê o meu exemplo? O script vai ser assim.

Coloca zero no topo da pilha, que vai ficar embaixo no final, né?

Coloca zero. Coloca a assinatura um no topo da pilha. Coloca a segunda assinatura no topo da pilha. Coloca dois. Esse dois é do quórum das assinaturas. Se fosse três aqui ia aparecer três. Bota as três assinaturas e bota três e assim por diante. Agora vai vir as pub keys. O zero é um bug. Deixa. Vamos lá. Já já comento depois. Mas vai ter que ter esse cara aí, tá? Vamos lá. Segue o balha aqui. Agora vem as pub keys. Vou botar a Pub key 1, a Pub key 2, a Pub key 3. Aqui eu tenho que mostrar todas as pub keys, não tem jeito, tá? Não, nesse nesse tipo de contrato eu tenho que mostrar todos os PUBG keys forem sem pubs, eu tenho que botar lá sem pubs, mesmo que elas não estejam participando das assinaturas, tem que ir lá e mostrar elas. O que é um problema quando essa multisí é muito envolve muita pub key. Tem coisas mais espertas que a gente pode fazer hoje, tá? Mas a gente chega lá. Então vocês vão ver no problemas e vão ver a motivação dos upgrades que foram aparecendo, né? Tá? Aí eu boto aqui três, que é o total de chaves. É esse dois de três, tá aqui, eu que vou dizer. E aí eu boto o operador, que é o op check.

Multisig. Qual que é a semântica do check multisig?

Lê a pilha, tá? Isso aqui tá no topo da pilha. Isso aqui tá no fundo da pilha. A primeira coisa que entra, entra e as coisas vão entrando em cima, né? Tá? Então, beleza. O que que o check muito sig faz? Ele pega o que tá no topo da pilha e vê e analisa aqui. Ah, é três. Então eu preciso pegar três para biquis da pilha. Então ele vai pegar essa, essa e essa e ele sabe que aquilo são as pubs. Aí a próxima coisa que ele vai pegar é um número que diz para ele quantas assinaturas eu tenho que checar. Aqui é dois. Aí ele pega assinatura. Assinatura. Em princípio, esse cara já tem toda a informação que ele precisa. Toda a informação que ele precisa. E aí a ideia é que ele valida aquelas duas assinaturas contra aquelas três bobys, tá? Aí vai validando, vai testando. Não é muito difícil de fazer de implementar isso. Professor, e aquele zero que foi a pergunta que você fez, para que que serve aquele zero? Aquele zero foi um bug do Satoshi. Na hora que o Satos implementou esse esse cara aqui, ó, esse cara aqui, ele fez tem um tinha um loop lá dentro e ele errou por um aquele loop. Se você já escrever no fó em C, é em C mais mais se escrever um for em C e aí sem querer você bota um menor igual quando você queria dizer menor e aí a coisa roda uma vez a mais. Foi exatamente o que aconteceu aqui. Foi exatamente o que aconteceu aqui. Ele errou por um. O check multig consome um dado a mais da pilha do que deveria. Então a gente se viu obrigado a botar um dado a mais na pilha só para não falhar a execução do do daquele opcode. Esse zero não serve para nada, é só para por causa do bug. É muito consolador saber que o sapot também com todo mundo erra, tá? Todo mundo erra. É esse também é interessante pra questão dos, mesmo que seja soft for, você tem soft for, você tem a questão que o outro ele olharia e e aceitaria independente do contrato, mas com esse zero ele vai neegar. É porque mas esse zero aqui ele não vai servir para nada, ele vai ser consumido, mas não vai ser usado na conta. Então posso botar 1, dois, três, pode botar qualquer número na conta do script. Mas se você não ler o script, ele vai ler o zero, vai detar falso. Não, não, não, não, não, não. Se eu não ler o script, se eu isso aqui, eu parciei o script. Mas na hora que tá aqui, ó, aqui eu não vou parar isso. Eu vou ver isso aqui, ó, tudo como um blocão de bytes. E eu não vou, eu não vou interpretar, ah, o primeiro byte é um zero, o segundo byte tem a ver com uma assinatura, o terceiro byte tem a ver com Eu não vou fazer isso aqui, ó, nesse momento aqui. Eu só vou fazer isso depois que validou aquela primeira passada. E eu chequei, ah, tá, caiu na regra especial. Então, vamos lá ver. Então, essa última coisa é um script. O que eu tô mostrando para você é que script, um exemplo de script que pode estar ali, entendeu? Um exemplo de script que pode tá ali, tá? Esse aqui é um exemplo de script. Esse script aqui é meio meio meio boboca, tá? Que eu tô mostrando para vocês. Ele é meio boboca. Por quê? Porque as assinaturas já estão aqui.

Que que quer dizer? Quer dizer que na hora que eu fiz o lock, na hora que eu travei os fundos, eu preciso calcular o hash, o script primeiro para poder calcular o hash e colocar no contrato. Aqueles que eu mostrei para vocês a boboca. Por quê? Porque as o o o script já tá pré-assinado, então ele é um um dois de três fake. Assim, é só para eu mostrar alguma coisa grande para vocês, tá? Como é que seria mais interessante aqui no caso seria eu colocar lá no script, tá? Esse pedaço aqui, ó. Deixa eu apagar aqui. Seria eu colocar no script esse pedaço aqui, esse pedaço aqui, sem as assinaturas e coletar as as assinaturas aqui, ó, com o data que eu tenho que colocar, que eu posso botar antes e preenchendo a pilha antes. Isso seria mais um pouco mais esperto. E é assim que de fato é feito. Tudo bem? Porque aí permite eu colocar assinaturas diferentes ali, tá? Agora, por que que eu quis mostrar isso também? Porque em vários momentos vai fazer sentido a gente colocar coisas pré-assinadas, travar coisas pré-assinadas, falar assim, ó, tá aqui tipo um cheque pré-datado assim, pré-assinado. Tá aqui o cheque, toma, já tá assinado, mas não gasta agora. Segura aí, guarda isso aí para depois. Faz bastante sentido querer fazer isso. Tudo bem? Vai ficar um pouco mais claro à medida que a gente for falando de outros protocolos. Todo mundo OK com isso? Todo mundo OK com isso? Próximo. Esses são os três contratos padrão que existiam até 2012, tá? Repare que esse cara aqui, ó, resolve um problema. Esse cara aqui, o P script, resolve um problema de você propagar transações não standar. Por quê? Porque esse cara é standar e ele esconde os scripts. Então eu posso escrever um script completamente doido, do jeito que eu quiser, gigante, do jeito que eu quiser, que não propagaria, não seria standard, que seria seriam a princípio só esses dois aqui até aquele momento, tá? Mas eu escondo ele e eu atrás de uma transação que é padrão e ela vai propagar normal na rede. Todo mundo bem. Por isso que esse negócio de standndar ou não standar não tem, você tem sempre ter um mecanismo de embutir alguma coisa não padrão dentro de uma transação padrão e propagar na rede e confirmar que é o o page e o script hash. Todo mundo bem, tá? O próximos dois que a gente vai falar, eles vieram num upgrade que chama Segwich, tá? Segwich, que que a spec deles são bips 141, 43 e 44. Aí você lê lá a especificação, tá? Antes de eu mostrar o que que é importante entender do Seg, o Sege tá fazendo um upgrade nesse tipo de transação, nesse tipo de contrato, e ele tá fazendo um upgrade nesse tipo de contrato, tá? Qual é? Ele tá tentando resolver dois problemas, na verdade vários problemas, tá? Mas assim, dois problemas principais, no meu entender. O primeiro deles é o que vocês vão lidar lá na na no assignment to que é eu consigo ter uma transação e eu consigo mexer nas assinaturas da transação. Mesmo que eu não saiba a chave privada, eu consigo mexer na assinatura transação, criar uma outra transação válida, mas que tem um um ID diferente. E isso aí é um problema. Por que que isso é um problema? Porque na hora que a gente tá fazendo esse esquema de transações pré-assinadas que eu acabei de comentar para fazer outros protocolos, em boa medida, o que a gente vai monitorar é: "Ah, eu tenho TX ID de uma transação já e aí eu vou ficar monitorando se uma a minha outra parte, a minha contraparte no protocolo, se ele não tá usando essa TX ID, se ele não propagou isso, eu vou ficar, eu preciso dar essa informação e ficar monitorando esse aquele ID. da aquela transação com aquele ID, se ela aparece na blockchain ou não, porque na hora que ela aparece em geral esses protocolos envolvem eu ter que fazer alguma coisa, eu tenho um prazo para fazer alguma coisa. A maioria desses protocolos envolve um prazo para fazer alguma coisa, tá? E aí se a pessoa me dá uma transação e ela consegue criar uma outra válida com ID diferente, ela consegue me enganar porque ela me dá a transação, eu fico monitorando aquele ID. Ela vai lá criar outra válida. e que faz a mesma coisa com os mesmos contratos e ti propaga. Só que eu não consigo saber porque eu não sei aquele aquele outro ID que de fato vai paraa blockchain, tá? E aí eu fico cego nesses protocolos. Isso é um big problema, tá? A gente vai ver um pouco mais paraa frente. Isso é um big problema, tá? Esse é o primeiro problema que o Segwich veio para resolver, tá? Onde que nasce esse problema? Esse problema a gente chama de maleabilidade. Maleabilidade consumo malear, né? mexer na transação e ela continuar válida, tá? Onde que nasce o problema? O problema nasce aqui, ó, no fato de ter assinatura na transação. E essa assinatura tá entrando no cálculo do ID da transação. Repare que aqui tá entrando uma assinatura, aqui tá entrando uma assinatura, aqui no script hash entra a assinatura. Ô, perdão, aqui no data em geral entra assinaturas. E aí vocês vão calcular a assinatura, vocês vão ver que elas são, ela tem um que é aleatório, tanto shin quanto SCDSA. Vocês vão trabalhar com SDSA, que é o o que se fazia até recentemente. E ela tem uma componente aleatória. E se a componente aleatória, quer dizer que eu consigo tirar uma outra assinatura válida que que é imprevisível. a outra parte não consegue saber de antemão. Não só isso, vocês vão ver lá que eu consigo mexer na assinatura até sem saber a chave, a chave privada. Se calcular outra assinatura a partir de uma de uma primeira, tá? Vocês vão fazer isso. Isso é uma outra forma de maleabilidade. O seg veio para principalmente para resolver esse problema. E como é que você resolve esse problema?

Tem que tirar as assinaturas daqui. As assinaturas não podem entrar mais no cálculo do ID da transação. É, essa é a ideia básica. Preciso tirar as assinaturas daqui e jogar para outro lugar, colocar em outro lugar. Essa é a ideia básica do Seg. Vai ter um campo adicional nas transações que a gente vai chamar de witness. O witness em na linguagem de criptografia quer dizer assinatura. É quase um sinônimo, tá? quase um sinônimo. Eu vou chamar de witness e eu vou jogar essas assinaturas para lá. Tudo bem? Tá. Só que a gente vai ver, eu não quero permitir muita alteração na coisa de novo. Eu quero fazer alguma coisa para resolver um problema, mas a gente abre um monte de buraco fazendo, fazendo esse tipo de alteração. Já vou mostrar como é que como é que é o seget, tá? Então o que que se pensou? Vamos fazer esse mecanismo novo, mas ele só vai funcionar para esse contrato e esse contrato especificamente. Ponto final. E aí a ideia é que eu tenho um contrato que é para pagamentos, vamos chamar assim, de simples, que é o page public, é meio que de um para uma pessoa para outra. E eu tenho um contrato genérico que eu posso esconder um script que vai ser o P to script hash que um contrato mais flexível. Tudo bem? Dito isso, como que é o segu? Vamos lá. E e acompanha comigo aqui, pensa comigo aqui, tá? Porque o Seg é um bicho meio complicado. Como que é a transação, a transação de Bitcoin, a transção legacy, tá? Porque eu não posso quebrar os nós antigos, eu quero fazer um softwk, lembra disso? Os nós antigos vão receber as transações do jeito que eles já sabiam antes, tá? Eu não posso adicionar campos necessariamente, eu tenho que tomar um cuidado. Então vamos lá. Como é que é a transação? Eu tenho um campo de versão que tem exatamente 4 bytes. Eu tenho um contador, eu vou chamar assim de in count.

Aí o depois desses 4 bytes vem um um byte ou alguns bytes que é um número dizendo quantas entradas tem nessa transação. Aí vem a lista de entradas, tá? Cada uma das entradas tem um TX ID, um index, o script,

que é onde normalmente aparece assinaturas. Tem o sequence.

Aí vai repetir para esse esse padrão vai repetindo para sei lá se são três entradas vai ter de index script sigue de index vai repetindo pá uma para cada entrada. Depois disso vem um contador de quantas saídas tem aí são alguns bytes ali. É porque é um número variável de bytes. Não quero entrar nesse detalhe, mas enfim, tem alguns bytes ali para dizer quantas saídas tem. Cada saída tem um amount. que tem 64 bits e tem o script

e tem o script. Aí repete amount script, amount script, quantas forem necessárias, quantas saídas tiverem. E por fim tem o lock time, que se eu não me engano são 32 bits. Posso estar enganado, mas acho que é 32 bits mesmo, tá? É isso aí, a transação. Aí o que que o Seg fez? A primeira modificação que vai acontecer é, a gente vai botar alguns campos a mais aqui. A gente vai botar coisas aqui, tá? Entre o campo de versão e o contador, eu vou botar dois bytes. O primeiro deles a gente vai chamar de de marker, um marcador. Esse azul tá visível aí para vocês? Tá um marcador que é sempre zero, o byte zero. E eu vou botar uma flag que é sempre um é um byte. é fixo, tá? O marcador ele serve para indicar que essa transação é uma transação seg, tá? O flag é um número de versão que é para na na hora que a gente quiser fazer um upgrade, botar outros campos, a gente muda o flag e aí a gente consegue fazer algum começa a ter um pouco mais de flexibilidade, tá? Os nós antigos, eles eles vêm esse zero aqui, ó. A primeira vem o número de versão, depois vem esse zero. Os nós antigos, a primeira coisa que eles vem esse zero. Todo mundo vai ver esse zero. Zero para eles é o contador de entradas. Ou seja, para eles é como se a entrada, essa transção tivesse zero entradas. Só que zero entradas quer dizer que eu não tenho dinheiro para gastar, né? E isso daí é uma transção inválida. Sempre foi. Pergunta, ainda não mostrei todos os campos. Pergunta: "Como é que isso aqui pode ser um soft fork?

Claramente eu tô quebrando os nós antigos, tá? Agora fazendo isso aqui. O que eu tô perguntando para vocês agora é difícil. Demorou, demorou alguns meses até alguém bolar uma solução. Vamos ver se vai. É uma é uma solução ingênua.

Chuta aí alguma coisa. Lembra que eu não posso mudar a regra dos nós antigos, eu só posso mudar a regra dos nós novos.

Quê? Não, vou botar isso aí aí mesmo, do jeito que eu tô mostrando para você. vai entrar ali um byte, um byte zero ali no meio depois do version.

Vou vou para vou frasear de uma forma que talvez fique mais fácil a solução. Se o nó antigo vê isso aí, ele vai interpretar esse zero como sendo zero entradas e ele vai considerar isso inválido. Como que eu resolvo? interpretação. Eu não posso mudar a reinterpretação do nó antigo, só posso mudar a interpretação do nó novo. Vou repetir. Se o nó antigo v zero, ele vai interpretar essa parada como zero entradas vai ser inválido. Só você não deixar ele ver. É, fala alto para todo mundo. É só não deixar ele ver. É só eu não mostrar isso pro nó antigo. Essa sacada demorou alguns meses para para se perceber. É meio óbvio que eu tô induzindo você a pensar nisso, né? Como que eu faço para não mostrar esse zero para ele? Eu falei para vocês que eram bip 141, 43 e 44. São três documentos. Um deles, que é o 141, tá explicando isso aqui, os campos novos. Um dos outros documentos vai explicar as mudanças na camada de rede, quais as mensagens eu mando entre os nós. A gente não comentou sobre isso, mas eu tenho um nó aqui e eu tenho outro nó aqui. Quando os nós se conectam, eles vão abrir um um socket TCP. Aí tem outros protocolos, mas em princípio é TCP. Eu abro o socket aqui com com outro nó. Aí eu mando um pacote, um pacotinho de dados, uma mensagem que é uma mensagem que a gente chama de versão. E nessa versão tem campos que identificam o que eu sei fazer na rede.

Tem lá umas flags que em princípio não serviam para nada, não eram usadas para nada. Aí o que que se pensou? Vamos adicionar uma flag nesse nesse campo aí que diz que aquele nó é um nó seg. Então tem um bit lá que o nó que tá abrindo a conexão fala: "Eu sou seguit". Aí ele bota um bit lá, bit um. O nó que tá sendo conectado, ele responde com um e aí depois ele manda um pacotinho, a uma mensagem de versão também respondendo, dizendo o que que ele sabe fazer. E ele pode botar o bit, eu sei seg ou eu não sei se aí esse cara aqui responde com um. E aí isso aqui encerra o o handshake. Esses dois caras vão considerar conectados a partir de agora e eles vão poder trocar outras mensagens. Que que se pensou? Vamos no número de versão aqui, ó, na mensagem de versão anunciar que a gente é ceg ou não. Por quê? Porque o nó antigo ele vai ver aquele um bit e ele para ele que não significa nada. O nó novo ele sabe que ele tá falando com outro nó novo que foi que sabe a regra nova. E aí quando eu for mandar, então repare, na hora que eu vou mandar uma transação para esse nó aqui, eu sei se ele sabe a regra nova ou não. Por quê? Porque a gente a gente trocou os o as nossas capacidades no início do protocolo. Repare que isso é camada de rede, isso não é protocolo de consenso, tá? Mas eu sei se ele sabe a regra nova ou não. E aí, qual é qual é uma das coisas que se fez? Se eu tô mandando uma transação para um nó que é que é upgraded, eu mando eu mando isso aqui, ó. Eu mando com isso aqui. Se eu tô mandando a transação para um nó que não sabe essa regra nova, eu não mando isso aqui, nem a flag, nem o marcador, nem a flag, porque são informações novas. Ele vai ver o que ele já via antes, só que ele vai conseguir ser válido de forma. A gente já vai ver se ele vai conseguir validar ou não. Tudo bem? Isso, mas isso é parte do do da dificuldade que é fazer a esquema sem quebrar o a regra, sem quebrar os nós antigos, tá? Todo mundo entendeu isso? Os nós segot vem mais informação do que os nós não seguot. Tudo bem? Próxima coisa que a gente vai adicionar é bem aqui, ó. Antes do lock time e depois das saídas, a gente vai adicionar um campo que a gente chama de witness. A witness é uma lista. É uma lista. Ele vai ter um elemento para cada entrada. Cada entrada da transação vai ter um elemento nessa witness. Todo mundo bem? Se não tiver nenhuma entrada que seja seguit ali naquela transação, eu não preciso nem nem botar nada na witness, tá? Mas hoje em dia é raríssimo isso acontecer. Mas vai ter uma entrada, um uma lista, um elemento para cada uma das entradas. E na ordem, né? Entrada zero é o primeiro, entrada um é o segundo e tal. E o que que tem cada um desses elementos? Cada um desses carinhas aqui, o que que tem aqui dentro? Esses carinhas t um contador dizendo quantos itens tem aqui dentro. Tem uma lista também, tá? Uma lista de listas. Tem um contador dizendo, tem tantos, tem tantos itens para você pegar daqui. E aí tem uns itens, eu vou chamar aqui de data. Então tem o data, o elemento zero, tem o elemento um e assim por diante, quantos tiverem marcados aí. Todo mundo bem? E qual é a semântica dessa coisa aqui? Qual é a semântica dessa coisa aqui? A gente viu como é que executava o script antes, que era executa o unlock, executa o que tá aqui no destravamento, depois executa o que o contrato que tá no locking script, na saída que eu tô tentando gastar. Como é que vai ser a regra nova? Antes de fazer isso, pega esses dados aqui, ó, que estão na witness daquela entrada que eu tô validando, que eu vou rodar o contrato, e vai colocando na pilha, na ordem, porque elas aparecem. Então, primeiro eu vou botar isso aqui na pilha, depois vou botar isso aqui na pilha, tá? Tá, tá. Então, eu vou pré-preencher a pilha. Terminei de fazer isso aí, eu faço o que eu já fazia antes. Roda o o

unlock script, roda o lock script. Só que agora o unlock script já começa com uma pilha pré-preenchida que veio das itens, tá vendo? Então aqui tem uma pilha para executar, começar a execução do programa. Todo mundo OK? Todo mundo bem, tá? O que que na prática a gente vai fazer? Ora, esses dados aqui, ó, esses dados aqui que eu botava no começo do unlock script, eu vou mover para witness agora. É, é isso que a gente vai fazer. Em vez de botar aqui no no programa, eu vou botar lá no Witness. Só mexi, troquei de lugar uma coisa com a outra. Por que que isso aqui evita? Por que que isso aqui evita eu poder mexer no identificador da transação mexendo na assinatura? Aí tá especificado também num outro documento que é o seguinte: eu não posso mudar o cálculo do identificador das transações porque senão quebra os nós antigos, porque eles não vem as informações azuis, eles só vem as informações pretas. Isso quer dizer que o TX ID da transação

vai ser o resto disso aqui, ó, sem isso, sem isso, mesmo que seja uma transação segu. E aí, repare, os assinaturas, que eram os dados problemáticos, antes elas ficavam aqui, ó, faziam parte do cálculo do ID. Agora elas vão ficar aqui e elas não vão mais fazer parte do cálculo do ID. E aí eu conerto esse problema de a assinatura poder mexer e mudar o TX ID, mas agora a assinatura não entra mais no cálculo do TX ID, não tem o que mexer no TXID mais. Todos os outros campos são meio meio que fixo, eu não tenho liberdade para mexer. É assim que foi resolvido, tá? Isso introduz umas outros problemas que é o o TX ID, ele é um commitment, tá? Ele é um é uma é uma pré-imagem, é onh, né? Tá? E lembra que a gente usava, a gente usa o TX aí para calcular a Mercur Root e calcular a prova de trabalho. Agora eu tô tirando as assinaturas do cálculo da prova de trabalho, fazendo isso aqui que eu tô mostrando para vocês. Isso é um problema. Então tem um dos documentos lá também que vai falar assim: "Então, tá bom, como é que a gente vai resolver? Vamos definir um novo, um segundo ID que a gente vai chamar de W TX ID, que é o TX ID com os dados da Wens, que é os dados, que é botar isso aqui tudo no resto, ó, quer botar tudo. E aí esses dados aqui é tudo. Eu posso estar falando uma besteira aqui agora, não lembro se é tudo ou se é só as witness. Tem que checar ali, tá? Mas é o ID com envolvendo os dados da Ese aqui a gente vai obrigar a construir uma uma outra microot e botar na Coinbase Transaction, tá? Então tem uma regra lá adicional de dados que tem que entrar na Coinbase transaction e esses WTXID vão entrar como commitment lá para você não não puder não poder ficar mexendo nas assinaturas depois que o bloco tá confirmado, porque senão você poderia mexer na assinatura depois de confirmar o bloco deal para você poder cobrir a witness com a prova de trabalho, porque senão, qual o problema que a gente geraria? Eu poderia mexer numa transação depois dela tá confirmada no bloco, entendeu?

Senão eu poderia fazer isso e eu preciso resolver esse problema. Então, repara que tem um monte de peça que eu preciso amarrar para fazer uma mexida no protocolo. E e por que que eu tô mostrando esse monte de detalhe para vocês? para mostrar que esse tipo de sistema aqui de consenso, mexer um uma vírgula em algum lugar potencialmente quebra a parada em vários lugares. Precisa consertar, fazer remeno em um monte de lugares e à medida que você vai tentando fazer mais disso, mais disso, vai ficando mais difícil de fazer mais disso, tá? Obviamente as pessoas que estão fazendo isso, elas são espertas, elas vão olhando e falando: "Porra, quanto mais a gente mexer, mais difícil fica no futuro de mexer de novo, tá? Então o que que a gente vai fazendo? Vai deixando para trás margem de flexibilidade. Então, por exemplo, para que que serve essa flag? serve pra gente poder adicionar novos campos sem quebrar o os nós que porque no Segut os nós legacy dos primeiros caras eles não vêm os dados azuis. Os nossos seg eles vêm, mas eles tem uma regra que é se o a flag for diferente de um, eu vou validar e pronto. Para mim é válido, independente do que do que tiver aí dentro e só vou deixar passar. Por quê? Porque aí a gente pode usar isso aí no no futuro, mudando aquilo lá, botando outros campos aqui e eu não quebro mais a lógica dos nós dos nossos seg. Tranquilo? a gente vai ver que tem mais disso aí em outros lugares. Então a gente vai adicionando também mecanismo de upgrade no futuro. Diga o estaria pela prova de trabalho, já você estaria fazendo um cálculo ID e não teria como ser mudado. Não, não, não, não. No o TX ID, o TX ID tá entrando essa informação, não tá entrando na witness não. Sim, mas tipo assim, você já fez, já calculou o block tá válido. Como é que você mudaria na Witness e mudaria? Uai, é só eu assinar uma outra assinatura e colocar aqui no meu, no lugar. Se você calculasse o TL, tipo, estaria Não, não, não, não, não, não, não, não, você não tá entendendo. Eu posso depois mexer na assinatura, trocar uma assinatura que tá aqui dentro, só que o TX ID é resto do que tá aqui, ó, na parte preta. Eu não mexi nos dados que estão na parte preta, ele continua com o mesmo TX ID. Então, eu consigo gerar uma outra transação com o mesmo TX ID, só que com uma outra assinatura na Witness. O problema não é gerar mais de uma mais de uma coisa com a mesmo TX ID. O problema é gerar TX IDs diferentes pra mesma coisa, pra mesma semântica, pro mesmo pagamento. Acho que não ficou claro como é que você geraria assinatura se aí não tá sendo calculada. Não entendi. F como é que você geria isso se a está fora desse Como é que eu faria isso? O quê? De gerar outro outro tex aqui com valor diferente? Não, aqui a gente tá fazendo o upgrade para não ser possível. Como é que eu faria? Como é que eu faço antes do Porque o que tá o que tinha antes do upgrade eu continuo podendo fazer? Como é que eu posso fazer? Ora, eu venho aqui n, tá vendo aqui? Essa, isso aqui é uma transação legacy, ó. Vai est tudo na parte preta. Se isso aqui for uma assinatura, é só eu reassinar a transação e botar lá a assinatura. Vai continuar sendo válida. A transação continua toda válida, mas mudou a assinatura e mudou os dados que entram no cálculo do do ID dela. Então eu criei uma segunda assinatura, uma segunda transção válida que faz as mesmas coisas. Ela gasta o mesmo dinheiro e paga as mesmas pessoas, cria as mesmas exce, só que ela tem outro ID, entendeu? O problema não é eu ter duas coisas diferentes com o mesmo ID necessariamente. Aqui o problema é eu ter dois pagamentos semelhantes equivalentes com IDs diferentes. Que eu quero dizer com isso? O problema, se eu ver a transação como sendo a pessoa A, entre aspas, pessoa A, pagando a pessoa B, o problema é eu ter isso aqui com vários IDs diferentes. A pessoa A pagando a pessoa B, a moeda A sendo gasta e a moeda B sendo criada. A mesma moeda A e a mesma moeda B, entendeu?

Entendeu? Os nós antigos, eles eles são vulneráveis a isso e eles não conseguem rodar protocolos onde isso é um problema. Os nossos pós seguit eles são vulneráveis a isso se você fizer essas transações aqui. Essas essas outras continuam existindo. Só que elas isso foi mitigado aqui, ó, nesse desenho do das transações novas, desses desse tipo de transação novo. Então, se marcar aqui uma transação nova, você vai precisar validar também, vai precisar gerar regras novas aqui, validar mais coisas. Isso, sacou? Beleza? Então, repare que efetivamente eu segrego não só isso aqui. Seguit significa meu Deus, segregated witness. A witness tá separada, a assinatura tá separada, tá? Mas eu também tô segregando, como eu mostrei ali, eu tô segregando também a rede em duas partes. Tem a parte que é pré seg, a parte e os nossos pós seguit, tá? Os nossos préegot eles nem vêm, eles nunca vem essas informações novas aí, azul, eles nunca vem isso. Por quê? mostrei para vocês. O mecanismo é feito lá na parte de rede para eu se a gente se identificar e eu saber. Não, beleza? Você não sabe de dessa regra nova, eu nem te mando os dados. Você só vê as coisas antigas. Tudo bem? Eu vou parar por aqui agora. O que que eu quero fazer na próxima aula? Quero mostrar para vocês como que é os dois contratos do Segw. Tô mostrando como é que foi o upgrade, tá? Vou mostrar os dois contratos, porque o contrato que eu vou executar, ele precisa ser válido ainda no no passado. Ainda tem mais coisas que tem que entrar como sendo válido aqui, tá? E na aula que vem eu também vou mostrar um outro upgrade que já é mais recente, que é de 2021, que é um upgrade que a gente chama de tapot, tá? Que na verdade é um upgrade do seg. É o Segit tecnicamente seria deveria ser chamar de segit versão zero. Vai ficar claro porque na próxima aula. E o te é o seguit versão um. Tem um número de versão diferente lá em algum lugar mesmo, tá? E eles fazem coisas bem diferentes, tá? O Segot resolveu esse problema de maleabilidade das transações. Eu vou mostrar para vocês que o Seg nesse meio do caminho ele resolveu uma outra querela que tinha na época. Quando que foi isso aqui? 2017. Foi na época que tava se discutindo. Vamos aumentar o bloco, vou aumentar o bloco, não vou aumentar o tamanho do bloco. De 1 me para mais, tá? Foi na época do do fork do Bitcoin Cash. O Seg adicionou um outro mecanismo, vou mostrar na na aula na aula que vem, de a gente poder efetivamente aumentar o tamanho do bloco sem quebrar o o o a compatibilidade com os nós antigos, os pré seg, tá? Vou mostrar isso na próxima aula, como é que é feita a conta do tamanho do bloco agora. Então ele resolveu, meio que tá resolvendo vários pequenos problemas, né? O taper o que que ele tá vai resolver de problema? Ele vai trazer principalmente duas coisas, tá? Que foram discutidas na época do Seg, mas não foram incluídas ali naquele momento, porque isso aqui já foi muito complicado. Que que o Tep vai incluir? Principalmente duas coisas que são assim, nossa, para mim são muito fantásticas, tá? Salto qualitativo o negócio. A primeira delas é o o esquema de assinatura digital. Em vez de fazer SCDSA, vocês vão ficar, vocês vão mexer na no assignment. a gente passou a introduzir a assinatura shnor, que permite fazer vários truques, tá? Vários truques. Eu não vou mostrar aqui os truques para vocês, mas esses truques, eles truques criptográficos que permitem a gente implementar várias coisas interessantes, novas que a gente não conseguia fazer antes, tá? Multisig diferente, vários protocolos de multisig bem interessantes, um monte de coisa bacana. E a segunda coisa interessante do Teper é a ideia de que agora eu vou poder fazer scripts de gigantescos que em princípio não caberiam no bloco. E eu vou mostrar como, tá? Como que a gente pode fazer isso. E aí não só aumenta muito a expressividade do que eu posso fazer, porque agora eu posso fazer scripts muito maiores, tá? Como vocês vão ver, eu aumento muito a privacidade relacionado a script, porque na hora que eu for executar o script, eu não vou mostrar o script inteiro, porque eu não pensa, se se eu escrevo um script que tem 100 M de tamanho de bytes, 100 MB lá, ele nunca cabe no bloco. Isso quer dizer que na hora de executar eu nunca vou mostrar esse 100 MB, eu só vou mostrar partes dele, só vou revelar partes. E se eu só vou revelar partes, isso aumenta muita privacidade relacionada a esses scripts. Por exemplo, eu posso te mostrar uma parte do do script e uma parte pro Pedro. E vocês dois são dono do mesmo dinheiro, mas você só vem uma parte do script e o Pedro só vem outra parte do script e vocês nem sabem que vocês são donos juntos, por exemplo, de alguma coisa, tá? Eh, isso parece meio esotérico, por que que eu faria isso, tá? Mas a gente vai ver depois aqui em outros protocolos onde isso é útil, extremamente útil para implementar algum tipo de de pagamento ou algum tipo de compartilhamento de fundos, tá? vários e várias aplicações em cima do em cima disso. Todo mundo bem? Vamos parar por aqui então.