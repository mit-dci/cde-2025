Beleza, vamos voltar aqui. Vamos seguir então mudar de sunto, tá? Deixa eu falar de hashes nesses minutos que me faltam aqui agora de hoje, tá? Deixa eu definir um que que é uma função de hash. Na aula que vem eu quero falar de assinaturas digitais, assinaturas e curva elíptica e essa coisa arada toda, tá? Eu vou definir uma função de hash.

Vamos definir o que que é uma função de hash, tá? e ver o que que a gente pode fazer com isso.

Em algum lugar vai est disponível. Em algum lugar vai est disponível. Vamos lá. Que que vai ser uma função de rest para mim? Tá, eu vou chamar, eu vou dizer que existe uma certa função que vou chamar aqui de H, aliás, vou chamar de hash mesmo, tá? de R que recebe uma entrada de tamanho arbitrário. Então, pode ser qualquer tamanho essa coisa aqui, em princípio infinito, não importa o tamanho, tá? Esse X que é a entrada de uma função, a entrada da função eu vou chamar de pré-imagem, guarda esse nome porque eu vou usar esse nome várias vezes, vai aparecer muitas vezes aqui pra gente. É a entrada da função de rest. É a entrada, é um dado que eu boto na na entrada dessa função de rest, tá? E eu vou produzir uma informação aqui na saída. Vou produzir uma saída. Essa saída tem um tamanho fixo, vai ser sempre do mesmo tamanho, tá? aqui com vocês, eu vou, na mais esmagadora maioria do tempo, eu vou tratar essa saída como sendo 256 bits, mas tem várias funções de R diferentes com tamanhos diferentes.

Computação não tem muita matemática envolvida não. Função de H é uma da criptografia meio que tem dois, entre aspas, ramos de criptografia. É o é a parte que é baseada em matemática. Tem um problema matemático de fato que a gente não sabe resolver. E tem uma boa parte que é heurísticas. A gente não tem uma matemática muito precisa, mas a gente sabe que funciona porque a gente foi vendo as coisas acontecendo ao longo tempo. Análise estatística do negócio. Função de HCH é uma dessas eurísticas. Não tem uma explicação matemática muito sofisticada para dizer porque que funciona. Só sabe que funciona. É um pouquinho mais sofisticado que só sabe que funciona. Mas é mas é muito mais baseado numa horítica do que ter uma juscativa matemática formal, tá? Mas vamos lá.

A saída dessa função vai sempre ter o mesmo tamanho. Vou considerar pra maioria dos casos aqui 256 bits, tá? Eu vou chamar essa saída aqui de hash. É o hash da pré-imagem ou digest. Digest é o resultado da digestão, né? Tá? Tipo, enfim, eu vou chamar mais aqui como hash. É um hash. Ó, calculei o hash de alguma coisa, tá? Préimagem a entrada, hash a saída. Todo mundo OK? Repare o que que tá acontecendo. Repare o que que tá acontecendo, tá? Tem um conjunto de entrada grande aqui. Pensa que esse X vão ser bits. O H que vai sair vão ser outros bits, tá? Como o X pode ser uma entrada de qualquer tamanho, tem um certo conjunto de bit strings aqui, de strings de bits que podem ser colocados na entrada e ter um conjunto menor na saída, que é de tamanho fixo. Então, tem um número aqui. Nesse caso particular, quantos números diferentes pode ter na saída aqui? Quantos resultados diferentes? 2 elevado 256. 2 elevado 256 é o tamanho desse conjunto aqui, ó. E esse conjunto aqui, em princípio, não tem limite. Em princípio, na prática, tem limite, mas é uns limites muito, muito, muito, muito maior que isso aí, tá? Para vocês terem uma noção, 2 elevado 256 2 elevado 256, se eu não estou enganado, isso aqui é da ordem de 10 elevado 77, se eu não tiver errado nessa conta, tá? E a estimativa que a gente tem para o número de átomos no universo, o número de átomos no universo observável, pega todo o universo observável, se fosse possível, contar esse número de átomos. E essa estimativa é séria mesmo, tá? Tipo, os físicos que calculam isso, eles estimam isso. É da ordem de 10 a 80. Então, a gente tá falando de aqui nesse conjuntinho tem mais ou menos a mesma quantidade de átomos que tem no universo. É uma quantidade muito grande de coisa, tá? Por isso que é tão difícil de tu sortear dois números aleatórios dentro desse conjunto e tu pegar dois iguais, tá? A probabilidade sem é extremamente baixa. É igual você apontar um átomo no universo inteiro e outra pessoa aleatoriamente apontar um átomo também e ser casado de ser o mesmo átomo. Esse é o nível de dificuldade astronômico que a gente tá falando de dessa coisa. Todo mundo OK? Mas repare, repare, tá? Como na entrada tem mais, o conjunto de entrada é maior do que o conjunto de saída, necessariamente vai ter mais, vai ter alguns com alguns elementos aqui que mapeiam pro mesmo elemento do lado de cá. Necessariamente a gente vai chamar de colisão, necessariamente vai acontecer colisões, tá? Agora a questão é quão difícil é a gente conseguir construir essas colisões. Já vou definir um pouco melhor, mas presta atenção porque é isso que tá vai acontecer aqui, tá? A gente não quer qualquer função de H. Repare que eu posso fazer várias coisas aqui e calcular o H e e produzir isso aqui, tá? Mas eu quero algumas propriedades específicas para eu chamar essa esse R de criptográfico, tá? Primeiro deles, primeiro deles, eu quero que essa coisa pareça aleatório. Eu vou botar entre parênteses aqui aleatório.

Tem que parecer aleatório, só que isso é bem informal o que eu tô falando aqui agora. Preciso ter uma definição um pouco melhor, tá? Mas repare, isso aqui não é rolar dados. Eu pegar um X e rolar dados. Não é isso que a gente vai fazer. Essa essa função tem que ser completamente determin

x1 = x2 é garantido que h de x1 é igual ao h de x2, tá? Eu quero que isso seja verdade. Pra mesma entrada tem que dar a mesma conta o tempo todo. Ponto final. Não é rolado, mas eu quero que essas saídas pareçam meio que aleatórias assim, tá? Aí, o que que eu quero dizer com isso? Na média, eu gostaria aqui a quantidade de uns no H, vou chamar assim, ó, quantidade de uns, de zeros e a quantidade de uns. Vou usar essa anotação aqui que eu inventei agora. Eu quero que a quantidade de zero seja mais ou menos 128. E eu quero que a quantidade de uns seja mais ou menos 128. Pareça mais ou menos aleatória ali a coisa na média. Cuidado que a gente vai ver um monte de R aqui que não não que tem mais zero do que um de propósito para por exemplo calcular a prova de trabalho. Mas eu quero que na média isso aí seja mais ou menos verdade, tá? Outra coisa que eu quero é o seguinte. Outra coisa que eu quero que aconteça é o seguinte, é o que a gente vai chamar de efeito avalanche.

Se eu mudar um bit da entrada, eu gostaria que mudasse mais ou menos metade dos bits da saída. Eu gostaria que isso acontecesse, tá? Eu até fiz um fiz mais ou menos, mas fiz um pequeno demozinho aqui, ó.

Vocês estão vendo minha tela, né? Cadê ele aqui? Eu tô tentando voltar meus comandos para não precisar de digitar tudo de novo. Eu vou calcular o rest dessa dessa mensagem aqui, ó. Edil. Tá ali, ó. Deixa eu só explicar o comando. Edil vai ser minha mensagem. E é só para produzir uma string para poder passar pra frente aqui no terminal. Menos C é para não botar a quebra de linha no final. É só esses quatro caracteres mesmo que vai ter lá, tá? Eu vou calcular o X256, que é a função de R que eu vou usar aqui como exemplo, é a das mais comuns, extremamente utilizada em quase tudo, inclusive Bitcoin, inclusive quase todas as cript essa usa X 256. Eu quero ver essa parada aqui em binário. Eu quero, tô usando esses outros XXD, não sei o quê, tudo para ver os bits, tá?

Chamei isso aí de A. E aí eu tenho em algum lugar aqui, uma que é B. Repare que a mesma coisa eu tô mudando a mensagem de edil para edin. Se você olhar a tabela ask desse negócio, eu tô mudando o bit menos significativo de zero para um. Só isso que eu tô fazendo. Todos os bits são iguais. O bit menos significativo, eu tô mudando de zero para um. Todos os outros bits são iguais nessa mensagem aí, tá? Hã, 76. 76. Aí você que sabe dessas coisas. Eu não faço menor ideia, tá? Olha o A. O resultado daquele primeiro hash é são esses bits aí. O resultado do segundo hash são esses bits aí, tá? São esses bits aí. Eu não vou pedir para vocês olharem na mão. A gente pode pedir pro computador calcular pra gente quantos quantos quantos bits tem diferente em cada um deles, tá? Esse comp calculou para mim. Ele um comando aqui que compara duas strings e fala para mim onde, uma por linha, fala assim qual posição é diferente de cada um. E aí eu tô pedindo para contar quantas linhas tem. Isso vai ser a quantidade de bits que tem de diferente um no outro, tá? Nesse caso aqui, ó, tem 124 bits diferentes. Eu mudei 1 bit na entrada e eu mudei 124 bits na saída. Hã,

você não tá vendo ali. Pera aí. Agora você tá vendo o 124, tá? 124 bits de diferença. Tudo bem? Hã? Aproximadamente a metade. Repara que não é exatamente a metade o tempo todo, tá? Tem uma outra string que eu fiz aqui que é essa daqui, ó. Mudei um mais um bit. Mudei mais um bit. É, sei lá, de 77 para 78 lá. o o ask lá, tá? E aí, se eu comparar aqui, ó, o B, o A com C, repar que mudou 134 bits. Eu não sei quais, tá? Mas mudaram 134 bits. Se eu comparar o B com C, mudou 142 bits. Eu quero que isso aconteça. Eu mexi um pouquinho só na entrada, bagunça totalmente lá a saída, tá? Eu eu quero que isso aconteça. O XH 256 é uma função que tem essa, uma das que tem essa propriedade, por exemplo, tá? De chamando de efeito avalanche.

Mas tem três propriedades que eu vou definir um pouco mais formalmente aqui com vocês que vão ser a base pra gente usar os restos. Eu não vou mostrar para vocês como que constrói o rest, pra gente vai ser uma caixa preta, tá? Mas essas três propriedades vão ser necessárias, vão ser suficientes pra gente construir todas as outras coisas, tá? Todas as outras coisas. A primeira delas é o que eu vou chamar de resistência à primeira pré-imagem.

Resistência à primeira préimagem. Quer dizer o seguinte, vou definir assim, ó. Essa propriedade aqui, eu te dei um y. Eu te dei um y que é um hash. Eu te dei um hash qualquer. Eu te dei a saída dessa função avaliada por um certo x, tá? Você não será capaz de encontrar, eu vou marcar assim, ó. você não será capaz de encontrar um X tal que h de X é Y. Que que eu tô falando? Que eu tô falando para você. Se eu te mostrar um hash a saída, se eu te mostrar umest desse aí, você não vai conseguir calcular uma pré-imagem que corresponde à aquele hash. Isso quer dizer que essa propriedade aqui é extremamente útil. Por quê? Porque ela me permite esconder informações por trás dos restos. Se eu te mostrar o o o hash, eu não tô te eu não te não tô te revelando em princípio, de forma nenhuma o x. Equivalente dizer que a função não é inversível. É o equivalente a dizer que essa função não é invertível. Exatamente. Mas repar, eu tô escondendo o X. Como é que você faz a métrica disso? Quê? Como é que é a métrica? Como assim a métrica disso? A métrica da temática. Como assim a métrica? Como é que eu descubro se a função é tem essa propriedade ou não? É porque você o ação no resto é porque você tem o domínio contra domínio e o um é maior isso. E aí você pode fazer um brut force ao contrário. Você sempre pode fazer um brute force. Quando eu digo que você não será capaz de encontrar um X que corresponde que é uma pré-imagem daquele Y. O que eu tô dizendo, na verdade, é que não tem nada melhor que você possa fazer do que ficar gerando vários X e calculando até encontrar o Y que você tá procurando.

Aí a pergunta é quantos quantas se for um R de 256 bits, quantas tentativas na média você precisa fazer para encontrar esse X aqui?

na média não

285

de 2 é quanto? É metade 2 elevado 2 elevado 256.

E aí aqui num curso de cripto a gente mostra melhor por, mas aqui eu simplesmente vou falar. É isso aí. Não tem nada melhor que você possa fazer, pelo menos nessas funções aqui que a gente vai usar, do que sair testando um monte de X até encontrar um que cujo r.

Mas a quantidade de coisas que você tem que testar é tão grande, mas tão grande, tão absurdamente grande, que na prática é impraticável. Claro que você pode ir lá e começar a testar e dar sorte de em poucos segundos lá, olha só, encontrei um. Mas na média, qual a qual a probabilidade de você conseguir fazer isso? Praticamente zero. Mas pode ter também salvos, né? Hã, você pode ter, você tem lá sendo, mas aí é outra conversa, porque aí aí eu não tô te dizendo que é um X qualquer, eu tô te dizendo que o conjunto X é pequeno. Se eu te falar assim, ó, tá aqui um R e você sabe que as entradas vieram de um conjuntinho pequeno, aí você vai lá e testa. Aí o brute force é é óbvio assim, vai lá e faz e vai descobrir, entendeu? O tamanho do X importa também. O tamanho assim, o espaço de onde tá o definido X importa, tá? Isso inclusive vai ser uma questão. Ele tá falando que ataque de dicionário. É ataque de dicionário, por exemplo, você não guarda, você no site você não guarda R, você senhas em branco, você guarda os restes deles. Mas só guardar, só guardar o rest assim também não te ajuda muito não, porque os as senhas das pessoas a gente precisa mais ou menos como é que elas fazem. Então a gente começa a testar ali, a gente vai encontrar uma hora. Eu preciso de alguma coisa mais. Tá, mas vamos lá. Mas isso tudo para dizer que o tamanho do X importa, o tipo o espaço de onde ele vem, tá? Segunda propriedade que eu quero, eu vou chamar de resistência à segunda pré-imagem,

a segunda pré-imagem. Presta bem atenção, porque esse daqui é meio bagunçado.

Eu te dou um par. XY. Eu te dou um par XY, sendo que Y é o r do X. Eu te mostrei um H e pra imagem dele.

Eu tô dizendo, eu afirmo, que você não vai conseguir encontrar um X linha de tal forma um X linha diferente de X. Você já viu o X? de tal forma que o resto do x linha é igual a Y. Esse aqui é diferente. No primeiro eu te dei a saída do resto, não falei como é que é a pré-imagem. Nesse aqui eu tô te dando uma pré-imagem e um rest. E eu tô falando assim, você não vai conseguir encontrar uma segunda pré-imagem diferente daquela que eu já te falei que bate no mesmo r. Tudo bem? E a terceira propriedade que eu quero nessas funções de hash, não só que eu quero, eu vou considerar que as minhas funções que que as funções que eu vou usar tem essas propriedades, tá? É o que a gente vai chamar de resistência colisão,

resistência, colisão. Presta muita atenção porque ela é parecida com da segunda pré-imagem, mas é diferente, tá? Eu tô dizendo o seguinte, você não vai conseguir fazer

logo de partido. Você não vai conseguir encontrar X e Z com X diferente de Z,

que tem a propriedade de que o resto do X é igual ao resto do Z. Eu

tô falando aqui para você, você pode escolher as duas duas pré-imagens quaisquer, do jeito que você quiser. Repare que na segunda pré-imagem eu te dei uma uma delas, uma delas tá travada. Na colisão, você tá livre para escolher os as pré-imagensagens que você quiser. Tô dizendo para você, você pode escolher dois duas pré-imagens quaisquer. Você não vai conseguir encontrar dois dois duas entradas diferentes que produzem o mesmo rest.

É improvável, mas é possível. Claro que é possível. Tem sempre vai ter colisão. Afinal, o conjunto de entrada é maior que de saída. sempre vai ter colisão, inclusive sempre vai ter uma quantidade astronômica de colisões. Quando a gente calcula essa parada, tipo, a quantidade de colisões é monstruosa, tá? Só que a probabilidade de eu encontrar uma colisão nessa aí é extremamente baixa. Pergunta: quanto? Não é que eu não consigo aqui, eu também vou fazendo brute force, tá? Eu sempre posso fazer bruto ficar testando dois dois X e ficar fazendo vários pares e testando quantos eu tenho que testar aqui na média para conseguir fazer isso aqui foi 2 elevado 256.

Quantos vão ser aqui embaixo? 2 a não. Quanto? 255 não.

Eu vou dar o racional aqui para vocês do por que não é 2 elevado 256. É mais fácil do que isso, mas é muito, tá? Repare que eu posso começar o processo fazendo, calculando, escolhendo. Aleatório, sorteio lá x0 e x1. Aí eu vou lá e calculo o resto desses dois. Aí não bateu. Vocês concordam que eu posso produzir um x2? E agora eu comparar o resto com esse e com esse não bateu. Aí eu produzo um x3 e aí eu calculo o resto desse com esse, com esse e com esse, porque eu já vi aqueles restos antes, é só eu ir guardando. Então para cada número a mais que eu coloco, eu aumento minha probabilidade de de encontrar um outro hash que bate. Tá vendo? Cada número a mais que eu sorteio, a minha lista de coisas possíveis na minha busca tá aumentando. Então, tá ficando. Quanto mais e eu quanto mais eu vou nesse processo, mais fácil fica, porque maior é a quantidade de restos válidos agora para mim, porque eu posso fazer quaisquer duas combinações. Então, isso aqui é mais fácil do que 2 a 256. Eu não vou provar para vocês, tá? Mas esse processo aqui, isso aqui, isso aqui chama birthday attack, tipo ataque do dia do aniversário. Enfim, procura no Google que é isso. A gente consegue provar que vai ser raiz quadrada da quantidade de de de possibilidades possíveis, que nesse caso é 2 a 256. Então isso aqui vai dar 2 a 128 combinações. Eu preciso testar 2 a 128 coisas, tá? 2 a 128 coisas, que é bem menor do que 2 a 256, mas ainda sem uma quantidade astronômica, tá? Eu vou dar o nome para isso aqui. Eu vou chamar isso aqui, ó, de 128 bits de segurança.

Quando eu digo: "Ah, eu quero alguma, eu quero um parâmetro aí, eu quero colocar, parametrizar minhas coisas". Quando eu falo assim: "Ah, eu quero criar um sistema com 128 bit de segurança, quer dizer o seguinte, a gente não conhece nada melhor do que ter que testar 2 a 128 possibilidades para eu conseguir ter uma probabilidade não nula ou uma probabilidade razoável, normalmente é 50%, de encontrar um, de fazer alguma coisa no sistema. Repare que não é garantido, tá? Pode ser que eu

calcule do a 128 coisas e ainda assim eu não encontrei. Pode ser que eu encontre, calcule dois e encontrei na média. Se eu ficar repetindo essa coisa aqui, 2 a 128 tentativas. Isso que quer dizer 128 bit de segurança. Alguém perguntar alguma coisa aqui? Eh, professor, eu não entendi muito a diferença entre a a segunda e a terceira regra, porque parece parecido no quesito de eu tenho, no caso da segunda do X e o X linha, eles são diferentes e eles não podem ter a responsabilidad. Isso. E no terceiro eu tenho um X e um Z. são diferentes. Eles não tem o mesmo rest, mas o rest é igual a saída. Como assim? O resto é igual a saída. O H, o rest é a saída. O resto é a saída. Então aí se ele não tem o mesmo rica parece muito com a segunda regra. Parece muito com a segunda regra. Tanto que a segunda regra ela é meio meio mess assim, meio bagunçada, tá? É meio difícil até de dizer quando que é útil, tá? Porque esse esse protocolo aqui ele é meio interativo. Eu preciso te dizer um X, um, uma pré-imagem primeiro e aí você vai tentar buscar uma outra pré-imagem que encaixe com aquele Lele R. Tem um, um termo tá fixo, uma das entradas tá fixa. Nesse daqui você pode procurar duas entradas quaisquer, do jeito que você quiser, entendeu? As duas estão livres, você tem mais graus de liberdade. Essa que é a diferença. Aqui, ó, o X tá fixo, você tá procurando o X linha. Aqui o X e o Z tão livres para você mexer. E você tá procurando X e Z que satisfazem isso aqui, ó. Nos dois casos, você tá procurando duas coisas que gera o mesmo resto, a mesma saída. Mas numa delas, uma entrada tá fixa e na outra você tem liberdade nas duas entradas. Mas 128 bits assim seria computacionalmente baixo? Não, 128 bits é o padrão ouro de segurança. A gente acredita que a gente vai passar várias décadas até isso aqui. A gente precisar fazer sistemas com mais de 128 bit de segurança, décadas. E isso aqui não melhora em termos de hash. Isso aqui não melhora com computação quântica. A própria C frames com 12 palavras é essa essa combinação aí 121 de segurança. É, professor, você pode a primeira a primeira resistência pré imagem é o seguinte, eu te mostro um hash, eu te mostro só a saída, você não vai ser capaz de calcular uma pré-imagem que produz aquela saída.

Oi? Então eu consigo calcular a mesma pré imagem que Não, não é a mesma pré imagem. Eu te mostrei um rest. Eu te mostrei um rest. Tipo esse aqui, ó. Eu te mostrei um um r aqui, ó. Esse aqui é um resto qualquer, tá? Imagina aqui, você sabe qual é a pré imagem, mas se eu tivesse te mostrado só a saída, o que eu tô afirmando lá, resistência pré imagem é que você não consegue calcular alguma coisa para botar aqui dentro. que dá esse valor específico, entendeu?

É isso que tá dizendo a resistência a primeira préagem, tá? E essa resistência a primeira pré imagem é é uma das coisas extremamente importantes pra gente. Por quê? Porque isso aqui vai dar duas duas propriedades pra gente, que é hiding. A gente vai chamar de hiding, que é o hash esconde alguma informação por conta disso aqui, ó. Se eu te mostrar o Y, você eu você não sabe nada do X ainda. Então ele esconde uma informação. A gente vai usar isso direto, direto para esconder uma informação. Mas ele é binding. Que que quer dizer binding? Quer dizer o seguinte, eu posso me comprometer com o X. Eu posso falar assim para você, eu sei quanto que vai dar o o o o valor da Mega Cena na semana, daqui a um ano. Eu sei hoje que que eu posso fazer. Eu não quero te dizer, porque se eu te disser, você vai lá e vai jogar daqui um ano e vai ganhar. Eu quero ganhar sozinho. Mas eu quero mostrar agora, por exemplo, quero apostar ainda com você e ganhar mais dinheiro ainda. Quero apostar com você que eu sei hoje que que eu posso fazer. Eu vou lá e escrevo os números. Escrevo os números, guardo comigo. Isso é secreto, não quero mostrar para ninguém. Calculo o resto daquilo e mostro para você. Ó, eu eu sei os números e tá aqui o meu commitment, tá aqui o rest do da da do desses números. Tá aqui, ó. Pum. Daqui a um ano, depois do fato acontecido, eu posso mostrar para você e falar assim: "Ah, como é que você sabe que você sabia? Eu olho aqui, ó, pré-imagem daquele hash que gerou aquele r específico que eu te mostrei lá um ano atrás. A primeira propriedade aqui, ela me permite fazer isso e me permite me dar alguma garantia de que eu não consigo no meio do caminho esconder. Por quê? Porque lá no passado eu produzi, eu precisava de uma entrada na função que produzia um certo RH. E eu já te mostrei o RH. E o que eu tô dizendo aqui para você, dado um hash, eu não consigo calcular um outro x qualquer arbitrário que gera aquele aquele Y específico. Eu tinha que já saber o X que produz aquele R específico naquele momento do tempo. Então, repara, eu vou chamar isso de commitment também. Eu me comprometo, eu consigo me comprometer com informação agora. Eu consigo falar assim, ó, eu sei uma coisa, tá aqui, tá aqui o o o o o contrato, uma informação que garante que eu sei aquela coisa. E como é que você prova que você sabe? Você mostra a coisa e alguém consegue verificar bater no resto. Só uma prioridade, eh, essa propriedade, ela quando os primeiros sistemas que com essas propriedades ela era usada para patente. Para patente para pessoa que assim, por exemplo, eu inventei uma coisa, só que eu não publiquei essa coisa não. Ah, então tá vendo? Você esconde aqui, tá aqui o r da da minha invenção. Exatamente. Quando fosse publicado, tava eu fiz. Olha aqui, ó. lá naquele momento, quando já existia aquele hash, só podia ter sido gerado, só podia ter sido gerado por essa por essa entrada aqui, ó. Tá aqui, me engano, alguns matemáticos que que começaram a criar isso, eles faziam rest de teoremas, eles faziam teorema. Funções de rest vão ser a base pra brincadeira toda que a gente vai fazer aqui. A gente vai usar em absolutamente todo lugar. Por quê? Porque eu consegui esconder e eu me e me comprometer com informações e provar no futuro que eu sabia alguma coisa no passado. Você estudia dos números. Hã? Teoria dos números. Como assim? Teoria dos da matemática estuda teoria dos números. Criptografia. Eu preciso terminar a aula agora por causa da da próxima. Só um segundo aqui só para deixar um gostinho de tipo ixe mais que doideira. Computação quântica não melhora isso aqui não ajuda muito isso aqui a a quebrar quebrar um hash é quebrar alguma dessas coisas aqui é conseguir calcular uma dessas três coisas mais rápido do que isso ou do que isso, tá? Qualquer coisa mais rápido do que isso é considerado, mesmo que seja impraticável, é considerado que quebrou o ré. Por exemplo, eu consigo calcular uma colisão com 2 elevado a 127 coisas. Quebrei o resto, tá? É melhor do que 2 a 128, mas ainda assim é impraticável. quer dizer que ah, quebrou tudo. Por que que computação quântica não ajuda aqui? E é meio que um uma coisa que eu tô fazendo rang wave violento. Como eu disse, criptografia tem meio que parte das coisas, das primitivas, das coisas que a gente vai construir. Elas são base, algumas são baseadas em alguma teoria matemática de sobre números a gente conseguir ou não calcular alguma coisa. Aí o computador quântico ajuda e tem algumas outras partes da criptografia de primitivas que a gente vai fazer que são basicamente orísticas. É tipo, ah, mistura esse com esse, faz o shift para lá, soma com tal coisa, soma com tal coisa e deu. Computador quântico não ajuda em nada com relação a isso. Beleza, gente? Valeu, até a semana que vem.