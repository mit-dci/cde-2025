Eu esqueci de dar um recado, mas vocês sabem, né? Tô gravando a aula, aquela coisa toda, tá? Tudo que vocês disserem vai ficar aqui. Alguém vai pode bagunçar isso. Enfim, vamos lá, segue o baile aqui. Então, vamos falar de programabilidade do dinheiro. Vou falar de, vou dar vários, vou mostrar vários contratos hoje. Então, presta bastante atenção aqui, tá? Deixa eu falar, passar o dia inteiro falando disso, tá? recap, uma recapitulação breve aqui, tá? Uma recapitulação breve do que a gente tá fazendo, né? Do que tá acontecendo. Do que tá acontecendo. Tudo isso aqui tá no contexto de transações. As transações tem entradas e tem saídas. Entrada é dinheiro que alguém tá gastando. Saída é o dinheiro que alguém tá recebendo. Todo mundo já decorou isso, né? Entrada é o dinheiro que alguém tá gastando, saída é o dinheiro que alguém tá recebendo, tá beleza? nas saídas, nas saídas dos das transações, cada saída de uma transação tem dois campos, como a gente viu, tem o amount, que é quanto tá sendo gasto, e tem um script que eu chamei aqui de script pub key, que é o nome que tá no código lá do Bitcoin Core desde então. Eu prefiro chamar de locking script, um script de travamento, tá? E o que que é esse script? Ele é um contrato que estabelece condições, que estabelece condições para alguém poder gastar aquele amount, gastar aquela saída. E o que que significa gastar aquela saída? Significa produzir uma outra transação, chamar isso aqui de TX0, chamar aqui de TX1. gastar uma saída é produzir uma outra transação que usa aquela que faz referência aquela aquela uma saída da transação zero numa das entradas. Isso só pode acontecer uma vez no sistema, tá? Uma vez que a transação um for confirmada, aquela saída zero da transação zero nunca mais vai poder ser usada numa outra entrada de uma outra transição qualquer. É, essa é a regra básica, tá? Aqui na entrada da transação, aqui na entrada da transação tem quatro campos. Quatro campos, tá? O primeiro deles é o TX ID, o segundo dele deles é o index. Isso aqui é um ponteiro que diz, ó, eu quero gastar a saída index da transação TXID. Então, tô dizendo qual é a moeda específica que eu quero gastar. Depois disso, tem um script que eu chamei de script SIG. normalmente envolve uma assinatura, no outro caso lá envolve uma chave pública normalmente, mas toma muito cuidado com isso, tá? Tem um script que é um um programa de computador que a gente vai falar muito mais sobre ele, sobre esses dois programas hoje, tá? O script PUBG key e o script SIG juntos combinados formam um programa de computador e esse programa de computador o resultado final dele tem que ser verdadeiro. Se o resultado final dele for falso, essa transação um vai ser considerada inválida. Quer dizer que quem tá tentando gastar não apresentou as condições necessárias pro gasto. Não conseguiu cumprir com o contrato, o contrato que tá escrito na transação zero. Todo mundo OK com isso? Com isso, tá? Por fim, tem um campo aqui que é o sequence. E hoje ele vai começar a aparecer um pouco mais porque a gente usa esse sequence para inserir uma semântica de tempo de quando que isso aqui pode acontecer, quando que não pode acontecer. Mas vou falar bem lá no final da aula. Todo mundo ok com isso? Todo mundo OK com isso? Isso aqui tem, isso aqui é o tem que tá na mente o tempo todo. Isso aqui tem que estar na mente o tempo todo. Isso aqui é o a pecinha básica da de tudo, de absolutamente tudo, tudo, tudo, tudo que a gente quer fazer com com as cripto. Todas, absolutamente todas elas. Isso aqui é o basicão da coisa toda. Se tu não tem isso aqui em mente, é tudo um grande uma grande mágica.

Todo mundo bem, né? Então tá bom. Segue o baile aqui. Dois pontos importantes a se observar. O primeiro deles é o seguinte: quando que esse programa vai executar o script SIG mais o script PUBK, quando que ele vai executar? Porque repare que tem dois momentos diferentes no tempo, no tempo físico aqui agora que tô falando, o tempo do relógio mesmo, do mundo real, tá? O tempo tá passando aqui, ó. Tem um momento que eu vou chamar aqui de T0, que é quando a transação zero foi conhecida por por um nó.

Um nó, viu? Essa transação aí, tá? Que que ele vai fazer? Validar. Parte do processo de validar é executar esses scripts, tá? O que que ele vai executar de scripts? Ele vai executar o programa da transação anterior, onde que ele tá tentando que tá tentando ser gasta aqui, combinado com o programa que tá nas entradas. Cada uma das entradas vai virar um programa e cada uma das entradas ele vai ter que ser validado independentemente. Todo mundo bem? O que que não vai executar no momento t0? Esse programa que tá aqui, ó, ele não executa agora. Ele vai executar quando? num segundo momento, que eu vou chamar aqui de T1, quando um nó conhece a transação TX1,

aí ele vai passar a executar esse programa combinado com o pedacinho de programa que tá aqui. Hoje eu vou mostrar vários programas diferentes e eu vou mostrar o o o a parte de travamento, que é o contrato, e a parte de destravamento, que é o gasto, que é a condição de gasto. Todo mundo bem? Mas mantenha sempre isso aqui em mente, quando que essas coisas são executadas, porque isso importa e importa muito, importa muito pra gente construir aplicações. Diga, que que é o quê? Sequence. Sequence é um campo, por enquanto são só bytes. E a gente vai ver que ele vai ser usado para para introduzir uma uma semântica de tempo. Uma semântica de tempo. Todo mundo OK com isso? Esse é o segundo ponto relevante. Segundo ponto relevante, tá? Segundo ponto relevante. Terceiro ponto relevante que que eu espero que fique mais claro ao longo da aula de hoje é o seguinte. A gente tem dois modelos de computação de é de programabilidade, de express expressividade, acho que é assim que fala em português, expressivity, de o que que eu consigo dizer com esses programas, tá? O que que eu consigo expressar com esses programas, que tipo de contrato eu consigo dizer com esses programas? ou que tipo de programa eu consigo programar, tá? E aí a gente tem dois paradigmas. O primeiro deles que é o paradigma que começou com Bitcoin, eu vou chamar de Bitcoin model,

mas é um nome que eu tô inventando agora, tá? Tem outras outras criptomonas que seguem esse mesmo modelo, que é o modelo de que eu vou chamar aqui de validação. Eu consigo validar informações, mas eu sou extremamente limitado na hora de produzir novas informações com aqueles programas ali. Então, quem é que tem que produzir as informações? O programador é basicamente hard coded ali. Elas tem que ser produzidas fora do do do do fora do sistema aqui, fora do meu dos meus contratos e da execução dos contratos. Tudo bem? Mas eu vou ter mecanismos para validar alguma coisa, para, por exemplo, checar uma assinatura. Checar uma assinatura é validar, validar se você é você, tá? A gente vai ver aqui, vai ter mecanismo para eu validar se aquilo é válido naquele momento ou não, se eu posso, se eu podia estar fazendo uma coisa num certo momento, não. Vou ter mecanismo para validar se você sabe um certo segredo ou não sabe um certo segredo, tá? E vocês vão ver que o mecanismo básico é eu poder escolher entre diferentes condições de gás. Ah, eu posso fazer isso ou aquilo, tá? Vai perguntar? Não, eu posso fazer isso ou eu posso fazer aquilo. Então vocês vão ver que envolve condicionais, tá? Ao passo que tem um segundo modelo que eu vou chamar aqui de Ethereum model

Ethereum model, tá? Que começou com a ideia do do Etheréum. A ideia do Etheréum é universal computation. É, não, eu não quero só validar alguma coisa, algum dado que alguém produziu e eu não sei como ele produziu. Eu quero eu mesmo aqui produzir os dados. E mais do que isso, mais do que isso, eu quero ter acesso ao estado atual do sistema para eu poder calcular alguma coisa. Essa é a ideia básica do Etherum, que eles vão chamar de depois de smart contract, tá? Mas a ideia de smart contract não nasceu ali, já tava já tava no no Bitcoin. Você não vê que é tudo no whiteaper já essas ideias do Etheréum. Sim, você o white paper do Etherum tá na lista de materiais recomendados e o white paper do Etheréum vale muito a pena ler, tá? O o white paper do Bitcoin ele não fala sobre script, tá? O, é, é, é até curioso, é até curioso. Eu tô investigando para ver se tem alguma coisa, onde é que apareceu isso a primeira vez, porque no white paper não há nenhuma menção. O o Satos fala que as transações, as moedas vão ser cadeias de assinaturas digitais. E aí na ideia básica, no no paper, essas isso que eu desenhei aqui, aqui teria uma PUBG que uma chave pública, não teria um programa que envolve uma chave pública, teria só a chave pública, um campo com uma chave pública. E aqui teria uma assinatura referente à aquela chave pública, tá? Eu acho que era assim que ele tava projetando o sistema. Isso até final de 2008, quando foi lançado em começo de 2009, tinha isso aqui que eu tô mostrando para vocês, o script, tá? E eu sei de um relato, eu vou recuperar isso, esse relato e eu mando para vocês. Tem um relato dele explicando que, ah, quando eu, tipo, a gente, a gente, assim, eu tava pensando em várias aplicações diferentes do tipo, ah, contratos, tipo, ah, eu posso eu posso querer gastar, eu posso querer dar um prazo pra pessoa pegar e gastar aquele dinheiro, se não volta para outra pessoa, entendeu? ele ele tava querendo expressar outras ideias que a gente já executa com dinheiro, que a gente já executa com dinheiro, tá? E aí ele e aí ele diz que ele pensou, em vez de eu botar campos específicos para cada uma dessas aplicações, porque isso travaria já o sistema, eu não poderia expandir ele depois. Tem a história do consenso. Para eu mudar uma regra de consenso é um problema. Como a gente começou a comentar na aula passada, como ele percebeu isso, o que que ele pensou? Vou embutir uma linguagem de programação, porque aí eu dou flexibilidade para expressar esses contratos. Aí é que foi começou essa história do script, tá? Provavelmente não tem um relato muito claro de como é que foi o racional, tá? Mas foi por aí. Hã, pensou para evitar isso, sair, tipo, sair do controle? Que que você chama de sair do controle? A partir do momento que você dá essa flexibilidade também, você dá flexibilidade para muitas vulnerabilidades. Exatamente. Ele pensou, preciso limitar isso aqui. Isso aqui não pode ser universal computation, não posso poder fazer qualquer coisa. completo. Hã, não pode ser. Por isso que já começa essa linguagem não é toc,

ela tem que ser suficientemente poderosa para eu validar dados, mas ela tem que ser suficiente, ela tem que ser o mais minimalista possível para eu não conseguir expressar bugs, até bugs simples assim, do tipo, ah, vou fazer um loop infinito aqui. É fácil um loop infinito, né? Se você tem o a ideia de repetir as coisas, não tem estrutura de repetição aqui, o que é um problema, porque a gente quer fazer coisas, estrutura de repetição é extremamente útil porque torna o o o código mais compacto, né? Então fala, eu posso falar assim: "Ah, repete essa, vai, eu vou, você vai precisar fazer essa operação aqui 10 vezes. Repete ela 10 vezes ou repete ela 1000 vezes, certo? Se eu sei a antes do do se eu sei a priori quantas vezes tem que repetir, eu posso fazer um unrolling, né? Só copio e cola o código ali, tá? Qual o problema de fazer isso aqui?

A transação vai ficar muito grande até o ponto que eventualmente ela nem cabe no bloco mais. Então ela não tem um limite do do que que você consegue fazer. Certo? Hoje eu quero comentar com vocês de como é que a gente resolveu em boa medida esse limite específico de deixar um fazer um script muito fazer um script gigantesco, tá? Hoje a gente consegue fazer scripts gigantescos, absurdamente gigantescos. Vocês não não tem nem mais tá noção do tamanho da parada, tá? Como truques criptográficos, tudo vai envolver um monte de função de has, como a gente viu ali ali em algum momento, tá? Mas enfim, o modelo do Etheréum, essa inaugurou essa ideia de não vamos fazer computação universal, tá? E aí várias outras criptos vão nesse caminho, vão nessa linha, várias outras moedas vão nessa linha, tá? De computação universal, mudando o como é o estado, mudando que tipo de informação que a que a transação tem acesso, tá? Aí tem inúmeras variações. Tudo bem? Bitcoin é linguagem de validação, mas você vai ver que é extremamente poderoso até hoje. A gente ainda tá tentando descobrir o que que é o que que é o que que a gente é capaz de fazer com isso. Assim como a gente ainda tá tentando descobrir o que que a gente pode fazer com a internet. Aí o a gente sabe que é extremamente limitado. O o fato de ser extremamente limitado não quer dizer que que é extremamente limitado.

Mas você pode entendeu a a ideia básica? Tipo assim, a linguagem do é a linguagem de do etheréum é turcum, se eu não me engano, chama simplicity, que é uma linguagem mesmo, compila. enfim, tem uma linguagem de alto nível envolvida e essa coisa toda. Todo mundo bem? Esse é o paradigma. Esse é o paradigma, tá? Aqui com vocês vou falar muito mais do modelo Bitcoin, vou passar referência sobre o outros modelos de de computação universal, tá? Solid Solid, perdão, Simplicity é outra coisa. Simplity é uma que tão construindo em cima do Bitcoin. Solidity, isso tá que vocês vão ver aí tem curso de Solidity para tudo quanto é lado, né? é a linguagem de de programação para escrever os contratos nas transações do Etheréum, do Etheréum, de outras criptos também usam a mesma linguagem. Tem outras scriptos que usam, tá? Ah, perdi o fio da meada aqui. Que que eu tava falando?

Ah, enfim. Vamos vamos ver como é que funciona o caso do Bitcoin. Vamos ver como é que funciona o caso do Bitcoin. Beleza? Próximo fato, antes da gente ir vendo os contratos mesmo, tá? A linguagem do Bitcoin é baseada numa pilha, ao contrário de de linguagens, entre aspas mais convencionais, são baseadas em registradores. Você tem alguns registradores e você opera em cima desses registradores. Aqui não. Aqui a estrutura básica que você tem para operar é uma pilha e é uma linguagem com uma pilha, cara. Uma linguagem com uma pilha é uma linguagem relativamente simples, né? Você estud em teoria de computação, acho um autômo, um pushp autôma, né, que ele tem acesso a uma pilha e você pode colocar dados na pilha e pode tirar dados da pilha e processar esses dados que você tirou da pilha, tá? Mas em princípio as o programa ele vai ter acesso aos dados que estão nessa pilha e um ou outra informação da transação da transação que tá tentando fazer o gasto. A gente vai ver aqui que eu vou chamar de contexto, tá? Teu programa roda num ali o avaliador, ele tem um certo contexto naquele momento. O que que é esse contexto? O contexto é essa transação aqui, ó. Os dados que estão nessa transação, eu vou chamar desse de contexto, tá? Cuidado que os dados dessa transação não aparecem aqui. Eu não tenho acesso a eles, nada, zero. Eu só tenho acesso a algum acesso aos dados dessa transação um, tá? E aí a gente vai ver aqui também hoje é é extremamente limitado o acesso a esse contexto pro para esse programa que tá executando pro contrato ali. Mas você vai ver a outra transação a partir do momento você vai ver o completo. E é assim, vocês vão ver que, tipo assim, envolve a computação envolve a a o contrato que tá na transação zero, mas eu não tenho acesso a dados daquela transção zero do tipo assim, ah, quando que ela foi, quando que ela foi validada, quando que ela foi confirmada, por exemplo, eu não tenho acesso a esse tipo de informação. seria útil eu ter algum tipo de acesso a isso, mas começa a ter problemas, tá? Tipo, vai abrindo superfície de ataque. Enfim, uma discussão recente, extremamente recente, se a gente não sabe ainda para onde vai dar na no mundo do Bitcoin, tá? É uma discussão que o pessoal tá chamando de covenants.

Covenant é a ideia. Covenant é o contrato de de um condomínio. Quando você tem um apartamento num condomínio ou tem uma casa num condomínio fechado aqui no Brasil, por exemplo, você não pode fazer qualquer coisa dentro na tua casa. Tem horário para você fazer barulho, tem horário para você fazer obra, tu não, sei lá, tu não pode fazer uma piscina, não sei aonde, sabe? Assim, você tem restrições de uso do seu terreno, da sua propriedade. Essas restrições a gente chama de coverants, tá?

Faz um pouco mais de sentido nos Estados Unidos porque tem lá nos Estados Unidos tem a ideia do condomínio fechado e aí tem um contrato que rege o condomínio, que é mais parecido com o que a gente faz aqui hoje. E tem a ideia do covenant, que é que é restrições para as casas que estão na rua, tá? para as casas que estão na rua, mas não são restrições que foram impostas por uma lei, por legislação. Então, um negócio meio esquisito pra gente, porque a gente não tem esse mecanismo aqui, tá? Mas é a ideia de você, repare, é a ideia de que você tem alguma coisa, mas você não pode fazer qualquer coisa com aquilo. Você tem restrições pra forma como você pode usar aquilo. A discussão atual do Bitcoin é introduzir esse tipo de ideia. Na prática, tecnicamente, o que que significa isso? Significa eu expandi o acesso ao contexto que a transação, que o contrato das transações tá sendo executado. É eu poder ver essa transação aqui, ó. eu poder saber quantas saídas ela tem, quantas entradas ela tem, eu poder ler a assinatura de uma outra entrada, eu poder ver o contrato que tá numa certa saída. A gente não pode fazer nada disso hoje, tá? Mas se eu pudesse, eu poderia começar a falar coisas do tipo assim: "Ah, olha só, eu poderia aqui, ó, nessa transação escrever um contrato do tipo, ó, esse esse dinheiro só pode ser gasto numa transação que tem exatamente três saídas." Hoje a gente não consegue falar isso aqui. Eu poderia, se eu tivesse esse tipo de capacidade, eu poderia aqui na TX0 falar assim: "A transação TX1, que eu nem sei como é que vai ser, que é que nem sou eu que vou fazer, é o dono, é o novo dono da transação. Ele só pode gastar se tiver uma das entradas sendo paga pela Pubital. Se tiver a PUBIT tal tiver participando lá das entradas da transação, por exemplo, percebe o o o o a nuance que isso começa a introduzir? Eu aqui agora que tô pagando para sei lá, como é que teu nome, filho? Eu tô fazendo pagamento pro Antônio, eu escrevo a transação, certo? Eu escrevo já no contrato o que que você pode ou não pode fazer com o seu dinheiro que você tá recebendo de mim. Tô colocando restrições futuras no em cima daquele dinheiro. Isso é hã perderia um pouco da perderia um pouco da essência do Bitcoin. Que que você quer dizer com isso? Essência que o Bitcoin tem a questão de ser uma uma moeda. Então se você traga essa moeda de alguma forma você já tá virando de tipo de gestando de algo mais. Eu eu não, mas é continua sendo um contrato entre eu e ele, porque quando eu escrevo a transação, ele tá vendo o contrato que eu tô colocando na transação. Lembra? Eu posso fazer o pagamento para pagar a transação ser confirmada. E o Antônio tá vendo a parada e não concordar com aquilo e falar assim: "É, mas eu não, tipo, é, tu pagou, mas eu não vou te entregar aqui o carro que você tá comprando de mim, que esse contrato eu não aceito. Você não é obrigado. Lembra que a as transações de aqui tudo que a gente tá falando é um lado de de duas é uma é um lado da moeda. A transação de Bitcoin é o lado financeiro de uma transação que tem um lado real também. tem a contrapartida, certo? Eu vou passar a palavra para você, mas eu queria deixar uma pergunta no ar, que é porque eu escuto muito essa coisa. Ah, não é contra a essência do Bitcoin. Eu deixo uma pergunta no ar que eu não tenho uma resposta para ela, que é o que que é essa essência do Bitcoin? Não, pensa aí. Eu não sei o que que é processor, mas está sendo discutido na gente, né? Mas quem é o maior interesse dos usuários, das? De quem é uma Essa é uma excelente pergunta, de quem é o maior interesse disso aqui? Esses covenants, eles são discutidos muito num contexto de layers, layer to, de segundas camadas, de aplicações de outros protocolos que são construídos sobre o protocolo base do Bitcoin, tá? A gente vai falar disso. Eu vou falar em detalhes em particular. Eu vou falar em detalhes como é que funciona Lightning, que é o principal LR2 no Bitcoin, tá? Que é para vocês terem uma noção de como se constrói um um protocolo desse desse tipo em cima de outro, tá? Mas tem vários outros protocolos sendo propostos, tá? Lightning é o maior deles hoje no contexto do Bitcoin. Lightning é o maior deles, mas tem várias outras coisas muito interessantes acontecendo. Fora do fora do contexto do Bitcoin, mas vindo pro contexto do Bitcoin mais recentemente, tem a ideia de stable coin, uma moeda estável, uma moeda lastreada em outra moeda, uma moeda digital dessas aqui lastreada numa outra moeda, ouro, dólar. As mais as mais importantes hoje são as lastadas em dólar, que é o a do o SDT, que é da empresa Teter e o Dólar Circle, que é da empresa chamada Circle, tá? Eles emitem esses tokens, esses stable coin, são contratos e elas funcionam em várias blockchains, em várias blockchains. Blockchain da Solana, blockchain da Ripple, blockchain da da Etheréum, blockchain da Liquid, blockchain da base, assim, várias blockchains, tá? Mas tem um certo movimento hoje deante tentar trazer esse tipo de aplicação pra blockchain do Bitcoin também. Eu acho que seria bastante interessante. Eu pessoalmente, o problema é, tá, mas como é que a gente faz isso? É mais complicado do que parece, tá? E eu espero que ao longo do tempo vai ficando mais claro, vai ficando mais claro. Então esses covenantes em boa medida eles vão surgindo nessa discussão de segundas camadas, tá?

Qual é o a questão? A gente antes da gravação aqui a gente tava falando de que é muito mais fácil escrever software do que ler software, né? Tem um corolário disso que é o seguinte. Quando eu faço uma proposta de modificação no software, eu tenho uma intenção por trás, por trás daquele design. Ah, eu quero adicionar tal feature, eu quero fazer tal modificação para poder fazer tal outra ação, para me habilitar uma certa ação, certo? Então, a gente tem uma intenção por trás disso e é fácil de justificar isso. Qual que é o problema? É muito difícil de você perceber, de você descobrir, tá? Isso aqui vai me permitir tais novas ações que as que são intencionais. Eu quero que elas sejam possíveis agora, mas isso abre imagem para eu fazer um todo um outro universo de novas ações que são indesejáveis e essas são muito mais difíceis de eu descobrir quais são, porque essas são não intencionais.

Muito mais difícil mesmo. Normalmente, quando é que a gente descobre essas essas novas ações não intencionais depois que já tá em produção a parada?

Por quê? Porque é ali que começa a ter um incentivo real para alguém lá e fazer uma aplicação usando um algum tipo de exploit, aproveitando alguma, vamos chamar assim, entre aspas, brecha que a gente construiu ali, porque eu habilitei uma feature nova, tá? Esse é esse é o o balanço que a gente precisa encontrar aqui. E ao contrário de ao contrário de Silicon Valley, que tem esse tal mote de não faz rápido, quebra rápido, descobre logo os problemas, tá? Aqui não dá para fazer isso porque se eu quebrar a rede do Bitcoin agora, acabou, quebrou, não tem mais como consertar. Tipo, já era o projeto. A mesma coisa pro pro Etheréum, tá? Mesma coisa para outras para algumas outras redes. Meio que tu quebrar aqui agora meio que já era, já vai ficar quebrado para sempre, não vai ter muito como desfazer. E isso é um problema. Todo mundo bem? Todo mundo bem com isso, né? Deixa eu virar aqui. Deixa eu virar aqui. Isso aqui é uma documentação, vamos chamar assim, não oficial, mas de muito boa qualidade, tá? Que é o Bitcoin Wick. Põe no Google, aí você vai encontrar. Ahã.

É de muito boa qualidade, porque os caras que escreveram isso aqui, eles de fato tavam trabalhando no desenvolvimento do software também. Então isso aqui traduz em boa medida o que o software fazia num certo momento. Em boa medida, tá? Mas isso aqui tá bem desatualizado em vários aspectos, então tem que tomar cuidado, tá? Mas enfim, mas é informação de boa qualidade, tá? a gente vai ter essa noção de opcodes. Occodes são instruções e pensa em instruções de assembly, tá? Tipo, tem um OPCO ali e ela tem recebe certos argumentos que tem que estar nessa pilha ou vem do do contexto que é o que é os dados da transação, tá? Não precisa decorar os upcodes e a coisa toda, mas só para dar uma noção de que tipo de upcode tem aqui. Que tipo de OPC tem aqui? Eu tenho os opcodes mais, vamos chamar assim, mais primitivos, que são colocar dados na pilha, tá? Então eu tenho lá o op zero, coloca zero na pilha, o zero é o falso também. Eu tenho o um que coloca um na pilha e a gente vai interpretar o um como verdadeiro, tá? E assim por diante. Eu tenho, posso botar dados na pilha, né? Tipo, bota os próximos tantos bytes na pilha, tá? Então eu posso botar dados na pilha, eu tenho instruções de controle de fluxo, que é um condicional if else, tá? Basicamente, ó, eu tenho if ou not if, eu tenho else e eu tenho que colocar o end if. Aí junto nessa mesma categoria, eu tenho opn que não faz nada, literalmente não faz nada. Parece meio idiota eu ter operadores que não fazem nada, mas vocês vão ver que eles são úteis, eles permitem upgrade. Tem vários opnop, tá? Eu tenho OP verify, que é a semântica dele é vai no topo da pega o elemento do top do top do top dopo da pilha e checa se é verdadeiro. Se for verdadeiro, continua. Se for falso, falha o programa, a execução do programa. E eu tenho up return. O apurtan ele falha imediatamente. É uma basicamente falar assim, falha, deu pau, erro, tá? A gente vai ver aqui que o opereturn é uma é uma primeira forma de você colocar dados arbitrários lá na blockchain do Bitcoin. Tudo bem? A gente vai falar sobre isso hoje. Eu tenho vários operadores que são para manipular a pilha, tá? por exemplo, ã, sei lá, ver quantos, qual o tamanho da pilha, tirar um elemento da pilha, duplicar um elemento no topo da pilha, mexer raw. Raw é pegar um elemento que tá no topo e botar no fundo da pilha, enfim, tá? Swap é pegar dois elementos do topo da pilha e trocar ele de lugar. Enfim, tem vários operadores aqui que são para mexer nos dados, na ordem dos dados da pilha, tá? Repare que tem vários marcados de vermelho, tá? Vários marcados de vermelho. Esses que estão, esses em particular aqui, eles são de de é operadores que mexiam com strings e substrings. Você fatiar bytes em dois elementos, tipo, tem um elemento com vários byes, você quebrar ele em dois ou três, vários ou concatenar, né? Pegar dois e juntar num só, tá? Por exemplo, opcat um desses. Ele pega dois elementos da pilha e concatena os dados num novo elemento na pilha, tá? Isso aqui, esse daqui, ó, ele é extremamente útil, extremamente útil. É absurdo como esse daqui é útil. E aparentemente é uma operação extremamente simples, né, que é pegar dois dados e concatenar, tá? Extremamente útil. Eu não vou ter tempo de ficar mostrando muitos contratos desenvolvendo ele, tá? O que é uma pena. Mas ele, naquela discussão de cover que a gente tá vendo, ele é um dos principais atores, é esse operador aqui, tá? E ele tem um detalhe que é ele foi desabilitado, ele tava lá na linguagem no início, tá? E ele foi desabilitado. Então se o teu script tiver ocat hoje e aí tem os bytes dele aqui, tal, não sei o quê, talização, se o teu script hoje tentar executar um upcat, ele vai falhar. Esse é o comportamento hoje, tá? Por que primeiro quem desabilitou e como e por quê? O próprio Satosche desabilitou isso aqui lá em 2009. mais ou menos bem no início da rede, tá? E foi mais ou menos na mesma época que ele botou o limite de 1 me do bloco, tá? Eu não sei exatamente por, ninguém sabe exatamente por ele desabilitou vários opcodes, tá? Vários deles. O cat é fácil eu explicar para vocês um ataque com ele, mas tem outros que eu não vejo uma forma muito clara de fazer um ataque, tá? E vocês vão ver que eles aparentemente são meio inocentes. Não sei. E o Satoshi não explicou, simplesmente desabilitou. Ocat é relativamente fácil de você fazer um ataque, que é enche a pilha, vai colocando dados na pilha e concatenando eles. E aí concatenou, bota mais dados na pilha e vai concatenando. E aí repare que você tem o dup, né, que é duplicar. Então você pode fazer uma string bem grandona e ficar duplicando ela e concatenando ela com ela mesma, tá? Isso gera potencialmente uma string muito grande para botar numa numa célula da pilha, tá? Tão grande que eventualmente pode estourar a memória da máquina que tá executando aquele script. É um tipo de ataque de negação de serviço. E aí você crashar a máquina, tá? Crashar a máquina é mais sério do que parece. Por quê? Porque eu tô falando de crashar a máquina que tá validando a transação. E aí ela crashou, aí você reiniciou. subiu o node de novo, ela vai receber aquela transação de novo, imagina que aquilo tá minerado no bloco, ela vai tentar validar o bloco, vai crashar de novo, ou seja, ela não consegue mais aquele nó não consegue progredir, a blockchain dele não consegue progredir. Então ele na prática se desconectou da rede. Repare que crashar o nó é sério, tá? É em várias medidas equivalente a desconectar o nó da rede, tá? Esse é um tipo de ataque relativamente fácil de fazer com opcat, tá? Esse aqui é meio fácil de perceber porque que foi desabilitado, tá? Precisava desabilitar? Eu acho que não. Podia ter pensado um pouco melhor que que ele podia ter feito. Ah, ele podia ter botado um limite de tamanho nas strings, no no na pilha, por exemplo. Seria suficiente? Não sei, mas quem sou eu para dizer, né? Eu não tava lá tentando fazer essa parada funcionar, tá? Próximos operadores lógicos bitwais, né? Que mexe bit a bit, tá? Repare que eles foram todos habilitados, ó. Shore, end, or, inverter, tá? Eu tenho o e que checa se uma coisa é igual a outra e coloca verdadeiro ou falso no topo da pilha. E eu tenho Wi verify. O tudo que todos os OPCodes que terminarem com verify, eles a semântica deles é se der certo continua. Se falhar falhou o script, tá? Falhou. E aí repara, ó, o Satos desabilitou esses operadores que são manipulação de bit. Por quê? Não sei meu chute, porque vocês todos vocês fizeram sistema digitais, vocês viram que esses caras aqui são os ingredientes básicos da gente fazer qualquer computador. Então esses caras são os ingredientes básicos para você fazer basicamente qualquer computação, tá? É um pouco mais complicado do que isso, como vocês viram em sistemas digitais, né? Mas é são os ingredientes básicos, tá? Tem operadores de aritméticos, então tem soma, subtração, a multiplicação, a divisão foi desabilitada, mas eu posso negar valor absoluto, checar números são iguais, enfim, tá? Tem várias coisas, ó. Checar se número maior do que, menor que, o mínimo o máximo, enfim, eles só não excluí porque não dá para excluir. Porque não dá para excluir? Repara que o porque como a coisa já tava rodando, como a coisa já tava rodando, o máximo que você pode, se já tava rodando, já tinha transações na blockchain que precisam continuar válidas depois do upgrade. Lembra a história do softw? Precisa precisam continuar válidas depois do upgrade, tá? E o softwk é eu mudar regras que que restringem as regras. Então eu tô dizendo que você não pode mais usar um certo code. Eu tô restringindo a regra, entendeu? Só que qual foi exatamente sua pergunta mesmo? Deletou. Deletou porque não tem essa noção de deletar. Porque deletar? Por que que o que que significa deletar? Tipo assim, o que tem lá nas transações é um byte, que é esse baite aqui 95 que corresponde a esse operador. Quando a máquina tá lá parciando isso aqui, ela vê se bate 95, ela fala: "Beleza, eu tenho que multiplicar". Aí ela vai lá na pilha, pega dois números, multiplica e bota o resultado na pilha. Hã, disse que para ela isso já tava hardcore lá no início, entendeu?

Troca ele, troca ele. Poderia falar assim: "Ah, tá, o 95 agora não vai ser mais multiplicar, vai ser somar ou vai ser opnop." Só que isso é mudar a semântica das transações que já estavam incluídas, dos scriptos que já estavam incluídos na blockchain. Isso é um hardfork. Isso eventualmente transforma as transações que que eram válidas em no passado em inválidas hoje no presente.

Nesse aspecto sim, apesar do Satos ter feito o R forx aí no meio do caminho,

ainda dava tempo de fazer hardfock e dar uma boa consertada nessa coisa aqui logo no início. Meio que dá um reset assim, mas mas é o que é e é o que ficou, tá? Agora para reabilitar esses caras aqui é um problema, é um problema que foi foi meio que já resolvido. Vou mostrar para vocês como tá, mas foi resolio convoluta, é bem mais complicado hoje em dia de usar esses caras aqui, tá? Não tô dizendo que eles estão habilitados, mas agora a gente tem um caminho para habilitar eles e outras coisas. Vamos lá, ó. Tem alguns operadores são expressivos de cripto. Tem operadores que calculam hashs, diferentes tipos de hash. Muita atenção nesses dois aqui, ó. R 160 que calcula chá, pega um dado na no topo da pilha, calcula shad 256 dele, depois calcula com o resultado um outro hash que é R MD 160, que é um hash que cospe 20 bytes em vez de 32 bytes, 160 bits. E tem chá 256 duplo, tá? Tem o chá 256, tem chá 1, tem outras coisas. Tenho esse operador check e tem o check sigfy. O check sig ele pega uma uma assinatura uma pub key e uma assinatura da no topo da pilha. Usa como mensagem a transação que tá tentando gastar, é o contexto dela, e valida aquilo, checa aquela assinatura. Eu tenho um operador que chama check multisig, tem versão verify dele, que requer várias assinaturas. A gente vai ver um exemplo usando Multisig aqui hoje para ficar um pouco mais claro de como é que ele funciona. É bastante usado. Eu tenho esses dois aqui que são operadores mais novos. A gente vai falar deles bem mais pro final da aula, que é o check lock time verify e o check sequence verify. Esse cara aqui pessoal normalmente chama de é CLTV, que é check, lock, time verify, são as iniciais. E esse outro cara aqui vocês vão ver com a sigla e CSV, que é check, sequence, verify, são as iniciais das palavras, tá? Lock time é um campo da transação e o sequence é um campo que é da entrada de cada transação. De cada uma das entradas tem um sequência que você me perguntou ali, que que é aquele sequência aqui atrás? Cadê o meu caderno? Ó lá, o sequence é um dos campos da entrada da transação. Cada uma entrada tem um sequence. E a gente consegue pegar esse sequence e inspecionar ele com aquele com aquele opcode, tá?

E aí tem alguns que são reservados, tá? Tem o reservado, blá blá blá, versão, não sei o quê. Os os os mais relevantes são esses aqui que são NOP. Qual que é a semântica deles? Não faz nada, tá? Para que que eles servem? Eles servem pra gente fazer upgrade. Esses aqui, como é que teu nome mesmo, filho? Esses aqui, Pedro, a gente consegue usar para mudar o que que eles fazem, tá? Que foi o caso desses dois, ó. Esse aqui era opnop 2 e esse aqui era o opnop 3. Ele, esse aqui não fazia nada e esse aqui não fazia nada. E agora eles fazem alguma coisa, tá? Só tem que tomar um cuidado que é pros nós antigos que não forem upgraded na regra nova, esses caras têm que continuar fazendo o que eles faziam antes. Então eles têm que ser nops, eles não podem alterar a pilha. Percebeu? Esses caras aqui, ó, eles são verify, eles não alteram a pilha. Eles não podem tirar nada da pilha, não podem colocar nada na pilha. A única coisa que vocês podem fazer é ver os dados da pilha e prosseguir ou falhar.

Isso é um problema. Isso é bastante restrição em cima de várias coisas que a gente quer fazer. Porque é bem interessante se eu pudesse ver os dados na pilha e produzir novos dados na pilha, coisa nova, tá? A gente não pode usar os opnop para isso. Todo mundo ok com isso? Esse é o universo de opcodes que a gente tem, tá? Repare o que que eu não tenho. Eu não tenho ou for, não tenho instrumento de repetição e eu não tenho jump, go, esse tipo de coisa. Eu não consigo voltar à execução do script, só consigo andar pra frente, tá? Essa é a principal restrição nesses scriptos, tá? H,

deixa eu dar um antes da gente parar pro intervalo, deixa eu dar exemplos, dois exemplos para ver como é que é a execução e aí depois do intervalo a gente vê os contratos que os contratos entre aspas de verdade, tá? Mas esses dois aqui são bons para ver como que é a execução da coisa, tá? O primeiro que eu quero mostrar aqui para vocês é um tipo de contrato que é meio boboca, que a gente chama de anyone can spend. Anyone can spend. Não é um contrato específico, é uma família de contratos, tá? É uma família de contratos cuja lógica é muito é trivial você qualquer pessoa ir lá e descobrir ou calcular o que que tem que ser dado de informações para poder gastar, tá? E eu vou mostrar aqui para vocês sempre dessa forma aqui, ó, o lock e o unlock script. O lock tá na saída da transação para travar o gasto. E o unlock é o que precisa aparecer na entrada na hora que eu tô tentando gastar, tá? Para contexto, o lock aparece aqui, o unlock aparece aqui, tem que aparecer aqui. Não tira isso de mente. Da mente. Tudo bem? Tá. Senão você não entende o bagulho. O primeiro deles é o seguinte, é um um um script mais trivial que você pode pensar aqui. Coloca verdadeiro no topo da pilha. Esse é o contrato, tá? Como é que vai ser a execução disso? Eu tenho, começo com a pilha vazia, primeiro é executado o unlock script. Repare que ele pode ser um script vazio que não faz nada. Então, nesse caso, que ele não vai fazer nada, mas principalmente ele não falha, ele não altera a pilha. Terminei de executar, eu vou passar a execução do lock script. Nesse caso aqui, coloca verdadeiro no topo da pilha. Acabou a execução do programa. Acabou a execução do do programa. Repar que os dois programas combinados é um programa só, tem que rodar, tá? Em princípio, em princípio, tá? O unlock gera dados para preenche a pilha, o lock consome a pilha. Essa é a ideia básica. Mas o o unlock pode mexer na pilha, criar dados e consumir. E o lock pode criar dados na pilha e pode fazer o que ele quiser. Mas a ideia básica é essa, tá? O unlock vai preenchendo a pilha e o lock, o lock vai consumindo da pilha e verificando. Essa é a ideia básica. Esse caso aqui, o topo da pilha tem verdadeiro. E a semântica é, se no final da execução o topo da pilha for diferente de falso, o falso é o zero ou a pilha vazia. Aqui tá diferente de zero e tá diferente da pilha vazia, tá? Eu vou considerar esse contrato como tendo sido satisfeito e eu vou autorizar o gasto. Claro que tem outras partes de validação que precisam acontecer, mas da parte do script do contrato é isso que vai acontecer, tá? Esse é um tipo de contrato bem trivial, tá? É um contrato bem trivial, mas ele é um contrato que a gente faz o tempo todo. Eu vou mostrar aqui para vocês por que que a gente faz o tempo todo. Porque perceber que existe esse tipo de contrato é perceber o caminho para eu conseguir mexer nos scripts, alterar as regras e ainda conseguir fazer um soft fork. Por quê? Qual é a ideia básica? é mexer nas regras de tal forma que os nós novos vão fazer alguma coisa nova, a regra nova, mas os nós antigos vão achar que aquela coisa que tá ali é um anyone can spend e aí eles não e aí eles autorizam o gasto. Então repare por que que isso é um soft fork? Porque os nós antigos estão autorizando gasto, mas os nós novos tão seguindo uma regra que é mais restritiva, que pega coisas que eram válidas no passado e transformam em válidas no presente ou no futuro. Isso é o softwk. O que eu não posso fazer é o contrário. Coisas que são válidas no passado se transformarem em válidas. Hoje o NOK não fez upgrade, eu quero que ele continue validando. Deixa quieto. Tudo bem? Esse aqui é o caminho do soft for nos scripts do Bitcoin. Hoje eu tendo a achar que conceitualmente esse é o tipo de contrato mais importante no Bitcoin, por cria. E ele é o tipo de contrato mais boboca que tem. Afinal, qualquer um pode gastar o dinheiro, mas ele é o caminho, ele, esse cara é a chave para eu fazer upgrade no sistema para eu poder mudar as regras. Vocês vão ver, eu vou mostrar exemplos concretos de dois upgrades, do seg do Tapert. Os dois usam esse mecanismo. Todo mundo bem. Outro exemplo de anyone can spend, um pouquinho mais sofisticado, mas ainda assim trivial. Esse aqui, ó, o lock é assim. Coloca sete no topo da pilha, soma os dois dados que tem no topo da pilha. Então, por aqui você já percebe que o unlock script precisa colocar alguma coisa no topo da pilha, porque senão o ed vai falhar, porque ele consome dois dados do topo da pilha. Se só tiver um, falha, tá beleza? Soma os dois caras. O resultado vai pro topo da pilha. Coloca 15 no topo da pilha e checa se os dois são iguais. Que que esse script tá fazendo?

Bora. Que que esse script tá fazendo? Ele pega um dado X na pilha e faz o quê? che se ele é oito. Não, ele não checa se ele é oito.

Ele checa se X, que é o dado que que eu vou botar no topo da pilha, no unlock script, mais 7 = 15. É isso que ele checa. Ele não checa se x é igo. Toma muito cuidado com isso. Parece que é a mesma coisa, porque o oito satisfaz aquela aquele aquele contrato. Você tá vendo? Botar oito no topo da pilha satisfaz aquele contrato. Mas cuidado, porque pode ser que exista alguma outra string que eu coloque lá no topo da pilha que na hora que é avaliado esse contrato, ele também dá verdadeiro. Ah, professor, mas isso é um bug. É, mas se se esse bug existir lá na parada, esse X é o que é e ele vai ser válido também. Então, toma muito cuidado com isso. O contrato é muito literal, é igual a software, tem que ser extremamente literal, tá? E essa história do bug é extremamente relevante. E isso aqui é um problema, um problema. Um problema para mim é um problema que é é muito difícil você rodar outro software por quê? Outra implementação disso aqui que não core. Por quê? Porque qualquer outra implementação precisa copiar os mesmos bug do Bitcoin core, inclusive aqueles que a gente nem sabe quais são.

Vários bugs a gente sabe quais são, a gente conhece. A gente não pode mexer porque seria um hardfox. Mas a gente conhece, então a gente pode vir lá botando os ifels lá no meio do caminho porque coisa conhecida. O problema é são os bugs que a gente não conhece. E se eu faço uma outra implementação e ela tem um o Bitcoin Core tem um bug desconhecido e a minha implementação não segue o mesmo mesmo comportamento, a uma transação válida pro Bitcoin Core, eventualmente vai ser inválida para mim. E aí eu fiquei desconectado da rede do do da rede dos nossos que rodam a outra implementação e numa rede de consenso, isso é um grande problema. Um grande problema. É um problema que a gente tá tentando evitar com todas as forças.

Que que sugera de efeito colateral no mundo real? Você vai olhar 99. Muitos por cent da rede roda o mesmo software, versões diferentes do mesmo software, mas o mesmo software. Eu acho isso um problema. Eu acho, pessoalmente, eu gostaria de ver mais implementações. Quantos bites tem esse dado colocado na? Em princípio tem um limite lá, mas em princípio é arbitrário. Esses números aí acho que são, o, se eles forem interpretados como números que a OPED faz, são números de 32 bits. Mas em princípio você pode botar dados arbitragem lá, pode botar tonelada de bits lá cada célula da pilha. Todo mundo bem até aí, tá? Qual é o unlock script dele aqui? Coloca oito no topo da pilha.

Repare que é trivial, qualquer um consegue descobrir esse essa informação. Hã, oi 32. Então, percebeu que tem vários eventualmente, mas repare que eu não preciso botar só oito. Eu posso botar, por exemplo, põe quatro no topo da pilha, duplica o que tem no topo da pilha, soma o que tem no topo da pilha. Dá na mesma, né? semanticamente dá na mesma, você concorda? Vai cumprir esse contrato do mesmo jeito, tá? Agora, reparem, isso aqui também é uma outra técnica que a gente vai usar, vocês vão usar, a gente usa isso que é expressar alguma ideia usando mais coisas do que o necessário.

Eu podia simplesmente botar oito lá no topo da pilha, mas eu posso escrever um outro programa. que gera o mesmo efeito, mas que tem mais dados aqui, ó, no programa. O programa tem mais dados. Eu preciso de mais dados para representar esse programa. E esses dados podem querer dizer alguma coisa fora desse sistema aqui para eu querer talvez introduzir dados arbitrários aqui, ó, na transção de Bitcoin. Que que significa escrever um JPEG lá na na na blockchain do Bitcoin? é colocar dados aqui, ó. Aqui é o único lugar que eu tenho para escrever dados na parada inteira. Por quê? O que que vai nos blocos? O cabeçalho, que a gente viu que não tem lugar para você escrever coisas arbitrárias. E tem as transações. O que que tem nas transações? Tem o número de versão 4 bit, 4 bytes. Tem o lock time 4 bytes. Você não pode fazer usar de qualquer jeito. Tem as entradas, que é isso aqui, ó, que é o unlock. O unlock tem as entradas, eu tenho que gastar alguma coisa válida. Então tem que ter um TX ID válido, um index válido e tem que ter um sequence, tem uma semântica própria também válida. A única coisa que eu posso escrever alguma coisa ali que não tá pré-determinada é no input, que é o unlock aqui que a gente tá vendo. Que mais tem na transação? Tem a saída. Cada saída tem um amount que é prédeterminado, é quanto eu tô gastando e tem um script que é o que é o lock que tá aqui, que é alguma coisa que eu posso ter alguma flexibilidade para escrever. O que que significa escrever dados na blockchain? Que que significa escrever um JPEG na na blockchain? É dar um jeito de pegar os bytes que eu quero e colocar nesses dois contratos aí, ó, nesses dois programas, porque é o único lugar que eu tenho para escrever alguma coisa que já não tá prédeterminada.

Preciso repetir. Vou repetir. Como que eu coloco dados na blockchain? Escrevendo esses contratos aqui, ó. Lock, unlock. Agora, repar que eu não posso fazer de qualquer jeito também. Por quê? Porque eles têm uma semântica, né? Isso aqui, esses caras juntos representam um programa de computador e ele precisa fazer alguma coisa, ele precisa validar a transação. Então, tem uma tonelada de restrições em cima. Eu vou mostrar para vocês como é que escreve dados arbitrais na blockchain. Mais de uma forma. Tá, mas de uma forma. Oi. Tem algum quê? Algum dado?

Tem vários dados muito icônicos. Tem um PDF enorme feito aí. Recentemente teve um monte de transação que quando você pega elas juntas, ela leu um texto assim gigantesco, meio esotérico, ah que no tipo meio que uma profecia assim que vai ao não sei quem vai pegar as bombas nucleares, não sei aonde, blá blá, tipo uma parada muito louca assim, tá? Pessoal escreve de tudo aí nesse negócio aqui. Pessoal escreve de tudo, pode imaginar que tem de tudo. O white paper do Bitcoin tá lá, tá lá o PDF, sacou? tá lá e tal. Aquele jornal lá que onde é que o Satos botou? Onde que o Satos botou a a manchete do jornal? Ele botou no script Sig da Coinbase Transaction da do Genesis Block,

que segue regras meio particulares porque ali não vai ter um programa que vai ser executado, tá? Ali você realmente pode botar dados arbitrariamente. Todo mundo OK com isso aqui até agora? Tá? Ó, eu não falei nada ainda de contratos, de contratos espertos, é o que a gente vai fazer na segunda metade da aula. Mas isso que eu falei aqui agora, o que eu que eu coloquei aqui agora, se tu entendeu isso, tu entendeu tudo que as outras blockchains estão tentando fazer, porque a maior diferença entre elas é o que é que eu posso colocar aqui nesses contratos. E várias outras, as outras blockchains, elas têm linguagem, uma linguagem diferente para você escrever esses contratos em algum, em vários aspectos mais poderosas, você faz mais coisas. Algumas blockchains aqui nas nas transações aqui, ó, elas têm campos específicos para você botar dados arbitrários. Elas são feitas para isso, tá? Mas todas elas são alguma variação disso que a gente tá vendo aqui agora. Não tem muita invenção não. O o que tem de muita invenção é como que a gente usa dados arbitrários colocados aqui. Isso eu não vou explicar hoje, eu vou mostrar vários contratos. Tudo isso é sistemas que a gente vai chamar de segunda camada, que são outros clientes que pegam essas transações e vão interpretar esses dados de alguma forma diferente do que o que tá aqui. Então tem os nodes rodando, validando, seguindo a blockchain. Então tá lá construindo a blockchain, seguindo blá blá pagamento para lá e para cá. E tem outro cliente que vai lendo aquela blockchain e vai vendo, interpretando aqueles dados que estão começando a aparecer lá naquela blockchain. É isso que que vamos chamar assim, uma segunda camada. E aí você faz uma outra lógica naquele outro cliente, como quase como se a blockchain fosse um banco de dados. Você vai lendo, passeando um banco de dados meio esquisito, vai lendo e tentando extrair dados dali. Tudo bem? Vamos fazer um intervalo agora e na volta a gente começa a falar dos contratos padrão.