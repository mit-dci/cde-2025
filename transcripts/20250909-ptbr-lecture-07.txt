Então vamos lá. Falamos de crirypto, falamos do Vamos falar de como é que funciona então entre aspas agora o banco distribuído. Não falando é o que a gente quer fazer, né? Tá? Vamos lá. Lembra qual é o problema, tá? Lembra qual é o problema? O problema é quando eu tenho o banco, o que que o banco faz? Ele mantém uma lista dos correntistas e o saldo de cada um. Ele mantém registro do balanço de cada um dos correntistas, tá? Basicamente é isso que tá acontecendo. Então eu tenho a hélice aqui, tem o Bob aqui. Quando a hélice quer fazer um pagamento pro Bob, o que que ela faz? Ela manda uma mensagem pro banco falando, eu quero transferir, eu quero pagar cinco dinheiros pro Bob. Aí o banco checa se ela tem o saldo. Subtrai daqui, virou cinco, soma aqui, virou 10. E aí o banco manda uma mensagem pro Bob e fala assim: "Ou atualizei teu balanço". Aí basicamente isso que acontece. Que que a gente quer fazer agora? A gente quer fazer um sistema que é bem parecido com isso aqui, mensagem uns pro outro, só que não tem o banco, só que não tem um banco no meio. A gente quer que as pessoas se virem e dê um jeito de fazer isso sem o banco, tá? A gente viu que parte do problema é que agora cada um vai precisar manter uma cópia do registro e vai precisar gerenciar essa cópia do registro. E aí manter a sincronia disso, manter a consistência desses registros é o que é o grande problema, tá? a gente comentou, mas eu vou entrar em mais detalhes provavelmente na aula que vem de uma dos mecanismos de a gente poder sincronizar esses blocos aqui é não ter uma um participante especial que nem o banco. Qualquer um pode ir lá e criar um registro novo e atualizar o registro de todo que em princípio vai serve para atualizar o registro de todo mundo, tá? E a ideia é que qualquer um deles pode fazer, mas essa é uma operação cara. E aí o custo de fazer isso é o que protege o o sistema de ataques, que é alguém tentando fazer um um pagamento, vamos chamar assim, malicioso aqui, ou tentar gastar dinheiro que não tem, ou tentar aumentar o seu saldo de maneira sem receber dinheiro, criar dinheiro do zero, esse tipo de coisa, tá? E aí tem básica, o que a gente vai ver agora são as tipo as essas mensagens que esses participantes vão trocar entre si, tá? Que é a mensagem falando tira dinheiro do A, deposita dinheiro no B, tudo bem? Que é as mensagens que o Hélice e o Bob trocam aqui com o banco, tá? E a gente tem basicamente duas formas de fazer isso. Duas formas de fazer isso. O primeiro tipo de sistema é o que a gente chama de account based. Account based, onde cada participante vai manter uma um balanço ali, tipo um sistema de contas também, um registro de um sistema de contas, igual o banco faria. Então, a hélice tem aqui o registro de, sei lá, a hélice tem 10 dinheiros, o Bob tem cinco dinheiros e o Bob tem um registro também que em princípio fala, ó, ele tem 10 dinheiros, o Bob tem cinco dinheiros. Vamos imaginar, sei lá, tem um Charlie, tem o mesmo registro. Hélice tem 10 dinheiros. O Bob tem cinco dinheiros. Tem cinco dinheiros. O que que me interessa aqui agora é o que eu vou chamar de transação.

A transação é uma mensagem para que os participantes alterem o estado do sistema. E o que que é o estado do sistema? Estado sistema é o que que tem no registro deles num determinado momento. Uma máquina de estados mesmo. Isso aqui é o estado atual. A transação, a transação é alguma coisa, é a função de próximo estado, que é dado o estado atual, dada essa transação, qual que vai ser o próximo estado? E aí cada um desses participantes precisa calcular isso, tá? Num sistema baseado em no baseado em contas, tá? baseado assim, não só no sistema baseado em contas, tá? Mas no sistema baseado em contas. E aqui exemplo de sistemas baseado em contas, banco tradicional, Etheréum e tem outros blockchain que são baseadas em sistemas, nesse tipo de nesse tipo de sistema aqui, tá? Uma transação é uma mensagem. Imagina que a Hélice vai fazer um pagamento pro Bob, então ele vai produzir uma certa mensagem aqui. E o que que tem nessa mensagem, tá? Que que precisa ter nessa mensagem? Valor. Valor. Vamos lá por partes. O valor é um amount. Quanto que ela tá pagando? Faz sentido, né? Que mais faz sentido botar aí? O destinatário. Eu vou chamar aqui de PI. PI é quem tá recebendo, né? É o alvo do pagamento. Que mais?

data, data a data de hora, né? Dia, hora que está acontecendo. Pode ser. Mas que mais que faz algum sentido? Hã? Quem tá pagando, né? O payer, quem tá pagando? Que mais? Tem mais alguma coisa que precisa entrar aí?

Ah, o blocoal não, não esquece bloco por enquanto. Pensa que tem o estado atual, tem a leder, cada um tem ali um a tabela com saldo de todo mundo. Assinatura que é, mas uma assinatura. Por quê? Por que que eu botaria uma assinatura? para provar que sou eu para provar que é a hélice que tá de fato construindo a mensagem, autorizando o gasto. Ou você chega lá no banco, liga lá e fala assim: "Ou vocês são, sei lá, qualquer pessoa, você vai lá ligar no meu banco ou transfere R$ 1.000 da conta do edil para essa conta aqui que eu vou te passar agora". É assim que funciona a parada? É assim que funciona a parada. Que que o banco te te fala? Não, ele não fala não. Ele fala: "Prova que você é o Edil".

Hã? Não esquece isso não. Não é o que o banco faz. Ele verifica se você é quem você de ser, tá? Precisa de algum esquema de autorização. Vou marcar aqui. Vou marcar assim. precisa ter algum esquema de autorização de a hélice, que é o payer, o pagador, autorizar os o gasto, senão o sistema era trivial aqui, tipo, qualquer um gasta dinheiro de qualquer um, tá? Esse essa autorização vai envolver algum tipo de assinatura digital. O identificação de quem é o pagador e de quem é o pagado, o pagado é que tá recebendo. Eu eu acho bem feio em português, mas é isso aí. o pagador e o pagado, a gente vai usar algum esquema de chave pública e privada. Então, bastante comum a gente identificar eles com a chave pública, chave pública de cada um ali. O amount é quanto que eu tô pagando? Quanto que eu tô pagando, tá? Então, repare, eu preciso da data. Essa é uma pergunta. Eu preciso dessa data aí? Assim, eu acho que poderia ser um informação externa também, né? Poderia ser uma informação externa. Se eu não tiver a data, a gente viu que porque olha só o negócio aqui, se eu botar a data, o quanto que eu posso confiar nessa data? Quem tá produzindo essa mensagem? A primeira pergunta é: quem tá produzindo essa mensagem? A hélice, no caso aqui, ó, as setinhas aí, a hélice tá produzindo essa mensagem. A pergunta que eu para cada um desses campos aqui, eu preciso me fazer a pergunta: o quanto eu confio na hélice para produzir essa data? Porque essa mensagem vai chegar aqui no Bob e o Bob vai olhar e falar assim: "Tá, esses eu vou aceitar esses dados aqui como verdadeiros. Preciso de algum processo para isso, mas vou ter alguma regra para isso. Vou falar: "Tá, eu aceito os dados verdadeiros". Vocês concordam comigo aqui? Para eu checar a data, eu preciso ter um relógio aqui também, ó. Preciso ter um relógio aqui, preciso ter um relógio aqui. E eu preciso ter uma forma de sincronizar esses relógios. E a forma de sincronizar o relógio é ter um servidor central para sincronizar a hora e todo mundo sincroniza com aquele servidor central. Precisa ter uma referência de tempo. Só que isso centraliza o sistema. Essa essa parte do tempo viraria uma peça centralizada no sistema que eu quero descentralizar tudo. Eu quero ter totalmente trustless. Eu não tenho nenhuma parte de confiança, tá? Então eu não vou ter um sistema para sincronizar os relógios. Então, se ace uma transação, fala que é 10 horas da manhã e chega para mim lá no meu relógio, é meio-dia, qual que isso quanto que isso serve? Quanto que isso serve? Entendeu? E mais, a gente viu ali no começo do curso que o grande problema é ordenar as transações, né? É ordenar as transações. Por exemplo, imagina que a tá fazendo um primeiro pagamento, pagando 10 pro Bob. E a hélice é o pagador. Aí ela fala que, sei lá, 10 horas da manhã ela, isso aconteceu. Aí ela manda essa, propaga essa transação. Aí ele depois vai lá e cria uma outra transação pagando 10 pro Charlie. Ela tá fazendo aqui, assinou, assinou e ela fala assim: "Deois, tá, no futuro vai lá e fala assim: "Não, essa daqui é às 9 horas da manhã". E a gente viu que o problema disso aqui é qual veio primeiro, porque a que veio primeiro, eu preciso ter uma alguma forma de definir qual é a transção que veio primeiro, porque se essa aqui veio primeiro, essa transção é válida, porque ace não tem mais 10 dinheiros para gastar. Se ao contrário essa aqui for a primeira, eu escolher como se definir, como sendo na primeira, essa aqui tem que ser inválida, porque a Bis não tem 10 para gastar. Então, repare o problema que tem envolvido nisso aqui, tá? A hora aqui é a coisa mais complexa de checar. E como é que a gente vai resolver esse problema? a gente vai resolver esse problema depois lá com aquela história de prova de trabalho e e alguém alguém depois coletando essas transações, falando: "Beleza, essa veio primeiro, depois essa, depois essa escolhendo uma ordem e e esse processo tem que ser caro. E o fato desse processo ser caro é o que vai garantir que vai ter alguma segurança na coisa. Bit não consegue ser usado como moeda corrente, né? Não necessariamente. Isso é uma afirmação muito forte. Bitcoin não pode ser usado como moeda corrente. É controvérsia. muita controvérsia. A gente fala sobre isso, sobre isso, porque tem várias formas de resolver. Isso. Vai ser um problema de escala, provavelmente porque você tá pensando é: "Tá, mas uma transação de Bitcoin demora algum tempo para ser confirmada." Sim, ela demora algum tempo para ser confirmada, mas a gente tem formas de e esse tempo, uma coisa demorar muito para acontecer é um problema de escala, né? Quando eu quero muitas coisas acontecendo por segundo, se cada coisa demora muito para acontecer, eu não consigo ter muitas coisas, uma taxa muito grande. Só que a gente consegue criar outros sistemas, outros protocolos. E esse é um outro problema de escalabilidade, que é o problema de escalabilidade no tempo. Eu quero ter mais transações no tempo, tá? A gente vai ver formas de de lidar com isso. Todo mundo OK com isso aqui? Todo mundo OK com isso? No Etheréum, tá? no etheréum, como que é a cara da transação? Porque a transação é uma estrutura de dados. Repara que isso aqui é meio que entre aspas o mínimo que eu preciso para poder caracterizar um pagamento de pagamentos. Quem tá pagando, para quem tá pagando, quanto tá pagando e é uma forma de autorizar que aquela pessoa que está pagando de fato está autorizando aquilo ser pago, aquele gasto ser feito. Essas quatro informações que eu preciso ter numa transação, tá? E depois eu preciso ter alguma forma de resolver a ordem delas, que vai ser n usando esse esquema de prova de trabalho ou algum outro esquema de consenso da gente ordenar essas transações. Prova de trabalho não é o único esquema, tá? Inclusive, Etheréum hoje não é mais prova de trabalho, era prova de trabalho início e hoje é um outro esquema que a gente proof of stake. Vou comentar mais paraa frente essas alternativas quando for pertinente, tá? Autorizam, tipo essa mudança de protocolo perdão. Como é que eles autorizam essa mudança de no caso da do Etheréum? É, ou de qualquer coisa do Bitcoin também trocou uma parte lá em 2019. Hum. Esses upgrades, em princípio, é como é que eu mudo regra no sistema? Essa é a pergunta. A gente vai falar sobre isso num tópico que eu chamei de governança, porque isso aí é muito mais complicado do que parece. Toda vez que isso é uma meio que entrasse uma entrasse, isso é meio que uma forma de você identificar um sistema que é descentralizado de um sistema que é muito centralizado, que é quão difícil é mudar uma regra, porque se for fácil mudar uma regra, quer dizer que isso é muito centralizado. Alguém decidiu uma regra nova e todo mundo tem que seguir. Quer dizer que é muito centralizado, tá? Ao contrário, um sistema que é muito descentralizado, quer dizer que essa decisão de quais regras vão ser implementadas, ela ela ela tá muito pulverizada nos nossos nos agentes. Então, pode ser que a Hélice e o Bob decidam mudar uma regra e o Charlie não. E continu e aí que que a gente faz com isso? Que que a gente faz com isso? Como que a gente faz? Então, tá, em princípio, no Bitcoin a gente vai diferenciar o que que é o soft fork e o hard fork. É mudanças de regras que expulsam o Charlie, já que ele não quer seguir a regra nova, ou mudanças de regras que não expulsam o Charlie se ele não quer seguir a regra nova. E a gente vai lidar, vai tratar sobre isso, tá? Isso é uma questão de governança, todo mundo OK aí, tá? Mas o Bitcoin não é assim. Várias outras moedas não são assim, tá? E os qual é o grande, qual é o principal problema dessa parada aqui, tá? Qual é o principal problema dessa parada? É o que a gente chama de ataque de replay. Replay é, como é que fala em português? Repetir. Repetir uma mensagem. Hã, replay. É, tá. Ataque de replay. Porque pensa que eu tenho uma transação aqui. Pensa que eu tenho uma transação. Tem essas informações, transação válida. Em princípio, é muito fácil eu pegar essa transação aqui, copiar ela mesmo. Tipo assim, eu sou um outro nó na rede, eu vi essa transação porque eu preciso atualizar meu meu meu meu meu estado aqui, eu sou o Charli, por exemplo, e eu pegar e propagar uma cópia dessa transação, da mesma transação, bum, propagar uma cópia dela na rede. Eu preciso ter algum mecanismo que impeça isso de acontecer, tá? E isso é bem mais difícil do que parece nesses tipo de sistema. é bem mais sofisticado de conseguir fazer funcionar direito nesses sistemas que são baseados em contas. É bem mais difícil do que parece, tá? Preciso de algum esquema, algum esquema criptográfico, normalmente envolve um certo aqui. Esse nãoce é um normalmente é um contador. Para eu falar assim, essa transação é a transação número 1000 da hélice.

Só que que acontece se eu fizer isso, todo mundo que tá aqui precisa guardar não só o saldo da hélice, como qual é a transação, a última transação que ace fez. Eu preciso guardar mais estado. Isso é aumenta muito a complexidade da coisa. Tipo, parece uma besteirinha, mas aumenta muito a complexidade da coisa, tá? Por quê? Por que que aumenta muita complexidade da coisa? Imagina que eu tenho aqui, ó, o N é quantas transações a hélice já fez. O M é quantas transações o Bob fez. Imagina que tá sincronizado aqui. Que que pode dar errado nisso aqui? Como é que poderia acontecer isso?

Não pode manipular o número da mais simples do que isso. Nem pensa que em em alguém manipulando alguma coisa de propósito para sacanear. Alguma coisa que aconteceu aí. Ih, olha só, tipo, sair de sincronia sem querer. Aí eles pagam o B. Hã? Aí eles pagam o B, Bob paga a o Charlie. Char não tá complicando.

O Charlie, imagina que o Charlie por algum motivo saiu da rede, ele nó dele caiu, acabou a energia lá onde tá rodando. É um computador, acabou a energia onde tá rodando, acabou, ficou sem internet, rompeu um cabro, sei lá, qualquer coisa que aconteceu. Ele saiu da rede durante um tempo. Se ele saiu da rede, ele não viu as transações atualizando o N para um N linha.

E aí na hora que ele voltou pra rede, ele tem o estado antigo aqui ainda. Como é que eu sincronizo essa coisa? Percebo que isso é um problema. Isso é bem mais complicado do que parece de resolver, tá? Bem mais complicado de do de resolver do que parece. Porque agora eu preciso sincronizar tanto o saldo quanto esses esses nonces aqui, tá? Um estado da rede que todos guardam. Aí se isso acontecer, se ele pegar estado se não tem um estado da rede que todos guardam, todos estão guardando o estado da rede, mas cada um tem uma visão local do estado da rede. Não existe uma noção global, porque a noção global aí você tem um servidor e aquele servidor é fonte trofs, né? So of truth, tipo fonte da verdade do sistema. Eu não tenho mais essa fonte da verdade. Cada um tem que cada um tem que tomar decisão com a informação que ele tem ali naquele momento. Como é que você Pera, pera eia meismoação inevotente? Ela ela você repete ela, mas o valor dela vai fazer uma coisa só. É mais difícil do que parece também de implementar isso, de achar uma construção criptográfica que tem essa propriedade.

Pergunta esqueceu, tá? O char só vai ter interesse nesse M se ele for realizar uma transação, porque olhar o M por olhar não tem interesse nenhum. Então ele só eh ele pode atualizar isso quando ele for fazer alguma transação com a Elix ou com o Bob. Aí ele busca dentro do do registro do Bobb da Hélix, o novo M. E por que que ele deveria confiar na hélice? Hã? E por que que ele deveria confiar na hélice? Aí eu já não sei qual o mecanismo de confiar. Essa é a pergunta. É confiar. É, eu te peço uma informação, você me dá e eu vou olho e fala: "Tá bom, a informação eu vou começar a usar como se fosse correta". Isso é confiar. Não, mas aí a informação vai estar lá registrada. Ela não vai fornecer a informação que ela quer. Ela vai o registro que vai tá lá. Mas ela, lembrem gente, a L só tem acesso ao registro dela. O Bob só tem acesso ao registro dele e o Charlie só tem acesso ao próprio registro. Se eu olho e falo assim: "O meu N tá desatualizado, eu vou pedir um N para alguém. Se eu pedir pra hélice, eu preciso me perguntar a hélice, como é que ela pode me sacanear? E como é que eu posso me proteger da pode estar desatualizada? É porque ela pode estar maliciosamente tentando manipular aquilo, como ela também pode estar fora de sincronia. Percebam que é bem mais complicado responder isso. Eu não vou responder como é que funciona nesses account bas systems aqui, mas dá para fazer funcionar, tá? Ó, Etheréum tá aí, tem outras moedas que funcionam assim, tá? Eh, hyper LED, tudo é baseado nesse tipo de mecanismo. Eu vou mostrar como é que funciona o Bitcoin, porque no Bitcoin é é meio estranho e precisa de um pouco mais de explicação. Pode pegar as as últimas informações do último bloco minerado, o último bloco bloco que já foi minerado. Tem informações? tem aí poderia pegar de lá, poderia usar um esquema de prova de trabalho pra gente poder falar, tá bom? Vamos organizar essas informações de algum lugar e e a gente vai confiar no quem produziu prova de trabalho. Isso. Quem para quem caiu da rede e acabou voltando pegar as informações do último blocoado. Então isso é um caminho, tá? Mas aí entra uma coisa, tipo, entra uma questão, tá? Que é, tá? E se eu não quiser usar prova de trabalho, quiser usar algum outro esquema que não é prova de trabalho, a gente vai ver no futuro que tem outros esquemas. E esses outros esquemas em geral envolvem você fazer uma certa transação para provar que você para travar um certo quantidade de dinheiro e aquela quantidade de dinheiro te dá como se fosse uma quantidade de votos que você pode votar aqui no sistema, entendeu? Só que isso é fazer uma transação também e eu preciso atualizar esse estado também. E aí como é que eu faço isso se eu tô fora de sincronia? Entendeu? É mais complicado do que parece. Deixa eu explicar como é que funciona no Bitcoin, porque no Bitcoin é completamente avesso isso aqui. E aí não fiquem pensando muitas soluções para esse tipo de problema agora, não, tá? Beleza? Primeira coisa que a gente vai que que no Bitcoin a gente vai fazer é a gente vai rejeitar essa ideia de de balances, né, de saldos, tá? Então os nós os nós como todo, eles não vão registrar os saldos, tá? A gente vai ter uma noção de que que não tá escrevendo. Em vez de registrar o balanço, eu vou registrar uma noção de um uma moeda. Vou explicar exatamente o que que é essa moeda hoje agora, tá? Uma moeda ou alguma coisa, às vezes a gente se refere como um token e eu vou explicar exatamente o que é esse token, tá? Tirem, tipo, venha. Não imaginem, não imaginem nada agora. Não imagine nada agora. Só guarda aqui a coisa por enquanto. A gente vai ter essa noção de os nossos participantes da rede, eles vão ter uma certa noção de uma moeda. E é isso que a gente vai gerenciar. A gente vai fazer o tracking de quais moedas existem e entre aspas quem é o dono dessas moedas, tá? ao invés de fazer o balanço, o tracking de quanto cada participante tem no sistema, eu não tenho noção de contas aqui. Tem esse monte de moeda aí e não tem, ninguém tem conta, não existe conta, tá? Claro que cada um de nós individualmente a gente quer saber o nosso saldo. Imagina que eu tenho, sei lá, 10 moedas de cinco unidades cada uma. Então eu sei que eu tenho 50 unidades de dinheiro no sistema. Eu individualmente eu quero saber isso, o meu saldo, quanto de eu controlo desse dinheiro, mas isso é meu problema calcular com base na informação. Isso aqui é meu problema individual calcular com base na informação que vai estar aqui pública e sincronizada com todo mundo. Essa vai ser a ideia básica, tá? Então vamos lá. Tudo é baseado na transação de Bitcoin.

Tudo é baseado numa estrutura de dados que a gente chama de transação.

A transação tem quatro campos. Pensa numa estrutura de dados. Tem quatro campos, tá? Tem quatro campos. O primeiro campo é o número de versão, que pra gente aqui não interessa muito. Interessa muito. Ele usa pra gente poder mudar a semântica ali dos do do dos do sistema, fazer upgrades, tá? O segundo campo também não vai interessar muito pra gente, pelo menos no agora, é um lock time, que vai me dar uma certa noção de quando que essa transação é válida ou não ou não válida. Quando ele me dá alguma noção de tempo, tá? Extremamente útil pra gente fazer vários contratos, mas eu não vou lidar com isso aqui agora. Os dois campos que realmente vão me interessar são um que eu vou chamar de inputs. E aí eu vou ter uma lista desses inputs e os outputs. Eu vou ter uma lista desses outputs. Pode, cada transação pode ter várias entradas e pode ter várias saídas, tá? Esquematicamente eu vou desenhar elas assim, ó. Sei lá, umas caixinhas do lado esquerdo, as entradas, do lado direito, as saídas. Tudo bem? E vocês vão ver que eu vou desenhar às vezes umas setinhas assim, ó, tipo, ah, alguma coisa chegando aqui e coisas saindo daqui. Entrada é o que tá entrando e saída é o que tá saindo, tá? Tá saindo, vai virar entrada, vai virar a entrada de de uma outra depois, tá? Nós vamos pro P. Aquele site,

aquele site é o mainpol space, que é esse aqui. Aqui tem uma transação especificamente, ele mostra as entradas do lado esquerdo e as saídas do lado direito. Tipo, ele renderiza assim, tá? Mas o que de fato existe é um monte de bytes e a gente precisa desceralizar esses bytes, parcial esses bytes. Vou inclusive mostrar os essa transação aqui eh hoje, tá? Cadê o meu caderno? Todo mundo OK? O que que tem nas entradas e o que que tem nas saídas, tá? Deixa eu começar pelas saídas, porque as saídas, a saída é um pouco mais fácil de entender primeiro, tá? E a gente vai abrir e detalhar mais essa semântica. Mas as saídas, ela tem ela tem duas informações, cada uma das saídas. Então você tem três saídas, cada uma delas tem essas três, tem as mesmas informações, tipo, tem os mesmos campos, né? Com os dados lá. Enfim, a saída vai ter um amount que diz quanto está sendo pago.

E a saída, cada uma das saídas vai ter um script pub key, é o nome do campo. Eu prefiro chamar isso aqui de locking script. Vai ficar claro por ele trava. tem uma noção de que isso aqui impede você de fazer alguma coisa, tá? Ele vai ter essa informação e isso aqui diz para mim quanto tá sendo pago. E isso aqui me dá uma noção de para quem está sendo pago,

para quem e quanto. É isso que vai ter em cada uma das saídas. E o que que tem nas entradas? Nas entradas vão ter três informações, que na verdade são duas, tá? Mas enfim, três informações. Uma que é o TX ID, uma que eu vou chamar de index e essas duas juntas é comum a gente chamar isso aqui de out point. Já vou explicar o que que é isso, mas isso aí identifica alguma coisa no sistema. E tem um outro campo que chama-se script. SIG. Repare que Pub tem alguma coisa a ver com Pub com a chave pública. Sig tem alguma coisa a ver com a assinatura, mas eu prefiro chamar isso aqui de unlocking script.

Unlocking script. E aí, isso aqui me dá uma noção de essa parte aqui me dá uma noção de o que está sendo gasto, o que é que eu tô tentando gastar, qual é o dinheiro que eu tô tentando gastar. E esse cara aqui vai servir para uma forma de autorização,

de autorizar aquele gasto. Isso aí é a transação de Bitcoin. Pergunta, filho.

Não é não. Não tá de boa. Ah, tá. É que tu tipo tava com malqueza, tava achando que era pergunta. Beleza. Repara uma coisa. Repara uma coisa. Sim. As saídas é dinheiro que alguém tá recebendo.

É dinheiro que alguém tá recebendo. Ela mostra para mim quem tá recebendo, quanto tá recebendo. Tem a ver com o lado do recebedor. As entradas elas são dinheiro que tá sendo gasto. Ela tem tem a ver com o lado do pagador.

Então, repara que isso aqui, isso aqui, ó, é um certo fluxo transferindo, entre aspas, moedas das entradas. ão meio que estão entrando moedas, entre aspas, tá? O que tem tem são esses bites aí, tão entrando moedas e estão saindo moedas. Repare que nesse nesse exemplo que eu tô fazendo aqui, ó, tão entrando duas moedas, uma por aqui, uma por aqui. Vamos supor que seja uma moeda de 10 unidades, uma moeda de cinco unidades.

E eu tô criando três moedas ali nas saídas. Um, supor que seja uma moeda de, sei lá, sete, uma moeda de sete, uma moeda de um.

Tudo bem? O que que é o TX ID? TX ID é o hash dessa transação aqui. É uma estrutura de dados. Você vai serizar ela, tem os bytes. Você pega aqueles bytes, calcula um hash. Um hash bem específico, mas vai calcular um hash. E esse hash a gente usa como identificador dessa transação, que é o que tá aparecendo aqui, ó, que é esse esse hash aqui. Repare que esse hash não tá escrito aqui, tá?

Opa. Não tá escrito aqui, ó, na na transação. Nem teria como, né? Como é que eu calculo o hash de alguma coisa que precisa do R dessa coisa para calcular o R daquela coisa? Não tem como. Tudo bem? Então, informação que tá sempre implícita, tá? Tá sempre implícita, mas é relativamente barato de calcular. Você pegou a transação, tá aqui os byttees, tá aqui os dados, você vai lá e faz o resto e você calcula oxid dela. Relativamente tranquilo. Todo mundo bem?

O que que é o índex? O index ele diz para mim qual saída tá sendo gasta aqui. Qual saída tá sendo gasta? Se é a saída zero, se é a saída um, se é a saída dois e assim por diante. Qual a posição? Tem várias saídas numa transação. Qual daquelas saídas eu tô fazendo referência? Qual daquelas saídas eu tô fazendo referência? Tá? Então, na prática, o que tá acontecendo, ó? meio que a visualização lógica da coisa, tá? É, imagina que eu tenho uma certa transação aqui,

tem uma outra transação, imaginar que ela tem uma entrada e duas saídas e eu quero gastar essa saída especificamente. Então, o que que eu venho aqui e falo? O que que vai aparecer aqui, ó? Vai aparecer o TX ID, que vou chamar de zero, e essa aqui é o índice um. Então aqui nessa nos dados dessa transção vai aparecer TX a ID 0 índice 1. É isso aí que eu tô tendo gastar.

Todo mundo OK? Repara que na entrada não diz quanto eu tô tentando gastar daquela moeda. Se essa moeda aqui que eu tô tentando gastar é de sete, se essa moeda que eu tô tentando gastar é de sete, essa formação tá só na saída. Ela não tá na entrada. Na entrada eu não digo quanto que eu quero gastar daquele set. Tá implícito que se você tá gastando, você tá gastando tudo. Você não tem opção de gastar parcialmente o dinheiro. Ou é tudo ou é nada. Porque cada uma das moedas vai ter uma regra que a gente vai concordar. Ela só pode ser gasta uma vez, no máximo uma vez. Ela pode ter, ela pode estar gasta zero vezes ou ela pode estar gasta uma vez. Ponto final. Se você tentar gastar uma moeda duas vezes, essa transação que gasta a moeda segunda vez vai ser considerada inválida.

Ou seja, no grafo das transações não vai ter uma outra transação que pega a mesma saidinha e tenta gastar aqui, ó. Não vai ter isso aí. Todo mundo OK? Fonte de muitos erros. Se você tem uma moeda de 10, você precisa gastar os 10. Professor, como é que eu pego a moeda de sete e pago e faço um pagamento de cinco? Eu não quero gastar o sete, só quero gastar cinco. Eu tô comprando, eu quero comprar uma coisa de cinco, custa cinco. E eu tenho uma moeda de sete. Como é que eu faço? Você, nesse caso aqui, ó, do jeito que eu tô dizendo, você pega uma moeda de sete, referencia ela na entrada, cria uma moeda, uma saída de cinco e direciona pra pessoa que você quer pagar. A gente vai ver como. Cria uma outra moeda de dois e direciona para você. A gente de novamente chama isso aqui de troco. Troco, né? É o change. É o troco. Que é a mesma coisa que você faria, né? Ah, eu tenho uma nota de 10 e quero fazer um pagamento de sete. Que que você faz? Você entrega pro logístico 10 e pega três de volta. Pega três moedinhas de um, por exemplo. Certo? Só que aqui você não entrega nada. Você mesmo que tem que calcular isso tudo. Porque quem que tá fazendo a transação? É quem tá recebendo ou quem tá pagando. Ô, é quem tá recebendo ou quem tá pagando? Quem tá pagando? Quem tá pagando? Quem tá recebendo nem entre aspas, nem participa aqui. Tem, tem que participar. Vocês vão ver que tem que participar de alguma forma. Mas dentro do desse dessa parte de protocolo nem participa. Quem cria as transações é quem tá pagando. Quem tá recebendo fica lá quietinho, não fala nada, não faz nada, não precisa dizer nada na rede, não precisa dizer: "Ah, eu tô recebendo tanto". Quem tá pagando que fala: "Ó, eu tô pagando tanto aqui, tô pagando fulano, fulano, ciclano". Professor, nesse fluxo aí que você tá descrevendo, eh, a moeda e tal, qual que seria de qual? Tô movendo sem Bitcoin ou tô movendo zero ponto em Bitcoin? É só o tamanho dela em bytes ou não é o é esse valor aqui, ó. Por exemplo, essa transação tá movimentando sete bitcoins, sete unidades, né? Sete bitcoins. Chama de Bitcoin. sete bitcoin. Uhum. Ela tem o mesmo tamanho se eu fosse mover 100 bitcoin. A gente vai ver aqui já. A gente vai ver aqui já. Depende, porque depende do número de entradas. Se eu preciso de juntar mais moedas, eu preciso colocar mais informações. Porque imagina que eu preciso, sei lá, juntar. Imagina que eu tenho uma moeda de 100 e eu quero movimentar 100. Eu faço uma entrada com essa moeda de 100 e vou embora. Agora imagina que eu não tenho uma moeda de 100, eu tenho 10 moedas de 10. Eu preciso criar 10 entradas com esses dados aqui, ó. Então são mais dados que eu tenho que botar. Então vai ficar maior em termos de bytes. Mas repare, o tamanho, a quantidade de dados que eu tenho que botar não tem a ver com o o valor da movimentação, valor financeiro, entendeu? Uma coisa não tem nada a ver com a outra. E isso é importante, esse esse detalhe é importante porque a gente vai pagar, vai ter uma noção de taxa que eu vou explicar agora, vai ter uma noção de taxa e a taxa não é calculada sobre quanto você tá movimentando de dinheiro, ela é calculada com quantos bytes você precisa para para nessa sua mensagem aqui, a mensagem, a transação, quantos bytes tem nessa tua mensagem? Se tiver muitos bytes, a gente vai precisar pagar mais, entendeu? Todo mundo quer ter aí? Todo mundo quer ter aí, beleza? regras que a gente vai chamar de regras de regras que a gente vai chamar de regras de consenso, tá? Uma delas é a soma das entradas tem que ser menor ou igual à soma das saídas.

Por quê?

Por quê? Não, por quê? Se fosse maior, se a soma das entradas Não, tá contrário isso aqui, né? A soma das entradas tem que ser maior ou igual a soma das saídas. Tem que entrar mais do que saiu. Sen não estaria criando dinheiro. Senão estaria criando dinheiro. Sen não tô criando dinheiro. Sen não tô criando dinheiro novo.

Nunca vai poder criar dinheiro novo. Não. Vai ter uma regra especial aí em algum lugar para gente poder criar e fazer a emissão do dinheiro, porque isso aqui precisa, esse processo precisa começar em algum lugar, tá? Então vai ter uma certa transação especial que Coinbase transaction. Ela vai seguir regras especiais. É bastante limitado como elas podem ser construída, tá? Mas ela é bem comum, inclusive todos os blocos vão ter uma coincra

aqui não vai ser não vai ser validada. Vamos, a gente vai validar outra regra de quanto que é a quantidade máxima que ela pode colocar de dinheiro, de dinheiro novo. Vai ter a história dividir por dois e vai ter a história da taxa, que é se tiver mais na entrada do que na saída, imagina que nesse caso aqui, ó, nesse exemplo, tá entrando sete, aí eu tô fazendo pagamento de cinco e tô criando uma outra entrada de um. Repare que tem um saldo de um, um saldo de um aí, né? uma diferença de um entre o que tá entrando e o que tá saindo. Tem um saldo aí, tá? Esse saldo eu vou chamar de taxa.

Repara que eu não escrevo isso aí na transação, ó. Não tem aqui escrito taxa. Quanto que eu tô pagando de taxa? Ao contrário, por exemplo, do Etheréum. Etheréum diz, você diz lá em parte quanto você quer pagar de taxa. Tem uma noção de gas, o gás. E a o gás é uma forma de taxa, tá? Porque o Etheréo tem uma outra questão que a gente vai entrar um pouco mais para frente, que é como que faz a autorização e que que que que a computação que eu vou fazer aqui? Aí o etheré preciso de uma forma de limitar o quanto você vai fazer de computação aqui. Não vai ter esse problema. Todo mundo OK? Então a caixa é tudo que sobra. Tudo que sobra com relação ao é a diferença entre o que entrou e o que saiu. Isso vai ser a taxa. Quem quem calc quem que escolhe essa taxa? Osadores. Não. Quem tá quem tá escrevendo a transação? Quem tá pagando? Quem tá pagando? Quem tá pagando, escreve tudo isso aí. Escolhe todos os dados aqui. Quem tá pagando, quem tá pagando, escolhe quanto quer pagar de taxa.

Quem tá pagando escolhe quanto quer pagar de taxa. Claro que isso aqui vai gerar um certo mercado, mas se pare. Você que tá criando transação, você escolhe quando você quer pagar de taxa. Você pode pagar muito, você pode pagar pouco. Qual incentivo você pagar muito? O incentivo? Essa é uma excelente pergunta. Qual o incentivo para eu pagar? muita taxa ou pouca taxa, valor da transação mais rápido, vai ter, a gente vai entrar na hora que a gente falar do bloco, o bloco vai ter bloco vai o bloco vai ser uma lista dessas transações parte do bloco, só que eu tenho um limite de de quantos bytes pode ter no bloco. Então ele tem uma escassez de quanto quantas mensagens eu consigo representar ali dentro naquele bloco, consigo incluir naquele bloco. E aí isso gera um mercado, tudo, tudo que tem escassez de alguma forma tem potencial para gerar um mercado. No caso aqui um mercado de taxa. E a gente vai falar um pouco mais sobre isso, porque isso tem a ver com um certo incentivo econômico, parte dos incentivos econômicos dessa coisa. É, o bloco é 1 ou 4 MB

debaixo. O bloco é um ou é 4 MB? No Bitcoin, o bloco é o tamanho do bloco é 1 MB, mas a gente tem uma outra noção que é o peso do bloco que é 4 MB. E aí depois eu alguma hora vou explicar o que que é a diferença disso aí, porque isso é uma complicação. Mas o bloco em princípio tem 1 MB, o máximo de byte você pode adicionar aí em princípio, tá? Mas teve um upgrade e aí isso ficou um pouquinho mais complicado. Todo mundo OK? E eu provavelmente vou falar do upgrade quando a gente for falar de governança, porque esse é um exemplo de upgrade que não que é introduz uma regra nova de consenso que não expulsa os participantes que não quiserem seguir a regra nova. Eu vou explicar melhor nisso, no nessa coisa de governança. É que então tipo o minerador aí, né, que tá fazendo aí, ele tá tipo incluindo essa transação aí, tipo essa um endereço para ele nessa transação não. Quem tá escrevendo essa transação? Então aí como é que ele vai pegar? Porque ele só tá falando tipo a vai para lá e para cá. Vale para lá para cá, mas ele sabe quem tá quem tá montando bloco tá vendo todas as transações que tá escolhendo. Ele tá vendo quanto que tem de sobra cada um, tá? Vai ter uma regra lá no no na hora que a gente falar da construção do bloco que vai dizer que ele pode somar todas essas taxas e pagar para ele, pagar para quem ele quiser. No caso lá, ele pode vai criar uma saída e vai pagar para quem ele quiser numa transação especial. Mas isso aí eu explico quando for falar do bloco. Por enquanto só pensa assim, eu quem tá pagando pode deixar uma diferença lá na mesa que é, e a gente vai chamar isso de taxa. E essa taxa vai servir para incentivar essa transação a ser confirmada mais rápido ou mais ou não. E repare, não é o minerador que escolhe taxa. O minerador não controla essa taxa. O minerador, inclusive, eu vou falar sobre isso um pouco mais na parte de incentivo econômico, mas o minerador não tem nenhum controle sobre essa taxa. Em princípio. É bem estranho isso, né? Porque o minerador tá prestando serviço, essa taxa paga pelo serviço. É igual você entrar na loja e você falar assim: "Ah, me dá um pão de queijo". E o e o vendedor falar assim: "Quanto você quer pagar?" E aí você falar: "Ah, eu pago 50 centavos." E ele falar: "Tá bom". E aí outra pessoa entrar na mesma loja do seu lado e falar assim: "Ô, me dá um pão de queijo". E você? E e aí o vendedor falar: "Quanto você quer pagar?" E o cara do seu lado falar assim: "Ah, pago 10 centavos." E o e o vendedor falar: "Ah, tá bom, professor". E aí você morreu 50 centavos lá, né? Mas já pagou. Tem como o minerador escolher só minerar acima de tal taxa? Pode. O minerador, né? Minerador ele faz o que ele quiser. A gente vai falar de mineração mais para frente. Acho que a analogia disso aí seria mais quanto você quer pagar de gorgeta, né? Mais ou menos. Mais ou menos, porque aí ou menos. Ah, eu vou dar gorjeta. É uma espécie de gorjeta. Então vou te atender antes, né? É uma espécie de gorgeta. É, é uma espécie de gorjeta, mas assim, vai ter um mercado aqui. E repare, um mercado meio estranho, porque o o minerador ele tá oferecendo um serviço, ele tá prestando um serviço. O pagamento pelo serviço não é ele que escolhe quanto que ele vai receber, não é ele que faz o preço. Ele não tem nenhum controle sobre esse preço. É bem doido isso, tá? É bem estranho. Quando eu converso com meus amigos economistas, eles olham e falam: "Cara, isso aqui é muito estranho. Isso aqui é muito, isso é muito estranho". Para eles, inclusive, isso aqui é um fonte de 1 problemas na teoria econômica. Mas enfim, a gente fala isso um pouco mais pra frente. Todo mundo quer até aqui? Todo mundo quer até aqui. Vamos olhar os dados de uma transação pra gente ver como é que como é que é. Ah, e qual transação que eu quero olhar com vocês, tá? É uma transação muito especial. É a transação que tá no bl, é a única transação, não, não é a única. No bloco 170 tem duas transações. Vocês vão ver que vários blocos aqui para trás, ó, são bem antigos, ó. Tem uma transação, uma transação, tá? Uma transação, uma transação, uma transação. A primeira, primeiro bloque transação diferente dessa especial que sempre todo bloco tem, foi esse bloco 170, que é esse daqui, tá? Ele tem uma transação, ó. Entrou 50 50 Bitcoin. Tem duas saídas, uma de 10, uma de 40, tá? E a gente sabe que que foi isso aqui. A gente sabe, essa daqui a gente sabe, a gente sabe quem é que pagou, quem é que recebeu essa, quem é que recebeu essa. Quem pagou foi o Satoshi. Nessa altura da rede só tinha o Satoshi. Na rede. Ninguém sabe quem é o Satoshi, mas era o Satoshi. É o cara que fez a parada ou as pessoas que deram parada, sei lá. É a pessoa, o Satoshi, essa entidade aí, tá? Ele fez um pagamento de 10 bitcoins para um cara chamado Halfiney. Esse cara é conhecido, tava lá na na e a gente sabe que é para ele porque eles trocaram mensagens mencionando isso aqui, tal. A gente sabe que é para que foi isso aí. Foi uma transação de teste, tá? Que era o Ralfini tentando subir o node, não sei o quê, conectar no node do do Satos e fazer uma transação de teste, então ele tinha que gerar chave, tal, tudo uma complicação. Hoje em dia é um pouco mais já tá mais bem trabalhado. E esse 40 é o Satoshi. Pegando 40 de troco. Quanto que foi a taxa aqui? Zero. Repara que você pode pagar zero de taxa em princípio, tá? Hoje em dia já é mais difícil porque hoje em dia os tem um certo, a gente vai diferenciar entre regras de consenso e regras de política. Consenso vai dizer o que que é válido e o que que não é válido. A regra de política vai dizer assim: "Daquelas coisas que são válidas, o que que eu topo? O que que eu topo? mostrar paraas outras pessoas e o que que eu não quero mostrar paraas outras pessoas. Basicamente isso, tá? Porque eu posso receber uma transação, validar e ver que ela é válida, mas eu não não informar os outras pessoas. Eu posso escolher fazer isso, tá? Por exemplo, transação hoje que um zero de taxa, a política normal é não repropagar ela. Se eu posso até ver, validar, ela entra no bloco, ela vai ser válida. E mas eu não, tipo, eu não fico anunciando ela. Por quê? Porque eu quero que pague taxa. A taxa é para incentivar a coisa acontecer. O assim, os mineradores podem se recusar a publicar, a validar essa taxa zero? O minerador faz o que ele quiser. Ele, o miner pergunta é, o minerador pode se negar a validar uma transação com taxa zero? Se ele viu, tipo assim, quando você viu uma transação, você não precisa nem validar. Você viu, você recebeu uma transação aqui, é um mon de byte, você pode falar: "Vou descartar". Simplesmente vou descartar. Isso é uma coisa. Outra coisa é você ver um bloco novo com prova de trabalho válida e aí esse aqui se você descartar você sai de sincronia da rede, entendeu? Uma

pergunta que sempre eu fiz que eu fiz uma transação. Uhum. Mandei ela tem zera, tá? Essa transação tá aí. Uhum. Né? E eu vi que já foram três bos lá nenhum deles em transação. Sim. Ou seja, eh, provavelmente tá. Como eu posso ter certeza? Existe algum um certificado de revogação? Quero dis Nossa, essa uma pergunta excelente. Olha só. a pergunta ali. Professor, imagina aqui que, sei lá, vamos pensar numa rede um pouquinho mais concreta. Eu tenho a Hélice, eu tenho Bob, perdão, eu tenho aice, eu tenho Bob, eu tenho Charlie e eu tenho o David. Ah, eles estão lá e tal. A hélice manda uma transação zero taxa ningém com zero taxa. É a transação da hélice. Aí ela chegou aqui, ela chegou aqui e vamos imaginar que ela chegou e propagou. Todo mundo viu essa transação. Aí apareceu aí a a blockchain tá aqui andando. Aí imaginar que minerou um bloco depois do do do daquela transação e a transação não tá aqui, tá? Aí minerou outro bloco, a transação não tá aqui. Minerou outro bloco, a transação não tá aqui. Aí a pergunta da da Melé, [ __ ] provavelmente paguei muito pouca taxa. Imagina se foi zero, mas não precisa nem ser zero. Pode ser que seja pouca taxa comparado com as outras transações todas que estão competindo para entrar ali, né? Tem como eu invalidar essa parada? Se eu aumentar a taxa, eu posso pagar dois. É, não tem uma mensagem para você cancelar uma transação. Você propagou, os nós viram, eles viram, tá? Não tem como você falar: "Ah, não, ó, esquece essa daí". Foi mal, errei. É, não tem essa, não tem que cancelar. Você fez, tá feito, tá? Mas o que você pode fazer é criar uma outra transação que compete com aquela primeira. Isso aí a gente faz o tempo todo. Presta atenção. Imagina que eu tenho uma uma certa transação e eu tô gastando essa saída aqui. Aí você fez essa transação aqui, ó. Entrou uma saída, você fez um pagamento. Essa transação, nesse momento, ela é válida, vai ter um monte de regra, vamos supor que ela seja válida, tá? Você propagou ela e aí tá demorando para confirmar. Uma coisa que você pode fazer é escreve outra transação que gasta o mesmo dinheiro. Isso aqui, repare que isso aqui é uma uma transação competindo com a outra. As duas não podem ser válidas ao mesmo tempo. E aí você paga. Paga. Só que aqui você deixa a taxa maior do que em relação à primeira. Aí não é tão simples assim, mas isso aqui é o princípio da coisa, tá? Essa transação passa a ter mais probabilidade de entrar num bloco do que a primeira. E se ela entrar? E se ela entrar, se a segunda cinza for confirmada, a primeira é inválida, porque elas não podem ser as duas válidas ao mesmo tempo, porque elas estão executando o que a gente chama de gasto duplo. Elas estão tentando gastar o mesmo dinheiro, a mesma moeda. Pegou a ideia? É assim que a gente revoga uma transação. Isso nome, esse termo para isso aqui é revogar a transação. Eu tenho uma transação que era válida no momento e eu faço alguma coisa que torna ela inválida num segundo momento. Normalmente essa segunda coisa é envolve gastar o mesmo dinheiro que a primeira também tava tentando gastar. Então você puder até dear para alguém e se devolver os pode, pode. Enquanto a enquanto a transação não for confirmada, eu posso sair jogando, gastando mesmo dinheiro várias vezes lá, ó. Posso fazer 10, seja lá, dezenas de transmída. taxa na hora que uma delas for confirmada os blocos, imagina que eu vi uma lista aqui de um montão de transações MA, MA1, MA2, todas elas concorrentes, MA3, blá blá. Aí eu vi o próximo bloco. O próximo bloco incluiu a transção MA2. Aí o que quando o Bob vê isso, ele vai falar, ele vai olhar na lista de todas as transções que ele viu. A gente chama isso aqui de manol. Manol.

uma lugar onde ele sai guardando as transações que ele já viu, que não foram confirmadas ainda. Aí ele vai olhar isso aqui e falar: "Porra, a M2 foi confirmada, tá no bloco, então essa aqui é inválida, essa é inválida, essa é inválida. Deleta lá do do do banco de dados". Mesma coisa quando isso aqui propagar, imagina que ele tinha visto o MA, o MA3, mas ele nunca viu o MA1 e o MA2. O que que o David vai fazer? Ele vai olhar e falar assim: "Isso aqui é inválido, isso aqui é inválido". Ele nunca vai ver o o MA1. E o MA2 ele vai ver porque tá no bloco.

Repare que eu não preciso sincronizar as minha impuls. Quem consola esse bloco assim a quantidade? O minerador, só que todos são mineradores potencialmente. A gente vai ver sobre isso. Foca na transação por enquanto. Foca na transação por enquanto. Tudo bem? Certo? Isso aqui vai ser, isso aqui é usado o tempo todo. Só

chegando nesse ponto, o o nó pode até esquecer se todos os outputos já foram usados, você não precisa guardar esse blog. Existe um output que tá parado desde É, existe. Tem output o o no bloco Gênesis tem uma transação com output e ele tá lá parado até hoje, ele nunca vai ser deletado porque ele é impossível de você gasto. Por exemplo, tem várias transações. Esse esse 40 aqui eu não lembro se ele foi gasto. A gente pode seguindo aqui o caminho dela. Eu não lembro se esse 40 já foi gasto. Isso aqui é do lado dos dos primórdios da rede. Esse 10 foi gasto, mas eu acho que a próxima transção gerou duas saídas. A gente pode caminhar, ver esse caminho aí. Tem uma delas que não foi gasta. A gente já sabe que o Ralfine morreu, a gente não sabe se alguém ainda tem as chave dele. Então assim, a medida que que a gente vai perdendo essas capacidades deação, acaba vai tribulando a lista, vai eventualmente, você já tá percebendo um problema que é na hora que eu crio uma saída dessa daqui, ó, para validar uma, o que que eu preciso para validar uma transação? Tá aparecendo, ô diabo. Para, o que que eu preciso para validar uma transação? Eu preciso saber, eu já gastei isso aqui ou não? Então, o que que a gente vai fazendo? A gente vai olhando todas as os blocos, vendo em todas as transações que foram confirmadas, a gente vai contabilizando as saídas. A gente fala assim, beleza, saída, essa saída aqui no bloco um, ela ela surgiu. Aí eu vou lá e bloco no banco de dados. Aí eu vou vendo todos os blocos, todos os blocos. Aí lá pelo bloco 100.000 Eu vi uma transção que gasta aquela uma que tá lá lá de trás. Aí que eu faço, tiro do banco de dados. E aí eu vou fazendo isso. A gente chama isso aí de UTXO. Uxo set. É esse conjunto de todas as saídas que ainda não foram gastas. E o Txo é unspent transaction output. Saídas de transações que ainda não foram gastas e elas são independentes, tá? Se eu gastar essa e não gastar essa, essa aqui é uma moeda ainda que pode ser gasta em algum momento do sistema, mas essa daqui não pode mais. Se alguém perder a chave, já era. Perdeu a chave, em princípio, já era. Pergunta, você falou ali que tipo essas duas essas duas vão tá competindo, né? Aham. Enquanto por exemplo, como é que eu posso pedir as pessoas que ele tem que produto aí?

Sim, ele fez uma transação, só que essa transação não foi confirmada. Confirmada. Aí tem que usar esse para comprar outra coisa. Como é que eu posso de comprar dois produtos diferentes? Você espera aparecer um o próximo bloco e confirmar uma delas. Senhor realiza a se se você receber, se ele quiser gastar dois vezes, ele que gasta. Isso você não recebeu. Eu eu que tô aqui fazendo o pagamento, eu posso fazer 10 100.000 300 milhões de pagamentos com a mesma moeda. Aí eu, sei lá, pego a minha moeda, pago todos vocês aqui, faço uma transação, pago para cada um aí, tá? Pagando, usando essa moeda para pagar cada um de vocês, tá? uma transção diferente todas elas concorrentes. No próximo bloco, o minerador vai escolher uma delas, vai incluir todas as outras, tod uma delas vai ser aválida e aí aquele pagamento é considerado final, porque ele vai estar protegido pela prova de trabalho e todas as outras transações vão ser invalidadas nos pelos nós, inclusive o seu nó. Seu nó vai ver todas elas e quase todas elas, entendeu? Se o bloco tiver ações inválidas, se o bloco invalidado, se o bloco tiver uma se o bloco pode ter milhares de transições, se tiver uma transção inválida, tudo é inválido, o bloco é inválido, mas não necessariamente todas as transções são inválidas, né? Tá todo mundo ok? Amentação original foi de C. C++. C+ é hoje, até hoje é feito em C+ mais Bitcoin Cor mais. Hã, todo o sistema do Bitcoin ser mais. Todo sistema do Bitcoin é uma expressão muito forte, né? Assim, o Bitcoin core é a principal implementação do node que faz a validação. Essa é mais e provavelmente uns 98% da rede é Bitcoin core, sei lá, uns 90 e muito% da rede. Só que tem 300 outras coisas que funcionam em cima da da rede principal. O Luiz tá trabalhando Florest, que é uma que é uma implementação de Funode concorrente que é que é em Rust Lightning Network acho que não tem implementação em C, tem GO, a maior delas é em GO, tem o Eclair, Rush também, tem Rush também, o Eclair, tem esquela, é que é Java, né? JVM, enfim, tem 300 coisas as wallets, tudo, tipo, wallet é JavaScript para quelado.

Qual linguagem que eu indico? Quais linguagens? Quais linguagens? Todas. Você tem que aprender a programar. Você não tem que aprender a falar linguagem A ou B, você tem que aprender a falar.

A gente pode falar sobre isso depois. Todo mundo OK? Todo mundo OK? Ah, que que eu tô falando aqui?

Calma que ele mandou. Então, eu sempre o minerador ele tem que olhar tudo, tipo assim, só o último bloco não não dá informação para ele, né? Todo mundo tá vendo tudo em princípio. Tá todo mundo vendo tudo ou quase tudo. Então aí tipo o minerador que ele tem que ter passado para ver. O minerador na hora de minerar ele tem que de alguma forma conhecer todo o passado. Sim, mas ele não precisa manter todo o passado. Ele precisa ter o estado atual da rede. O que que é o estado atual da rede? É quais saídas de transação ainda não foram gastas. Isso é o estado toda rede. Contando todas as transações estão confirmadas, quais saídas de transação não estão gastas. Isso é o que ele precisa manter num num num certo momento. Isso é o estado da rede. E repare, cada saída é um token ou uma moeda. Isso aqui é a moeda.

Isso aqui é a moeda. Só pode ser usado uma vez. Então, quando eu uso essa moeda nessa transação, repare que eu não vou apagar os dados daquela moeda, eu simplesmente vou marcar aquela saída como gasta e aí eu não posso mais gastar. E aí qualquer transação que tentar gastar aquela moeda vai ser inválida. aqui transação que não ser computado. Não foi não entendi, filho. Aquela translação Gênesis não foi confirmada. Ela foi confirmada, tá no bloco. Validada, foi validada. Ela tá no bloco. Ela tá no primeiro bloco. Inclusive o que eu disse é que ela tem uma saída que não pode ser gasta. Se eu tiver uma transação que não foi validada, só eu pego faço outra transação aquele eu posso fazer uma transação depois muito tempo. Não entendi. Uma trção validade. É esse cenário aqui. Sim. Tá. Que há muito tempo Aham. Imagina que você fez a preta, propagou e ela tá lá esperando há muito tempo. Sim. Aí eu posso criar outra transização depois vários. Pode é exatamente que eu desenho aqui. Tem umas formas um pouco mais inteligentes hoje de você fazer melhorar a taxa de uma transação. Por exemplo, você pode fazer alguma coisa do tipo, em vez de fazer isso aqui,

você pode, por exemplo, isso aqui é o seu troco, você pode, por exemplo, criar uma outra transação que gasta seu troco e cria só uma saída para você mesmo. Bum. Só que você paga a taxa nisso, você bota uma taxa lá, tá? E aí esse esquema aqui é o que a gente para aí você bota uma taxa relativamente alta na segunda. E aí que que o minerador vai olhar e falar assim: "Porra, eu queria confirmar essa porque essa daqui é muito vantajosa para mim. Eu, minerador vou receber muito pagamento. Só que para eu para eu confirmar essa, eu necessariamente preciso confirmar essa." Aí ele bota as duas no bloco. Bota as duas no bloco porque elas tem uma dependência entre elas, uma dependência lógica entre elas. Uma só pode entrar com a outra. A a transação dois só pode entrar se a um também entrar. A um pode entrar sozinha, mas a dois só entra se a um entrar, percebe? Num bloco, tá? E aí isso aqui a gente chama de child child pay for parent, CPFP. A transação filha paga pela transação pai a taxa. Isso tá implementado hoje. São um mecanismo também pode usar para aumentar a taxa. Tem outros mecanismos de aumentar taxa.

Tem algum limite no número de saídas você consegue colocar? Tem algum limite no número de saídas você consegue colocar? Em princípio não, mas na prática tem, porque você precisa descrever as saídas e aí volta. Ó, minha estrutura de dados, eu preciso botar essa informação aqui para cada saída. Então, na hora que eu vou botando é mais bytes, mais bytes, mais bytes, mais bytes. Chega uma hora que, tipo, aquela uma transção é tão grande que ela sozinha já não cabe no bloco. Tá aí, tipo, meio que na prática olha e fala: "É, mas quanto que quanto?" Não sei te dizer, porque esses scripts aqui a gente vai ver, são programas de computador, você pode botar mais coisa ou menos coisa, um programa que você vai escrever. Então também varia o tamanho do script, do script. O amount é fixo, são 64 bits. É, é fixo, mas o script não é fixo. Todo mundo OK? Se eu tenho várias moedas, né? Fiz várias transações de vários moedas diferentes. Aí se eu quiser pagar alguém uma certa quantidade, eu tenho que tipo juntar todas essas moedas. Se você quiser pagar alguém uma quantidade maior do que o valor da de cada moeda individual, aí você faz uma transação coletando várias, né? Por exemplo, sei lá, imagina que eu tenho uma moeda de 10, uma de cinco, uma de sete e uma de um, tá? E eu quero fazer um pagamento de 20. Aí, que que você pode fazer? Você pode fazer uma transação que pega a de 10, pega a de sete, por exemplo, e a de cinco. Isso aqui tá dando 22 de entrada. Aí você quer fazer um pagamento de 20. Você você vem aqui, cria uma uma saída de 20 para pagar quem você tá pagando e cria uma saída de 1,9, por exemplo, de troco, você paga para você mesmo e aquele 01 é taxa, por exemplo. Tranquilo? Todo mundo bem com isso? E o que so a diferença dessa da entrada com a saída é o que o minerador vai receber. Repare que o minerador ele ele pode coletar, mas ele não é obrigado a coletar. Já aconteceu de minerador ir lá ver um monte de taxa e não pegar, não pegar. E se ele não pegar, aquele dinheiro ficou perdido para sempre. Nunca mais ele pode ser usado. Esse não gera um problema Bitcoin a longo prazo de tipo não se cria moeda nova, tem um limite para isso. Tem um limite de moedas. Isso é assim d a partir do momento que você atinge esse limite, você vê que é muito fácil perder moedas, né? É, é muito fácil perder, não é perder moedas, é perder valor aqui no no sistema. É muito fácil perder valor. Sim, a tua pergunta é isso não vai dar um problema alguma hora? É, em princípio não. Em princípio não, porque pra economia aí isso não, uma questão de Bitcoin vigaria. Issa é a questão da economia. Pra economia não importa quanto de dinheiro tem circulação. Qualquer quantidade serve. É, mas os preços vão se ajustar à quantidade do dinheiro, mas tem uma hora que isso vai para zero, sem a longo prazo. Ah, mas aí é muito longo, longo, bem longo prazo, né, professor? Se o Bitcoin for, se conseguissem resolver esse problema escalabilidade, pode ter. Eu, eu vou confiar que você tá cuidando bem das suas moedas, você não vai perder, então vai sobrar pelo menos as suas moedas. Então é isso. Estatisticamente, o que que é considerado uma taxa muito barata e execuível e uma taxa alta? Uma taxa barata exec é meio que você tem que olhar o histórico da coisa. Hoje Hoje na média as taxas estão muito baixas. Tá abaixo de um de um tá abaixo de um satoche por bate. [ __ ] falei a palavra. Hã, não mais, não mais. Mas pera aí, o que que é um satche? Tá aqui nesse amount, esse amount e vocês tem que me avisar. Esse amount ele é um número inteiro de de até 64, de 64 bits, mas ele é um número inteiro, tá? O que que é um Bitcoin? Um Bitcoin. Essa quantidade monetária de um Bitcoin é 100 milhões.

100 milhões escrito aqui nesse nesse amount. Isso é o que a gente chama de um Bitcoin, tá? Aí repare, 100 milhões de quê? Qual é o nome da unidade aqui? Ao longo do tempo, alguém escolheu chamar de Satoshi ou SATs. Satosche, 100 milhões de sat é um Bitcoin. Então não tem número fracionário na parada, tem uma unidade básica de valor que é indivisível. Centavo, dig assim, não centavo. É um um Satoche. É a unidade. A unidade como se fosse dólare. É o centavo do real. É porque nós temos, a gente tem real. Eu morei na Suécia, lá a coroa é coroa sueca, o nome da moeda lá não tem centavo, então menor unidade lá é uma coroa. Ah, é, acho que no Japão também também não tem centavo um negócio assim. Tem dinheiro que não tem centavos. É a menor unidade é aquela que acabou. É aqui também. É como se multiplicasse a a nossa moeda por 100. É, é a mesma coisa. É o último centavo. Não tem sentido, né? É, é. Enfim, é a mesma coisa. Então uma unidade não tem número 0 V, não existe isso. Tem lá ah, um pagamento de 1000 Sat. Quanto que é isso? É 0,00, não sei quantos 1 0,0 não sei quantos zeros um Bitcoin, entendeu? Aí você escolhe umidade. Para pagamento grande é tipo um bitcoins, é o átomo. E para pagamento pequeno você vai falar em SATS que vai ficar mais cômodo. Todo mundo quer até aí, tá? Que que é uma taxa alta, uma taxa baixa? Hoje tá mais ou menos aqui, ó.

entre quatro e sete sats por VBT, satostos por Vbitte. Vbite é uma é uma medida de quantidade de bytes que tem a sua transação, tá? Não é bytes exatamente, mas a gente vê depois o que que é esse V aí. Mas pensa que é mais ou menos isso que tá por aí, tá? Mas às vezes tá mais, às vezes tá menos, até recentemente tava tipo, é bem dinâmico, né? Um só é bem dinâmico isso aqui. Depende de das pessoas usando. É, as pessoas estão usando mais, vai ter mais taxa se tiver usando. Isso é um leilão, né? Você tá isso dando um lance para te sentir por no bloco. Então se você dá mais, o minerador vai te botar no bloco. Isso. E isso aqui vai refletir em parte vai refletir a demanda por uso do espaço no bloco. Se tem muita gente tentando confirmar a transação, vai ter mais a taxa vai aumentar. Como eu disse, vai produzir um mercado de taxa. Mas eu não queria falar de mercado de taxa agora. Vamos olhar, vamos olhar a transação do do rapidão. Vamos olhar a, vamos lá, vamos lá, vamos olhar a transação do do Satos pro Ralfine, tá?

Esses aqui são os os bytes que estão lá. Eu coloquei uns labels para ficar um pouco mais fácil da gente ler e interpretar a parada, tá? Mas o que tem lá naquela transção tem os bytes zer nessa ordem tá 0 1 00 01 C9 97 A5 blá blá blá blá blá base4 base exa aqui tá aqui na minha na minha representação. Eu botei os labels aqui para ficar um pouco mais fácil da gente acompanhar o que tá acontecendo, tá? Então, olha lá, tem o número de versão, tem entradas, tem saídas, tem o lock time, tá? Aqui, inclusive tem a quantidade de B de cada um. Vamos dar uma olhada nas saídas aqui, ó. Aquela transção tem duas saídas, tá? Tem duas saídas. Então, lá tem uma no início da da desse campo aqui tem o número dois que fala assim: "Tem duas saídas. Então, tem um número lá dizendo quantas saídas tem." Cada uma tem o valor e um esse campo script pub, tá? Que eu quero explicar melhor agora. O valor dessa dessa dessa saída aqui, que é uma moeda nova que tá sendo criada no sistema agora, é 0 CA, blá blá blá, que é 10, esse número gigante aqui que é, sei lá, eu botei aqui em dividindo por quatro porque é mais, é tipo os, acho que japonês faz assim, né? E encaixa melhor com a história dos 100 milhões dos Satos. Em vez de você ficar dividindo três pedaços, você dividir em quatro pedaços, aqui dá o o unidade de Bitcoin. Mas isso aqui é 100 milhões. 100 milhões. 1 bilhão. 10 bilhões de bhões to. Então tá escrito 10 bilhões aqui em ex. Bitcoin tá um bitcoin aí, não tá? 10 bitcoins. 10 bitcoins. Isso 1 bilhão de fatórias. Hã? 1 bilhão de fatórios. 1 bilhão. Pera aí. 100 milhões é um Bitcoin. Ah, é 10. Isso. 1 bilhão. Isso. Eu que tô viajando. Isso é 10 bitcoins. Qual o número que tá escrito aqui? 1 bilhão. É o número inteiro. Não tem 10. Tá gente, hã, é só uma forma. É aquela transação inicial. É porque o Satoche pensou: "Ah, eu vou botar centavos, só que tipo muitas casas decimais." Mas acho que ele não esperava que mais ou menos não esperava, tá? Tipo, tem lá as conversas deles lá, eles falam: "Ah, eu calculei mais esse 10". É um número totalmente arbitrário isso aí. Aí ele fala: "Ah, eu calculei, peguei mais ou menos a quantidade de riqueza do mundo inteiro e pensei: "Ah, se tudo fosse representado usando as unidades de Bitcoin, isso aqui seria um um um satia dólar, tipo, alguma coisa parecida com isso." Mais ou menos essa conversa. Mas enfim, é só um número, tá? Qual registro dessas conversas na lista de e-mails? Tenho todo o registro histórico disso no fórum que eles conversavam. Bitcoin Talk. Procure Bitcoin Talk. Ainda existe esse fórum, mas ele virou muito ruim. Mas se você olhar o registro histórico lá vai ter muita coisa, tudo bem? E aí tem esse campus script pub aqui que a gente vai ler, que a gente vai ler aqui, tá? O que que é esse script pub key? Esse cript a melhor forma de pensar nele é como um predicado. Predicado é uma função que retorna verdadeira ou falso. A função f ou uma função p p de x. Uma certa função p dex que o resultado ou é verdadeiro ou é falso. Isso é um predicado. Aí o que que o predicado faz? Ele avalia o x. Você dá para ele um x, ele fala esse x é verdadeiro ou esse x é falso? Tá? E o que que é esse P? Esse P é uma função que você vai você vai escrever, você que vai escrever, tá? A gente vai ver algumas agora, algumas funções aqui, mas é um predicado, tá? Paraa transação ser considerada válida, esse predicado, na hora que da validação, ele precisa retornar o valor verdadeiro para todas as, a gente vai ver aqui, para todas as entradas que você tiver colocando lá. para saídas não, paraas saídas não vão ser avaliados agora, mas já vou mostrar a semântica disso. Lendo esses bytes aqui, o que que tem aí? Tem uma chave pública e tem uma um operador que a gente chama de op check. Pensa um pensa num operador como uma instrução de assembly. Não é muito diferente do que isso, tá? a gente já vou fazer exemplos aqui de como é que essa coisa executa, mas enfim, tem um programinha de computador aí. E o que que tem nas entradas? Tem uma entrada só nessa transação. Tem o TX ID, que é o identificador de uma outra transação e o índice zero. Que que isso quer dizer? Quer dizer que eu tô tentando gastar

a moeda. Tem comoentar um pouqu.

Eu tô tentando gastar

essa transação aqui, essa uma outra transação, tá? Que só tem uma saída e repare que ela não tem entradas. É uma daquelas transções que eu vou chamar de especiais, tá? Ela criou os 50 bitcoins em algum momento. Repare que o criar dinheiro é uma outra transção como é uma transção com motor qualquer. Tem uma saída lá e ela cospis gera, gera 50 bitcoins. E aqui tem a mesma estrutura, tem entradas. O tx id da coin bas vai ser tudo z tudo zero. A gente sabe que é é isso. Acabou. É uma constante. O index vai ser tudo f, tudo um. E a gente sabe que essa combinação é só pode aparecer na Coinbase transaction. Acabou. Tem lá um if else para testar. Ela tem um script SIG, que é um, no caso da Coinbase Transaction, não é um programa, é dados arbitrários. Tipo, tem alguma regra do que que eu tenho que colocar ali, mas em princípio eu posso botar qualquer coisa que eu quiser, tá? Aqui na transação do Satos tem uma assinatura digital. Isso aqui tudo é uma assinatura digital. Bom, do Satos. Tá. Como é que funciona esse esse programa? Deixa eu voltar nesse nessa versão aqui, tá? A sequência das transações tá assim, né? Ó, tem uma transação. Ah, sim. F. Isso. Eu tenho que lembrar. Eu tenho uma transação. Eu vou marcar assim, ó. Não tem, naquele caso particular ali, não tem nenhuma entrada, uma transção especial, tem uma saída. E eu tô olhando, tentando gastar essa uma saída na transação do bloco 170 que eu tô tentando, que é essa que eu tô mostrando ali na tela para vocês. Ela tem duas saídas, uma de uma de 10 e uma de 40. Beleza? Ele tava criando dinheiro. Hã, ele tava criando dinheiro. Calma. Esse aqui criou dinheiro do nada. criou 50 bitcoins do zero, que é o parte da coisa que a gente vai chamar de mineração, parte do pagamento. Essa daqui não, essa daqui entrou 50 e saiu 50. Essa aqui preservou a quantidade monetária no sistema. Ela só mudou de mão, né? Redistribuiu o valor, tá? redistribui o valor. Repare que aqui tinha um programinha de computador

que é bem parecido com esse que tá aqui, ó. Chave pública de alguém. Optig também, que se você for lá, mesma coisa. E aqui no campo que tá aqui no script SIG, tem uma assinatura digital. É isso que tem lá nesse nessa nessa nesse cenário que a gente tá olhando aqui. É isso que tem aí. Tá? Isso precisa ser executado. Por quê? Isso aqui é a função que eu chamei de predicado. E esse cara aqui produz as entradas dessa função.

É isso que vai acontecer. E aí, para essa transação ser considerada válida, o resultado de P de X tem que ser verdadeiro. True. E como é que é a execução dessa coisa, tá? Primeiro a gente vai executar o programa que tá aqui, ó, que produz os dados. Então eu vou lá e executo esse programa. Nesse caso aqui, eu só tenho uma assinatura digital. Essa linguagem de programação é baseada na numa pilha. Então eu tenho dado, botei dado na pilha. Então a minha pilha tá assim, ó. Tem uma assinatura lá no topo da pilha. A pilha tá aqui, ó. Tem uma assinatura no topo da pilha. Aí acabei a execução do lado do X aqui, ó. Bum. Aí eu passo a executar a o lado do P lá na saída. Lá na saída tem

chave pública. Bota a chave pública na pilha. Então eu tenho uma pub que

vai entrar na pilha. Hã, vai entrar uma pub aqui na pilha. Aí a próxima instrução, a próxima coisa que tem ali para fazer é essa instrução. Optck sig. Esse opcheck sig ele ele consome dois dados da pilha, uma pub key, uma assinatura. e valida essa transação é a mensagem. Então, repare, eu tenho uma pub, eu tenho uma assinatura, eu tenho uma mensagem, ele verifica se esse par é válido, ele checa essa assinatura, tá? Então ele consome dois dados da pilha. Então a pilha vai consumir e o resultado vai ser um ou zero. No caso aqui vai ser um porque a gente sabe que é válido. Ele consumiu da pilha. Então ele tirou dois dados da pilha, verificou, produziu o resultado que é um ou zero, botou lá no topo da pilha. É mutable a coisa, né? Stateful.

Stateful com relação à pilha, né? Mas um pouco de cuidado que a gente vai falar um pouco mais sobre o o que que eu consigo usar de para computar aqui, para calcular alguma coisa. Todo mundo OK? E repare que acabei a execução. Se no topo da pilha tem verdadeiro, o predicado é verdadeiro. E aí essa parte da validação vai ser verdadeira. Aí eu vou checar as outras regras, né? Ah, tá gastando dinheiro que não podia, as entr as entradas pagam todas as saídas, enfim. Aí tem as outras regras. Isso aqui é sintaticamente válido. Eu consigo parciar, né? Consigo dessereializar ou não. Tudo isso todo mundo pegou esse tipo de contrato aqui que eu acabei de mostrar para vocês. Eu vou chamar isso aqui de contrato, tá? Isso que tá aqui, ó, na saída de cada transação é um é um contrato. Um contrato estabelece condições. Que que é um contrato? Você que é do direito lá. é um apoio entre duas partes com que estabelece obrigações múas, certo? É, no caso aqui eu tenho um contrato que fala assim: "Quem pode gastar essa saída aqui, ó, de 50 bitcoins ou a tela? Quem pode gastar esse esse essa coisa? qualquer pessoa que conseguir produzir os dados X que satisfazem o contrato que tá escrito aqui. É isso que tá escrito aí.

No caso aqui só dá para tem infinitos dados que satisfazem, tá? Porque a é uma assinatura digital que eu preciso entregar. A assinatura digital não envolve um número aleatório. Então eu posso assinar mesma transação várias vezes e gerar várias assinaturas diferentes, todas válidas. Então tem infinitas soluções. Princípio, tem muitas soluções, tá? Mas eu, nesse caso aqui preciso saber uma chave privada para poder assinar essa coisa. No caso, a chave privada correspondente à chave pública que tá escrita aqui, ó. lá. Chave pública do Opa, a chave pública do Satosche tá escrita no contrato.

E aí isso faz dele o dono dessa coisa. Mas repar que em hora nenhuma a gente falou assim: "O dono dessa saída, o dono dessa dessa saída aqui é o Satos". A gente não falou história nenhuma. A gente falou o seguinte: "Tem um programa de computador aqui, ele é uma função, você vai dar entradas e ele vai determinar falso ou verdadeiro. O dono é quem for capaz de produzir os dados que tornam essa coisa verdadeira no final da execução. Esse é o dono dessa coisa,

professor. É para confirmar que eu recebi uma saída. Então eu tenho que confirmar que existe uma saída para confirmar que eu recebi uma saída. Que que você quer dizer com isso? Vamos supor que eu tô eu vou fazer uma transação com sen Uhum. E eu tô olhando as transações, certo? Uhum. Aí você fala: "Pronto, eu te paguei". Uhum. Essa transação aqui para eu saber que eu recebi, entre aspas, eu tenho que ver que essa transação tem uma saída cujo programa aí confir uma chave pública. Então que eu ten por exemplo, na verdade você precisa conferir, você precisa ficar olhando todas para você perceber que você recebeu um pagamento. Pare, ó, pro pro Ralfine perceber que ele recebeu um pagamento de 10, que que o software que tá que ele tá rodando para você fazer? Você ficar olhando as transações, olhando cada uma das saídas e vendo isso aqui é um programa que eu consigo satisfazer.

Ele tem que se perguntar isso, tá? E isso é um pouco mais complicado do que parece numa primeira vez, num primeiro momento, porque aqui esse programa é bem simples. É, tem uma tem uma PUB, tem uma uma coisa pedindo para checar assinatura. Eu fico só olhando, tipo assim, basicamente eu vou lá olhando e vendo, ah, a chave pública que tá aqui é minha, é uma das minhas. Se não for, não não tenho o que fazer, mas se for uma das minhas, eu sei que aquilo ali é meu paga. É para mim aquilo lá. Eu controlo aquilo lá. Foi dinheiro que eu recebi. É dinheiro que eu controlo. Eu inclusive prefiro chamar de eu controlo o que eu recebi, porque você não recebeu nada. Quem que recebeu o dinheiro? Quem que recebeu essa transação? Para onde que foi essa transação? Essa daqui, ó, onde que ela tá? Hum.

Onde que ela tá? Cadê meu desenho? Olha aqui. Onde que ela tá? Ela tá aqui, ela tá aqui, ela tá aqui. Ela tá aqui.

Seria possível. Então, por exemplo, todo mundo tem que ver ela. Hum.

Tenho um sistema aqui que eu vou fazer Bitcoin, só que eu crio contratos que eles só podem ser satisfeitos. Eh, por exemplo, eh,

dentro desse, desse, não, porque você aceitar o pagamento, se você puder provar que você consegue controlar, tem como você rodar esse predicado sem sem dar um comitção? Tem como você rodar o predicado sem dar um comit numa transação? Eu eu posso rodaramente para ver se eu consigo falar. Não vai ser exatamente assim que funciona, porque precisa aqui eu eu aqui tem uma precisa ter uma cooperação, tá? Precisa ter uma cooperação. Repara uma coisa, isso para isso isso é bem sofisticado, acho que confunde muita gente, que é o seguinte, do o que eu chamo de protocolo Bitcoin é as regras pra gente criar essas transações e criar os blocos. Ponto final, tá? Do ponto de vista do protocolo Bitcoin, disso que eu tô defino como protocolo Bitcoin, o recebedor não participa da transação, só quem tá pagando, porque quem tá pagando escreve isso aqui e propaga pro resto da rede. Quem tá recebendo fica só quietinho lá, tá só olhando as transações, vendo as coisas acontecendo que tá recebendo.

Sim, calma. Mas isso aqui não é totalmente verdade, porque aqui, ó, do lado de cá, hum, pro Satos conseguir pagar alguma coisa pro Ralfini. Cadê a meu? Aqui, aqui, aqui, ó. Pro Satos conseguir pagar alguma coisa pro Ralfini. Foi nessa saída aqui, tá? Foi nessa saída aqui. Detalhes

aqui. Pera aí, eu fiz besteira, né? V. É aqui que eu quero clicar aqui. Tá minha transação. Detalhes. Os scripts estão aqui, ó. Ele paria os scripts. Esse aqui é o o o contrato que o Satos escreveu e colocou na transação. Tá escrito aqui. Isso aqui é uma chave pública, tá? No caso do Ralfine, aí vem uma pergunta. Quem escreveu isso aqui foi o Satoucha. Só que para ele escrever isso aqui, como é que ele como é que ele adivinha a chave pública do do outro cara? Ele precisa lá pro outro cara e perguntar: "Ô, me dá uma chave pública para eu botar aqui?" Então, repare que para o esse pagamento acontecer, precisa ter algum nível de coordenação. Só que esse nível de coordenação acontece fora do protocolo. Como que eu te mando essa chave pública? [ __ ] te mando por e-mail, te mando no zap, eu vou lá, escrevo no papelzinho, te entrego o papelzinho, tanto faz, entendeu? O protocolo Bitcoin não se interessa como que isso acontece, tá? Claro que isso é um problema mais complicado do que parece, porque a gente quer fazer isso de uma forma que tenha pouco erro e não sei o quê, sabe? Assim, de uma forma mais automática e tal, tá? E aí a gente inventou a ideia do endereço.

Endereço de Bitcoin. Que que é o endereço de Bitcoin? Ah, vocês não estão vendo. Que que é o endereço de Bitcoin? Que que é o endereço de Bitcoin? O endereço de Bitcoin é um ó uma estrutura de dados que vai codificar o contrato que precisa ser escrito lá na saída da transção para você ser capaz de gastar depois, entendeu? Então quem é que escreve esse contrato, na verdade é quem tá recebendo agora. Só que isso tá fora, só que isso vai fora do protocolo. Então quando eu vou falo para você, a gente precisa cooperar, eu tô te pagando. Eu Amélia, vou quero te pagar 10 Bitcoin. Escreve o contrato. Aí você escreve um contrato que você sabe que se você escreve um contrato que você não consegue gastar depois, aí não tenho nada a ver com isso, né? Mas você quer escrever um contrato que você consiga controlar depois, entende? Aí você codifica isso no que eu tô chamando de endereço e me passa essas informação. E aí eu decodifico isso do meu lado e crio a transação e escrevo e propago. É isso que no final das contas acontece. Tudo bem? Aí pode ser um Qcode, pode ser uma string que eu umas letras que eu te passo. Isso aí tem um monte de coisa. Todo mundo OK? Falando em contratos, cadê meu caderno de novo? Ah, tá aqui já. Falando em contratos, esse contrato que eu acabei de descrever aqui para vocês, a gente chama, ele tem um nome, tá? A gente chama de pay.

O que que aparece na saída lá no contrato? Aparece uma public, uma chave pública, tá? E eu tô travando aquele fundo para quem conseguir produzir uma assinatura válida para aquela chave pública e a chave pública está no contrato. Então é como se eu tivesse pagando para aquela chave pública, tá? Tá. Qual o problema disso aqui? Tem dois problemas. Qual o problema disso aí?

Vou mostrar de novo o contrato, ó. Tá aqui, ó, esse pedaço laranja que tá destacado. Qual o problema disso aí?

Não, mas assim, olhando aqui, ó, olhando, olha, olha, olha os dados que estão aí. O que que, o que que você vê de problema aí?

É possível. Bora. É para é mais fácilível para quem foi feito. Fica visível. Eu tenho um problema de privacidade, mas não é isso que eu tô que eu esperava, porque ela, o problema que ela, que o que o que o próximo contrato tentar resolver é um problema bem, bem bobo assim, em princípio. E a questão de privacidade entra como quase como um bônus, que nem é privacidade, mas vamos lá. Qual o problema que você tá vendo aí?

Eu não sei quem pagou. Hum, mas você não precisa saber quem pagou.

Dá um chute, vai. Dá uma dica aí, Luiz. Mas se eu tiver três pagamentos de 10 bitcoins e só entrou dois, como é que eu vou saber quem não pagou? Não, você só ver quanto tem de entrada e quanto tem de saída. Quem tá pagando quem não interessa. É só o fluxo do do valor para lá e para cá. Não é isso a questão.

Vocês estão vendo os campos aí, né? Deixa eu botar ele de volta lá. Vocês estão vendo os campos aí, ó? Os bytes estão aí. Qual que é o maior campo em termos de bytes?

O script sig é o que é o que mais ocupa espaço. E espaço é um é escasso aqui. Então vocês estão vendo que o maior coisa que a coisa que ocupa mais espaço é a assinatura. No, esse aí é uma assinatura SDSA que é grande mesmo. O Shinor, assinatura um pouco menor, mas não é tão menor, mas é um pouco menor, tá? Ainda assim tem muito bite aí. Aí uma pergunta é: será que a gente não conseguiria diminuir o tamanho dessa assinatura? Porque se eu diminuir esse tamanho da assinatura, eu vou pagar menos taxa e eu consigo botar mais transações no bloco porque cada uma tá menor. Esse é o problema que o próximo contrato vai tentar resolver. De quebra a gente vai ganhar uma coisa que não era esperada no início, não era uma preocupação, mas é uma, hoje em dia já é uma preocupação maior, que é a minha chave pública tá exposta aí quando eu recebo um pagamento assim. E aí a minha chave pública tá exposta, lembra? A minha chave pública é P é igual a E x G. Tem alguém aí tentando fazer um computador que pega o P, pega o G e calcula o E. A minha chave já tá lá, o P já tá lá. Então ele já tem uns dados que ele precisa para, em princípio fazer o ataque de calcular minha chave pública. Inclusive deve ter gente que tá aí há 15 anos tentando quebrar algumas chaves. S algumas chaves do Satosa. Tá lá 15 anos, vai botando máquina lá e fica tentando, pô. Uma hora. Ah, não, mas isso aí vai demorar milênos. É, mas você pode dar sorte e achar uma 50 bitcoins hoje vale quanto? 1 milhão de dólares. 1 milhão de dólares. Pois é. É 1 milhão de É 5 milhões. 5 milhões. 5 milhões. Segundo o nosso colega aqui. 10 milhão é um bom uma um bom dinheiro. Isso se o Satos não reutilizou a chave. É se ele reutilizou a chave é aquela ali que a gente tá pode ser que a seja um pouco mais que eu consigo gastar, né? Entendeu? Então tem essa questão. Nunca mais usou Sat morreu aí. Ninguém sabe quem é. Ele sumiu e não tá lá parado os dinheiros dele. A gente até sabe mais ou menos quais são os dinheiros dele, mas tá lá parado. O e-mail dele que usava para se comunicar

tinha sido hackeado. Não sei dessa história.

Então, mas enfim, que que a gente pode fazer? Vocês lembram que a gente viu função de é função de hash e assinatura, tá, o tempo todo. Então é a resposta é sempre assim, professor, multiplica uns pontos aí ou soma pontos ou usa uma função de rest de alguma forma, tá? Já vou adiantar, tá bom? Como é que eu posso esconder minha pub?

Passa numa função de hash. A função de hash não esconde. Não tem hiding, binding, propriedades. Pois é. O próximo contrato aqui que a gente vai chamar de pay. Pub hash. Em vez de botar no contrato a Pub direto, eu vou botar o resto da PUB. E aí esse contrato ele é assim, tá? Ele é OP duple OP dup

160. É um hash que tem 160 bits. Eu vou botar o hash aqui, o resto da minha pub ke op equalify

op check.

Tudo bem? Esse aí é o contrato. Essa é a cara desse contrato aí. Aí, repare, ó, lá na hora que você cria um endereço, você não precisa codificar tudo isso aqui. Você pode só me dizer: "Ah, é para você fazer um page pub." Aí eu conheço essa estrutura já tá prédefinida, a gente já escolheu antes. E eu te dou esse hash aqui, ó. Você me dá esse hash. Pronto. Aí eu vou lá e crio isso aqui, boto lá os bytes, boto lá bonitinho na ordem e boto lá na transação, tá? Todo mundo OK? Para destravar isso aqui, que que eu preciso mostrar? Eu preciso mostrar uma assinatura que tem que entrar em algum momento, ela tem que estar no topo da pilha para poder participar do checkig, mas o check precisa de uma pub key também, certo?

Aí eu vou ter que mostrar também a PUB key. A PUB key é a préimagem desse R aqui, ó. E aí, como é que esse script funciona? Eu boto a assinatura na pilha, tá aqui. Eu boto assinatura, boto PUBG key. Aí acabou a parte que tá na entrada da transação. O vermelho é é onde tá é tá na entrada da transação quando eu tô tentando gastar isso aí. O preto dup dup é duplicar. Então pega o P e duplica no topo da pilha. R 160 consome o o topo da pilha e calcula o hash um hash aí no topo da pilha. Aí tem um hash. Então vai entrar um hash aqui no topo da pilha, o que tá no contrato. Aí eu checo se eles são iguais. Esse e verify consome dois dados da pilha. Se eles forem diferentes, eu falho. E aí a coisa é inválida. Se eles forem iguais, eu sigo. Eu não produzo nenhum dado nome na pilha. Eu só prossigo. Que que eu provei até agora? Que que eu provei aqui?

Eu provei que eu sei a pré-imagem daquele hash.

Vocês estão vendo aí? Eu provei que eu sei a pré-imagem do R e o verificador conseguiu verificar que você sabe qual é a PUB key que que é o dono daquela coisa. Aí agora tem um check sig. O check sig consome dois dados do topo da pilha. A transação é a mensagem e ela varia isso aqui. Bom,

isso aqui tem mais letrinhas, mas quando você vê os bytes tem bem menos bytes, tá? Bem menos bytes, menos da metade dos bytes, tá? Só que eu preciso mostrar a PUBK em algum momento. Repare em algum alguém vai ter que pagar por isso, por esses bites. Eu preciso mostrar PUBG em algum momento. Aquela coisa grande vai precisar aparecer, tá? Só que aqui eu tô jogando o custo dessa coisa. Antes estava na saída. Quem é que paga o custo da saída? Não tem o recebedor e o pagador. Esse tem que pagar a coisa. Quem é que paga a taxa da transação? O pagador. O pagador. Então, se tem uma tonelada de coisa lá na saída, é o pagador que tem que botar na saída e o pagador vai ter que pagar. Quem é que produz a entrada? O recebedor que tá tentando pagar no futuro e gastar aquilo, não é? Então eu troquei o ônus da das taxas aqui, ó, do desonerei quem tá pagando e onerei quem tá recebendo, porque quem tá recebendo a hora que for gastar vai precisar botar mais bytes lá. Mas aí você vai ter que dar a sua chave pública também para Eu sempre tenho que ter dar a chave pública. Mas olha só a diferença aqui. Isso, isso você sempre tem que dar, você tem que dar sua chave pública. Aqui eu tenho que dar uma chave de qualquer jeito, nesse caso aqui, tá? Mas é muito diferente um caso do outro que é o seguinte, aqui a chave pública tá exposta, tá exposta no contrato. E aí eu imagino que eu vou ficar com isso aqui 15 anos parado. Tem 15 anos para alguém ficar tentando quebrar essa chave. Aqui não, aqui eu mostrei o um hash e a pessoa sabe que a pré-imagem é uma chave pública, mas ele não sabe qual é. Então, se eu deixar isso 15 anos parado, primeiro o atacante tem que quebrar o resto e calcular uma pré-imagem, que a gente viu que é difícil. Vocês vão fazer um cálculo de pré-imagem aí no numa tarefa, tá? calcular uma préimagem, vocês vão ver que calcular uma colisão é relativamente fácil no jeito que eu calibrei lá, vocês fazem, sei lá, máquina de vocês vai fazer em segundos, mas eu tô pedindo lá no mesmo setup para fazer uma um ataque de pré-imagem e eu acho que a implementação de vocês vai demorar algumas horas, talvez pro mesmo resto. Essa é a ordem de grandeza do da dificuldade, tá? Essa é ordem de dificuldade. Assim, muitas, milhões de vezes mais difícil calcular uma pré-imagem do que calcular um colisão, tá? No caso que ele precisa primeiro atacar o resto e computador quântico não te ajuda nessa nessa conta aqui, pelo menos não que a gente saiba por enquanto. E aí eu revelei, mas eu ah, mas professor, mas eu vou revelar o a PUB key. Aí na hora que eu revelar alguém pode tentar ir lá e quebrar minha PUB key. É, mas olha só, na hora que eu revelei eu tô gastando. Quanto tempo ele tem para tentar quebrar minha coisa? O tempo? Não, o ele tem o tempo, ele tem o tempo até confirmar aquela transação, porque uma vez que confirmou já era, agora acabou. Ele pode calcular achar aquela chave privada, se você não reutilizar já era, não serve para nada mais. Pagamento já foi terminado, finalizado, em média 10 minutos. Então isso diminui muita superfície de ataque. O ataque agora precisa ser rápido também. Aí no além do contrato eu tenho que só que agora quando for dar isso não no no endereço não. Você me dá só o hash no endereço você só me dá o hash e fala que é page pub key. Hash. Você não me dá PUB key. Essa PUB key aqui, ó, vai entrar quando você for gastar o dinheiro que você recebeu de mim lá no futuro, entendeu? Lá no futuro. Lembra disso, ó. Essa é a parte mais complicada do da coisa. Pr na minha opinião, o cont o contrato que tá aqui, ele não executa agora. Ele executa na hora que o recebedor daquele contrato aqui, ó, tentou gastar, aí ele é executado junto com o que tá aqui. A entrada vai ser executada junto com a saída de uma transação anterior. Mas aquela transação que eu tô criando agora, as saídas, elas vão ser executadas agora. Eu não tenho os dados ainda, eu só tenho a função. Eu só tenho o contrato. O dono do contrato, o controlador do contrato, ele precisa gerar os dados. E como é que ele gera esses dados? Com uma nova transação. Então, lá no futuro, quando você decidir gastar, se você decidir gastar, se você não gastar, fica lá. Todo mundo bem até aí? Mas aí quando for pode usar o resto para não deixar a chap,

não, ele tem que cumprir o contrato. O contrato vai executar o programa que tá aqui na vê a gravação do da minha da minha aula de 2024 que eu vou calculando o que é que tem que aparecer aqui, ó. aqui com vocês. Eu tô só falando, ah, é, vai tem que ser assim para gastar. Lá na minha aula do do do 24, eu fiz com mais calma. Eu fui executando essa coisa sem saber quais são as informações que eu tenho que colocar e fui calculando o que que tem que o que que eu tenho que gerar de dados para pro programa ir passando nas etapas que que ele tem que passar. Mas é um programa de computador, você vaiá analisando ele e vai vendo a execução o que que precisa de dados e vai produzindo os dados. Todo mundo bem? Vamos ver um último tipo de contrato aqui. Um último tipo de contrato para aproveitar esse esse tempo aqui.

Um último tipo de contrato. É, vai um último tipo de contrato. Você pode escolher o tipo de contrato. Você pode, você pode fazer o programa que você quiser. Esses contratos que eu tô mostrando para vocês são considerados contratos padrão. Já a gente já conhece. que eles são meio que eles são um padrão assim, eles aparecem o tempo todo, mas você pode fazer o programa que você quiser ali. Inclusive você pode fazer um programa que é assim, ó, o locking script, tá? Vou aproveitar a tua pergunta. Você pode um locking script que é assim, ó, falso.

A última coisa que vai, independente de quanto você vai colocando coisa na pilha, a última coisa que vai acontecer é falso. Então, vai ter falso no topo da pilha. Tu concorda comigo que esse contrato sempre, esse contrato aqui sempre vai ser falso resultado? Não impressa os dados que você dá para ele? Quem é que consegue gastar esse contrato? Ninguém.

Esse é um contrato impossível de você gasto. É umpendable output. Isso aqui é um, a gente chama esse tipo de contrato de no one can spend. Ninguém pode gastar, tá? O falso não é muito comum para fazer para fazer esse tipo de contrato. Ele tem um um operador lá que é o op return. E a semântica do up return é na hora que o up return é executado falha imediatamente. Então se no teu programa tem lá no caminho, no meio do caminho um up return, aquele programa, aquele programa você já sabe que ele ele sempre falha, não tem como gastar também. Qual a vantagem de usar um appunto? Quando eu vejo o apur em qualquer lugar do meu programa, se se eu ver que vai passar pelo up return, eu já sei que não tem como gastar. Então eu já sei que eu não preciso nem eu não preciso nem guardar aquela, aquela moeda ali no meu banco de dados, porque ninguém consegue gastar mesmo. Então já nem me preocupo com ela. Fazer isso, qual seria a vantagem de alguém fazer isso? alguém fazer NFT, alguém fazer botar dados arbitrários na blockchain. Só que eu quero mostrar para vocês um pouco mais para frente como é que faz isso. O return é uma forma de você fazer isso, você botar a figurinha de macaco lá na no na transação. Esse aqui, ó, participou no Racatô agora e botou a figurinha de um bonequinho. Como é que é o nome do bonequinho? Labubo. Labubo. Vocês devem saber se vocês estão rindo. Não sabia nem o que que era um bonequinho japonês aí, né? Eu acho. Também não sabia não. É. Enfim. É, ele fez um protocolo aí que bota bonequinho japonês na na blockchain. Na blockchain. É, tá criando shitcoin, spamando a parada. Mas enfim, tem forma de fazer. Tem uma questão de fungibilidade aí na parada. Tudo bem? Mas eu preciso você precisa entender o básico de como é que o contrato funciona. Outro tipo de contrato que você pode fazer, outro tipo de contrato que você pode fazer é, por exemplo, true. Então, você vai lá, enche, enche a pilha de coisa. blá, né, com os dados entradas. Aí a última coisa que vai executar é true. Vai ficar verdadeiro no topo da pilha. Então esse contrato é sempre verdadeiro. Quem que é o dono desse desse contrato?

Qualquer um. O primeiro que tentar gastar vai conseguir gastar, não é? Tu concorda? Se eu qualquer um que tentar gastar, isso aqui já vai ser verdadeiro. Pum! Ah, foi, gastou. A gente chama isso aí de anyone can spend. Esse é meio, esse é meio idiota, tá? Esse normalmente você não quer fazer o N1P. É uma doação pro minador, basicamente. Basicamente assim fíar, botar taxa, enfim, que na prática vai virar tudo taxa mesmo, tá? Mas por fim, Penc, tem utilidade, tá? Não é assim inútil não, mas isso aqui a gente pode fazer, mas isso é considerado não standar. Isso aqui tem uma dificuldade de propagação na rede. Vou comentar isso mais pro futuro. Tem um outro tipo de contrato que eu quero comentar agora, que é o pay script hash. Se tem hash no nome, vai aparecer o hash no contrato. Mas ao contrário de ser o hash de uma PUB, é o resto de um outro programa. Agora eu quero esconder até o programa que vai rodar. Ele é assim, ó. Ele é assim. OP. contratos enviam um programa compilado. Não é exatamente compilado, mas enfim, ele é assim, ó. OP hash 160 um hash opo.

E como é que é o unlock dele? Como é que eu faço para destravar esse contrato? Eu coloco que eu vou chamar aqui de data. Aí pode ser vários campos, depende do script que vai entrar ali, tá? E a última coisa que eu coloco aqui é o programa que de fato eu quero que execute.

É de fato um programa que eu quero que execute. Pode ser um programa bem grandão, inclusive uma multisig, sei lá, um programa bem complexo, tá? Aí, como é que é a execução desse negócio? Vai entrar os dados, vai entrar lá os dados na pilha. Bum, bum, bum. Aí a última coisa que entra é o script. Aí eu consumo o script.

Calculei um hash, entrou um hash que tá no contrato e eu vou comparar essas duas coisas. Se as duas coisas forem iguais, consumi. E sobrou os dados. Aí tem uma regra especial lá no programa que quando ele vê esse padrão aqui, ó, ele fica, o avaliador fica executando os cada uma das coisas. Ele, ah, executei exatamente isso aqui. E ophos bytes, 20 bytes de 20 bytes, para ele é um hash mais 20 bytes quais que é. e o byte do apic. Na hora que ele vê esse padrão e ele executou, se isso aqui não falhou nesse momento, o que que ele vai fazer? Ele vai pegar esse script aqui, ó, que tá aqui, que foi validado, que é o script, que é a pré-imagem desse R. Então, meio que a gente fala, ó, isso aqui é o script correto que tá no contrato, que o contrato comitou, que o contrato se comprometeu com aquele programa ali, lembra disso, tá? Ele vai passar a executar esse script. Então ele vai lá parcer esse script agora, pode ser grandão e ele continua executando com os dados que tiverem aqui na pilha nesse momento, tá? Para que que serve isso? Para eu esconder o programa. Mas para que que serve isso? Para eu esconder o programa que vai ser de fato executado. Tô escondendo atrás de um hash. E aí, repare, isso aqui tem duas coisas, tá? duas implicações. Primeiro, o RH, em princípio, é bem menor que o programa, porque senão não vale a pena fazer isso. O R tem 20 bytes e um programa qual que sei lá, você faz um programa lá, sei lá, 200 bytes, 300 bytes, 500 byes, sei lá, grande, tá? Então, princípio ocupa menos espaço para quem tá pagando. Depois quem for gastar vai ter que mostrar esse script de qualquer jeito, vai ter que os dados tem que aparecer uma hora, tá? Os dados tm que aparecer alguma hora. Só que também tem uma implicação de privacidade, porque esse contrato pode envolver chave pública de um monte de gente que eu não quero mostrar, tá certo? Que na hora de gastar vou ter que mostrar a [ __ ] toda, tá? E aí para resolver essa parada aqui, ó, de humos interessante eu puder eu poder só mostrar as partes do programa que interessam num certo momento. Eu não preciso mostrar tudo também. Como é que eu escondo a informação? com hash eu escondo atrás de um hash. Então eu posso pensar que dentro do script eu posso organizar com um monte de hash pedaços dos scripts, pedaços do programa. Faz um pedaço ali, é o hash uma função aqui, uma função ali e tal, pensa assim, mais ou menos separar nessa coisa e eu só revelo as partes que me interessam. Isso aí é o que a gente vai fazer num upgrade que é mais é 2019, tap 2021 teve um upgrade chama Tot

que introduziu duas coisas interessantes que é isso que eu tô falando agora, esconder pedaços do script só mostrar a parte que interessa. E aí a partir desse momento eu posso ter scripts imensos, gigantescos, que não tem problema, porque eu nunca preciso mostrar o script inteiro, gigantesco. Posso ter script com gigabytes e não tem problema porque na hora de executar eu vou falar para você, ah, executo só essa parte aqui, ó. Bum, e aí é um pedacinho bem pequenininho dele. E aí eu provo para você com um monte de hashs lá, que vou mostrar como faz. Prova com um monte de R que aquele script tava lá de fato no contrato, era parte do contrato. Mas o script completo tá lá na nessa transação. A gente vai ver como é que constrói esse tipo de coisa, tá? Vou mostrar na aula que vem a construção básica, porque isso também usa nos blocos e vocês vão entender como é que eu uso aqui, tá? Vai mostrar claro se é código de fonte, código de máquina, é tudo código já de máquina que vai entrar tudo código de máquina. Tudo código de máquina. É, mas é a gente escreve direto o código de máquina.